Input => xxx | 1 | xxxx | 2222 | 3333 | xxxx | xxx | 4 | 55 | x | x | 6666
Input xxx | 1 | xxxx | 2222 | 3333 | xxxx | xxx | 4 | 55 | x | x | 6666
Input xxx1xxxx22223333xxxxxxx455xx6666
31 => x
30 => x
29 => x
28 => 1
27 => x
26 => x
25 => x
24 => x
23 => 2
22 => 2
21 => 2
21 => 2 22
20 => 2
20 => 2 21
19 => 3
18 => 3
17 => 3
17 => 3 18
16 => 3
16 => 3 17
15 => x
14 => x
13 => x
12 => x
11 => x
10 => x
9 => x
8 => 4
7 => 5
6 => 5
5 => x
4 => x
3 => 6
2 => 6
1 => 6
1 => 6 2
0 => 6
0 => 6 1
Constructed mask!
Ret : {
    struct Parsed
    {
        pub ident_1 : u32, pub ident_2 : u32, pub ident_4 : u32, pub ident_6 :
        u32, pub ident_3 : u32, pub ident_5 : u32,
    } impl Parsed
    {
        const fn mask < const START : usize, const END : usize > (val : u32)
        -> u32
        {
            let intermediate = val >> START; let mask =
            ((1 << (END - START + 1) as u32) as u32) - 1u32; let ret =
            intermediate & mask; assert! (ret <= mask); ret
        } const fn parse(mut self, value : u32) ->
        (u32, u32, u32, u32, u32, u32)
        {
            self.ident_1 = Self :: mask :: < 28usize, 28usize > (value);
            self.ident_2 = Self :: mask :: < 20usize, 23usize > (value);
            self.ident_4 = Self :: mask :: < 8usize, 8usize > (value);
            self.ident_6 = Self :: mask :: < 0usize, 3usize > (value);
            self.ident_3 = Self :: mask :: < 16usize, 19usize > (value);
            self.ident_5 = Self :: mask :: < 6usize, 7usize > (value);
            (self.ident_1, self.ident_2, self.ident_4, self.ident_6,
            self.ident_3, self.ident_5)
        } const fn zero() -> Self
        {
            Self
            {
                ident_1 : 0, ident_2 : 0, ident_4 : 0, ident_6 : 0, ident_3 :
                0, ident_5 : 0,
            }
        }
    } Parsed :: zero().parse(word)
}
#![feature(prelude_import)]
//! Defines an instruction decoder for the Armv7-m instruction set.
//!
//! The main export of this crate is the [`ASM`] object, which can be
//! constructed by [`parsing`](ASM::parse) from a byte
//! [`Stream`].
//!
//!
//! ## Usage
//!
//! This crate assumes that you have access to an iterable set of bytes that
//! represents an ArmV7-m program
//!
//! ```
//! use disarmv7::prelude::*;
//! use std::{
//!     iter::IntoIterator,
//!     fmt::Debug
//! };
//!
//!
//! // Decodes a single operation from the Vector of bytes.
//! fn decode(bin:Vec<u8>) -> Operation {
//!     let mut stream = PeekableBuffer::from(bin.into_iter());
//!     let instr = Operation::parse(&mut stream).expect("Parser broken").1;
//!     instr
//! }
//!
//! let mut bin = vec![];
//! bin.extend([0b11110100u8, 0b11001100u8].into_iter().rev());
//! bin.extend([0b10101000u8, 0b00000011u8].into_iter().rev());
//!
//! let instr = decode(bin);
//!
//! let imm = Imm21::try_from(0b111001100000000000110u32).unwrap().sign_extend();
//!
//! let cond: Condition = Condition::try_from(0b11u8).expect("Test is malformed");
//!
//! let target: Operation = operation::B::builder()
//!     .set_imm(imm)
//!     .set_condition(cond)
//!     .complete()
//!     .into();
//! assert_eq!(instr, target)
//! ```
//!
//! While the above usage might be the most common usage in libraries one can
//! also use the library to decode multiple instructions in one pass.
//!
//! ```
//! use disarmv7::prelude::*;
//! use arch::set_flags::SetFlags;
//! use std::{
//!     iter::IntoIterator,
//!     fmt::Debug
//! };
//!
//!
//! // Decodes a set of operations from the Vector of bytes.
//! fn decode(bin:Vec<u8>) -> ASM {
//!     let mut stream = PeekableBuffer::from(bin.into_iter());
//!     let instr = ASM::parse(&mut stream).unwrap();
//!     instr
//! }
//!
//! let mut bin = vec![];
//! bin.extend([0b11110100u8, 0b11001100u8].into_iter().rev());
//! bin.extend([0b10101000u8, 0b00000011u8].into_iter().rev());
//!
//! bin.extend([0b01000000u8, 0b10000011u8].into_iter().rev());
//!
//! let instr = decode(bin);
//!
//! let imm = Imm21::try_from(0b111001100000000000110u32).unwrap().sign_extend();
//!
//! let cond: Condition = Condition::try_from(0b11u8).expect("Test is malformed");
//!
//! let target: Vec<(usize,Operation)> = vec![
//!     (
//!         32,
//!         operation::B::builder()
//!             .set_imm(imm)
//!             .set_condition(cond)
//!             .complete()
//!             .into()
//!     ),
//!     (
//!         16,
//!         operation::LslRegister::builder()
//!             .set_s(Some(SetFlags::InITBlock(false)))
//!             .set_rd(Register::R3)
//!             .set_rm(Register::R0)
//!             .set_rn(Register::R3)
//!             .complete()
//!             .into()
//!     )
//! ];
//! let instr: Vec<(usize,Operation)> = instr.into();
//!
//! assert_eq!(instr, target)
//! ```
#![deny(clippy::all)]
#![deny(warnings)]
#![deny(missing_docs)]
#![deny(rustdoc::all)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod arch {
    //! Defines a few architecture specific types and how to parse them.
    //!
    //! This is mainly a helper crate for the [`disarmv7`](https://github.com/ivario123/dissarmv7) crate.
    //! For further documentation please refer to that crate.
    #![deny(clippy::all)]
    #![deny(missing_docs)]
    #![deny(warnings)]
    #![deny(rustdoc::all)]
    #![deny(rustdoc::broken_intra_doc_links)]
    pub mod condition {
        //! Defines the [`Condition`] codes that are defined in the Armv7-m instruction
        //! set..
        use crate::ArchError;
        /// Derived from section A7.3
        pub enum Condition {
            /// Exactly equal to, z == 1
            Eq,
            /// Not equal to, z == 0
            Ne,
            /// Carry set, C == 1
            Cs,
            /// Carry clear, C == 0
            Cc,
            /// Minus, negative N == 1
            Mi,
            /// Plus, positive or zero, N >= 0
            Pl,
            /// Overflow, V  == 1
            Vs,
            /// Not Overflow, V == 0
            Vc,
            /// Unsigned higher, C == 1 && z == 0
            Hi,
            /// Unsigned lower, C == 0 && z == 1
            Ls,
            /// Signed greater or equal, N == V
            Ge,
            /// Signed less than, N != V
            Lt,
            /// Signed greater than, Z == 0 && N == V
            Gt,
            /// Signed less than or equal, Z == 1 && N!=V
            Le,
            /// Unconditional
            None,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Condition {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Condition::Eq => "Eq",
                        Condition::Ne => "Ne",
                        Condition::Cs => "Cs",
                        Condition::Cc => "Cc",
                        Condition::Mi => "Mi",
                        Condition::Pl => "Pl",
                        Condition::Vs => "Vs",
                        Condition::Vc => "Vc",
                        Condition::Hi => "Hi",
                        Condition::Ls => "Ls",
                        Condition::Ge => "Ge",
                        Condition::Lt => "Lt",
                        Condition::Gt => "Gt",
                        Condition::Le => "Le",
                        Condition::None => "None",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Condition {
            #[inline]
            fn clone(&self) -> Condition {
                match self {
                    Condition::Eq => Condition::Eq,
                    Condition::Ne => Condition::Ne,
                    Condition::Cs => Condition::Cs,
                    Condition::Cc => Condition::Cc,
                    Condition::Mi => Condition::Mi,
                    Condition::Pl => Condition::Pl,
                    Condition::Vs => Condition::Vs,
                    Condition::Vc => Condition::Vc,
                    Condition::Hi => Condition::Hi,
                    Condition::Ls => Condition::Ls,
                    Condition::Ge => Condition::Ge,
                    Condition::Lt => Condition::Lt,
                    Condition::Gt => Condition::Gt,
                    Condition::Le => Condition::Le,
                    Condition::None => Condition::None,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Condition {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Condition {
            #[inline]
            fn eq(&self, other: &Condition) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        /// If then Else block
        ///
        /// This type defines how to [`Parse`](ITCondition::from)
        /// the condition vector from a base [`Condition`] and a mask.
        pub struct ITCondition {
            /// The conditions that need to be satisfied for
            /// the next few instructions to be executed.
            ///
            /// i.e. to execute instruction `i` the condition
            /// `conditions[i]` must evaluate to true.
            pub conditions: Vec<Condition>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ITCondition {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ITCondition",
                    "conditions",
                    &&self.conditions,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ITCondition {
            #[inline]
            fn clone(&self) -> ITCondition {
                ITCondition {
                    conditions: ::core::clone::Clone::clone(&self.conditions),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ITCondition {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ITCondition {
            #[inline]
            fn eq(&self, other: &ITCondition) -> bool {
                self.conditions == other.conditions
            }
        }
        impl Condition {
            fn invert(&self) -> Self {
                match self {
                    Self::Eq => Self::Ne,
                    Self::Ne => Self::Eq,
                    Self::Cs => Self::Cc,
                    Self::Cc => Self::Cs,
                    Self::Mi => Self::Pl,
                    Self::Pl => Self::Mi,
                    Self::Vs => Self::Vc,
                    Self::Vc => Self::Vs,
                    Self::Hi => Self::Ls,
                    Self::Ls => Self::Hi,
                    Self::Ge => Self::Lt,
                    Self::Lt => Self::Ge,
                    Self::Gt => Self::Le,
                    Self::Le => Self::Gt,
                    Self::None => Self::None,
                }
            }
        }
        impl From<(Condition, u8)> for ITCondition {
            fn from(value: (Condition, u8)) -> Self {
                let mask = value.1;
                let cond = value.0;
                let condition_code: u8 = cond.clone().into();
                let condition = condition_code & 0b1;
                if mask == 0b1000 {
                    return Self {
                        conditions: <[_]>::into_vec(::alloc::boxed::box_new([cond])),
                    };
                }
                let x = {
                    if (mask & 0b1000) >> 3 == condition {
                        cond.clone()
                    } else {
                        cond.invert()
                    }
                };
                if mask & 0b111 == 0b100 {
                    return Self {
                        conditions: <[_]>::into_vec(::alloc::boxed::box_new([cond, x])),
                    };
                }
                let y = {
                    if (mask & 0b100) >> 2 == condition {
                        cond.clone()
                    } else {
                        cond.invert()
                    }
                };
                if mask & 0b11 == 0b10 {
                    return Self {
                        conditions: <[_]>::into_vec(
                            ::alloc::boxed::box_new([cond, x, y]),
                        ),
                    };
                }
                let z = {
                    if (mask & 0b10) >> 1 == condition {
                        cond.clone()
                    } else {
                        cond.invert()
                    }
                };
                Self {
                    conditions: <[_]>::into_vec(::alloc::boxed::box_new([cond, x, y, z])),
                }
            }
        }
        impl From<ITCondition> for Vec<Condition> {
            fn from(val: ITCondition) -> Self {
                val.conditions
            }
        }
        impl TryFrom<u8> for Condition {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                Ok(
                    match value {
                        0b0 => Self::Eq,
                        0b1 => Self::Ne,
                        0b10 => Self::Cs,
                        0b11 => Self::Cc,
                        0b100 => Self::Mi,
                        0b101 => Self::Pl,
                        0b110 => Self::Vs,
                        0b111 => Self::Vc,
                        0b1000 => Self::Hi,
                        0b1001 => Self::Ls,
                        0b1010 => Self::Ge,
                        0b1011 => Self::Lt,
                        0b1100 => Self::Gt,
                        0b1101 => Self::Le,
                        0b1110 => Self::None,
                        _ => return Err(ArchError::InvalidCondition),
                    },
                )
            }
        }
        impl From<Condition> for u8 {
            fn from(value: Condition) -> Self {
                match value {
                    Condition::Eq => 0,
                    Condition::Ne => 0b1,
                    Condition::Cs => 0b10,
                    Condition::Cc => 0b11,
                    Condition::Mi => 0b100,
                    Condition::Pl => 0b101,
                    Condition::Vs => 0b110,
                    Condition::Vc => 0b111,
                    Condition::Hi => 0b1000,
                    Condition::Ls => 0b1001,
                    Condition::Ge => 0b1010,
                    Condition::Lt => 0b1011,
                    Condition::Gt => 0b1100,
                    Condition::Le => 0b1101,
                    Condition::None => 0b1110,
                }
            }
        }
        impl TryFrom<u16> for Condition {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                Self::try_from(value as u8)
            }
        }
    }
    pub mod coproc {
        //! Defines the standard [`co processor`](CoProcessor) ids.
        use crate::ArchError;
        #[repr(u8)]
        /// Enumerates the co processors that are available
        /// to the system
        #[allow(missing_docs)]
        pub enum CoProcessor {
            P0,
            P1,
            P2,
            P3,
            P4,
            P5,
            P6,
            P7,
            P8,
            P9,
            P10,
            P11,
            P12,
            P13,
            P14,
            P15,
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::fmt::Debug for CoProcessor {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        CoProcessor::P0 => "P0",
                        CoProcessor::P1 => "P1",
                        CoProcessor::P2 => "P2",
                        CoProcessor::P3 => "P3",
                        CoProcessor::P4 => "P4",
                        CoProcessor::P5 => "P5",
                        CoProcessor::P6 => "P6",
                        CoProcessor::P7 => "P7",
                        CoProcessor::P8 => "P8",
                        CoProcessor::P9 => "P9",
                        CoProcessor::P10 => "P10",
                        CoProcessor::P11 => "P11",
                        CoProcessor::P12 => "P12",
                        CoProcessor::P13 => "P13",
                        CoProcessor::P14 => "P14",
                        CoProcessor::P15 => "P15",
                    },
                )
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::Copy for CoProcessor {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for CoProcessor {
            #[inline]
            fn clone(&self) -> CoProcessor {
                *self
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::StructuralPartialEq for CoProcessor {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::cmp::PartialEq for CoProcessor {
            #[inline]
            fn eq(&self, other: &CoProcessor) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        impl TryFrom<u8> for CoProcessor {
            type Error = ArchError;
            #[allow(unused_assignments)]
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                let mut i = 0;
                if value == i {
                    return Ok(Self::P0);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P1);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P2);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P3);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P4);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P5);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P6);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P7);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P8);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P9);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P10);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P11);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P12);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P13);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P14);
                }
                i += 1;
                if value == i {
                    return Ok(Self::P15);
                }
                i += 1;
                Err(ArchError::InvalidRegister(value))
            }
        }
        impl From<CoProcessor> for u8 {
            #[allow(unused_assignments)]
            fn from(val: CoProcessor) -> u8 {
                let mut i = 0;
                if CoProcessor::P0 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P1 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P2 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P3 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P4 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P5 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P6 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P7 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P8 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P9 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P10 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P11 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P12 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P13 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P14 == val {
                    return i;
                }
                i += 1;
                if CoProcessor::P15 == val {
                    return i;
                }
                i += 1;
                ::core::panicking::panic("internal error: entered unreachable code");
            }
        }
        impl TryFrom<u16> for CoProcessor {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                (value as u8).try_into()
            }
        }
    }
    pub mod register {
        //! Defines the [`Register`]s that are available in the system.
        use crate::{ArchError, ParseError};
        #[repr(u8)]
        ///Enumerates the registers that are available to the system
        #[allow(missing_docs)]
        pub enum Register {
            R0,
            R1,
            R2,
            R3,
            R4,
            R5,
            R6,
            R7,
            R8,
            R9,
            R10,
            R11,
            R12,
            SP,
            LR,
            PC,
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::fmt::Debug for Register {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Register::R0 => "R0",
                        Register::R1 => "R1",
                        Register::R2 => "R2",
                        Register::R3 => "R3",
                        Register::R4 => "R4",
                        Register::R5 => "R5",
                        Register::R6 => "R6",
                        Register::R7 => "R7",
                        Register::R8 => "R8",
                        Register::R9 => "R9",
                        Register::R10 => "R10",
                        Register::R11 => "R11",
                        Register::R12 => "R12",
                        Register::SP => "SP",
                        Register::LR => "LR",
                        Register::PC => "PC",
                    },
                )
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::Copy for Register {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for Register {
            #[inline]
            fn clone(&self) -> Register {
                *self
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::StructuralPartialEq for Register {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::cmp::PartialEq for Register {
            #[inline]
            fn eq(&self, other: &Register) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        impl TryFrom<u8> for Register {
            type Error = ArchError;
            #[allow(unused_assignments)]
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                let mut i = 0;
                if value == i {
                    return Ok(Self::R0);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R1);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R2);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R3);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R4);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R5);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R6);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R7);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R8);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R9);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R10);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R11);
                }
                i += 1;
                if value == i {
                    return Ok(Self::R12);
                }
                i += 1;
                if value == i {
                    return Ok(Self::SP);
                }
                i += 1;
                if value == i {
                    return Ok(Self::LR);
                }
                i += 1;
                if value == i {
                    return Ok(Self::PC);
                }
                i += 1;
                Err(ArchError::InvalidRegister(value))
            }
        }
        impl From<Register> for u8 {
            #[allow(unused_assignments)]
            fn from(val: Register) -> u8 {
                let mut i = 0;
                if Register::R0 == val {
                    return i;
                }
                i += 1;
                if Register::R1 == val {
                    return i;
                }
                i += 1;
                if Register::R2 == val {
                    return i;
                }
                i += 1;
                if Register::R3 == val {
                    return i;
                }
                i += 1;
                if Register::R4 == val {
                    return i;
                }
                i += 1;
                if Register::R5 == val {
                    return i;
                }
                i += 1;
                if Register::R6 == val {
                    return i;
                }
                i += 1;
                if Register::R7 == val {
                    return i;
                }
                i += 1;
                if Register::R8 == val {
                    return i;
                }
                i += 1;
                if Register::R9 == val {
                    return i;
                }
                i += 1;
                if Register::R10 == val {
                    return i;
                }
                i += 1;
                if Register::R11 == val {
                    return i;
                }
                i += 1;
                if Register::R12 == val {
                    return i;
                }
                i += 1;
                if Register::SP == val {
                    return i;
                }
                i += 1;
                if Register::LR == val {
                    return i;
                }
                i += 1;
                if Register::PC == val {
                    return i;
                }
                i += 1;
                ::core::panicking::panic("internal error: entered unreachable code");
            }
        }
        #[repr(u8)]
        ///Enumerates the registers that are available to the system
        #[allow(missing_docs)]
        pub enum F64Register {
            D0,
            D1,
            D2,
            D3,
            D4,
            D5,
            D6,
            D7,
            D8,
            D9,
            D10,
            D11,
            D12,
            D13,
            D14,
            D16,
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::fmt::Debug for F64Register {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        F64Register::D0 => "D0",
                        F64Register::D1 => "D1",
                        F64Register::D2 => "D2",
                        F64Register::D3 => "D3",
                        F64Register::D4 => "D4",
                        F64Register::D5 => "D5",
                        F64Register::D6 => "D6",
                        F64Register::D7 => "D7",
                        F64Register::D8 => "D8",
                        F64Register::D9 => "D9",
                        F64Register::D10 => "D10",
                        F64Register::D11 => "D11",
                        F64Register::D12 => "D12",
                        F64Register::D13 => "D13",
                        F64Register::D14 => "D14",
                        F64Register::D16 => "D16",
                    },
                )
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::Copy for F64Register {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for F64Register {
            #[inline]
            fn clone(&self) -> F64Register {
                *self
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::StructuralPartialEq for F64Register {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::cmp::PartialEq for F64Register {
            #[inline]
            fn eq(&self, other: &F64Register) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        impl TryFrom<u8> for F64Register {
            type Error = ArchError;
            #[allow(unused_assignments)]
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                let mut i = 0;
                if value == i {
                    return Ok(Self::D0);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D1);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D2);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D3);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D4);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D5);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D6);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D7);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D8);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D9);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D10);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D11);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D12);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D13);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D14);
                }
                i += 1;
                if value == i {
                    return Ok(Self::D16);
                }
                i += 1;
                Err(ArchError::InvalidRegister(value))
            }
        }
        impl From<F64Register> for u8 {
            #[allow(unused_assignments)]
            fn from(val: F64Register) -> u8 {
                let mut i = 0;
                if F64Register::D0 == val {
                    return i;
                }
                i += 1;
                if F64Register::D1 == val {
                    return i;
                }
                i += 1;
                if F64Register::D2 == val {
                    return i;
                }
                i += 1;
                if F64Register::D3 == val {
                    return i;
                }
                i += 1;
                if F64Register::D4 == val {
                    return i;
                }
                i += 1;
                if F64Register::D5 == val {
                    return i;
                }
                i += 1;
                if F64Register::D6 == val {
                    return i;
                }
                i += 1;
                if F64Register::D7 == val {
                    return i;
                }
                i += 1;
                if F64Register::D8 == val {
                    return i;
                }
                i += 1;
                if F64Register::D9 == val {
                    return i;
                }
                i += 1;
                if F64Register::D10 == val {
                    return i;
                }
                i += 1;
                if F64Register::D11 == val {
                    return i;
                }
                i += 1;
                if F64Register::D12 == val {
                    return i;
                }
                i += 1;
                if F64Register::D13 == val {
                    return i;
                }
                i += 1;
                if F64Register::D14 == val {
                    return i;
                }
                i += 1;
                if F64Register::D16 == val {
                    return i;
                }
                i += 1;
                ::core::panicking::panic("internal error: entered unreachable code");
            }
        }
        #[repr(u8)]
        ///Enumerates the registers that are available to the system
        #[allow(missing_docs)]
        pub enum F32Register {
            S0,
            S1,
            S2,
            S3,
            S4,
            S5,
            S6,
            S7,
            S8,
            S9,
            S10,
            S11,
            S12,
            S13,
            S14,
            S15,
            S16,
            S17,
            S18,
            S19,
            S21,
            S22,
            S23,
            S24,
            S25,
            S26,
            S27,
            S28,
            S29,
            S30,
            S31,
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::fmt::Debug for F32Register {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        F32Register::S0 => "S0",
                        F32Register::S1 => "S1",
                        F32Register::S2 => "S2",
                        F32Register::S3 => "S3",
                        F32Register::S4 => "S4",
                        F32Register::S5 => "S5",
                        F32Register::S6 => "S6",
                        F32Register::S7 => "S7",
                        F32Register::S8 => "S8",
                        F32Register::S9 => "S9",
                        F32Register::S10 => "S10",
                        F32Register::S11 => "S11",
                        F32Register::S12 => "S12",
                        F32Register::S13 => "S13",
                        F32Register::S14 => "S14",
                        F32Register::S15 => "S15",
                        F32Register::S16 => "S16",
                        F32Register::S17 => "S17",
                        F32Register::S18 => "S18",
                        F32Register::S19 => "S19",
                        F32Register::S21 => "S21",
                        F32Register::S22 => "S22",
                        F32Register::S23 => "S23",
                        F32Register::S24 => "S24",
                        F32Register::S25 => "S25",
                        F32Register::S26 => "S26",
                        F32Register::S27 => "S27",
                        F32Register::S28 => "S28",
                        F32Register::S29 => "S29",
                        F32Register::S30 => "S30",
                        F32Register::S31 => "S31",
                    },
                )
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::Copy for F32Register {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for F32Register {
            #[inline]
            fn clone(&self) -> F32Register {
                *self
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::StructuralPartialEq for F32Register {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::cmp::PartialEq for F32Register {
            #[inline]
            fn eq(&self, other: &F32Register) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        impl TryFrom<u8> for F32Register {
            type Error = ArchError;
            #[allow(unused_assignments)]
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                let mut i = 0;
                if value == i {
                    return Ok(Self::S0);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S1);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S2);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S3);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S4);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S5);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S6);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S7);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S8);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S9);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S10);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S11);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S12);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S13);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S14);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S15);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S16);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S17);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S18);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S19);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S21);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S22);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S23);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S24);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S25);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S26);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S27);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S28);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S29);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S30);
                }
                i += 1;
                if value == i {
                    return Ok(Self::S31);
                }
                i += 1;
                Err(ArchError::InvalidRegister(value))
            }
        }
        impl From<F32Register> for u8 {
            #[allow(unused_assignments)]
            fn from(val: F32Register) -> u8 {
                let mut i = 0;
                if F32Register::S0 == val {
                    return i;
                }
                i += 1;
                if F32Register::S1 == val {
                    return i;
                }
                i += 1;
                if F32Register::S2 == val {
                    return i;
                }
                i += 1;
                if F32Register::S3 == val {
                    return i;
                }
                i += 1;
                if F32Register::S4 == val {
                    return i;
                }
                i += 1;
                if F32Register::S5 == val {
                    return i;
                }
                i += 1;
                if F32Register::S6 == val {
                    return i;
                }
                i += 1;
                if F32Register::S7 == val {
                    return i;
                }
                i += 1;
                if F32Register::S8 == val {
                    return i;
                }
                i += 1;
                if F32Register::S9 == val {
                    return i;
                }
                i += 1;
                if F32Register::S10 == val {
                    return i;
                }
                i += 1;
                if F32Register::S11 == val {
                    return i;
                }
                i += 1;
                if F32Register::S12 == val {
                    return i;
                }
                i += 1;
                if F32Register::S13 == val {
                    return i;
                }
                i += 1;
                if F32Register::S14 == val {
                    return i;
                }
                i += 1;
                if F32Register::S15 == val {
                    return i;
                }
                i += 1;
                if F32Register::S16 == val {
                    return i;
                }
                i += 1;
                if F32Register::S17 == val {
                    return i;
                }
                i += 1;
                if F32Register::S18 == val {
                    return i;
                }
                i += 1;
                if F32Register::S19 == val {
                    return i;
                }
                i += 1;
                if F32Register::S21 == val {
                    return i;
                }
                i += 1;
                if F32Register::S22 == val {
                    return i;
                }
                i += 1;
                if F32Register::S23 == val {
                    return i;
                }
                i += 1;
                if F32Register::S24 == val {
                    return i;
                }
                i += 1;
                if F32Register::S25 == val {
                    return i;
                }
                i += 1;
                if F32Register::S26 == val {
                    return i;
                }
                i += 1;
                if F32Register::S27 == val {
                    return i;
                }
                i += 1;
                if F32Register::S28 == val {
                    return i;
                }
                i += 1;
                if F32Register::S29 == val {
                    return i;
                }
                i += 1;
                if F32Register::S30 == val {
                    return i;
                }
                i += 1;
                if F32Register::S31 == val {
                    return i;
                }
                i += 1;
                ::core::panicking::panic("internal error: entered unreachable code");
            }
        }
        #[repr(u8)]
        /// Represents the floating point status register in the Armv7em spec.
        pub enum FPSCR {
            /// Set to true if the previous operations result value is negative.
            N,
            /// Set to true if the previous operations result value is zero.
            Z,
            /// Set to true if the previous operation resulted in a carry.
            C,
            /// Set to true if the previous operation resulted in overflow.
            V,
            /// Set to true if alternate half precission operations should be used.
            ///
            /// 0. IEEE 754-2008 specification.
            /// 1. Alternative half-precision format selected.
            ///
            /// See Floating-point half-precision formats for details.
            AHP,
            /// Wether or not to propegate NaN values.
            ///
            /// 0. NaN values propegate.
            /// 1. Any operations containing one or more NaN values return NaN.
            DN,
            /// Wether or not to flush to zero.
            ///
            /// If this is true it breaks compliance with the IEEE754 standard.
            ///
            /// 0. Compliant with IEEE 745.
            /// 1. Flush to zero behaviour enabled.
            FZ,
            /// Which way to round floating point operations.
            RMode(IEEE754RoundingMode),
            /// Error code, see A2-44.
            IDC,
            /// Error code, see A2-44.
            IXC,
            /// Error code, see A2-44.
            OFC,
            /// Error code, see A2-44.
            UFC,
            /// Error code, see A2-44.
            DZC,
            /// Error code, see A2-44.
            IOC,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FPSCR {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    FPSCR::N => ::core::fmt::Formatter::write_str(f, "N"),
                    FPSCR::Z => ::core::fmt::Formatter::write_str(f, "Z"),
                    FPSCR::C => ::core::fmt::Formatter::write_str(f, "C"),
                    FPSCR::V => ::core::fmt::Formatter::write_str(f, "V"),
                    FPSCR::AHP => ::core::fmt::Formatter::write_str(f, "AHP"),
                    FPSCR::DN => ::core::fmt::Formatter::write_str(f, "DN"),
                    FPSCR::FZ => ::core::fmt::Formatter::write_str(f, "FZ"),
                    FPSCR::RMode(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "RMode",
                            &__self_0,
                        )
                    }
                    FPSCR::IDC => ::core::fmt::Formatter::write_str(f, "IDC"),
                    FPSCR::IXC => ::core::fmt::Formatter::write_str(f, "IXC"),
                    FPSCR::OFC => ::core::fmt::Formatter::write_str(f, "OFC"),
                    FPSCR::UFC => ::core::fmt::Formatter::write_str(f, "UFC"),
                    FPSCR::DZC => ::core::fmt::Formatter::write_str(f, "DZC"),
                    FPSCR::IOC => ::core::fmt::Formatter::write_str(f, "IOC"),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for FPSCR {}
        #[automatically_derived]
        impl ::core::clone::Clone for FPSCR {
            #[inline]
            fn clone(&self) -> FPSCR {
                let _: ::core::clone::AssertParamIsClone<IEEE754RoundingMode>;
                *self
            }
        }
        /// Represents the roundning mode used.
        pub enum IEEE754RoundingMode {
            /// Rounds to nearest.
            RN = 0b00,
            /// Rounds up towards positive infinity.
            RP = 0b01,
            /// Rounds down towards negative inifinity.
            RM = 0b10,
            /// Round towards zero.
            RZ = 0b11,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IEEE754RoundingMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        IEEE754RoundingMode::RN => "RN",
                        IEEE754RoundingMode::RP => "RP",
                        IEEE754RoundingMode::RM => "RM",
                        IEEE754RoundingMode::RZ => "RZ",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for IEEE754RoundingMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for IEEE754RoundingMode {
            #[inline]
            fn clone(&self) -> IEEE754RoundingMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for IEEE754RoundingMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for IEEE754RoundingMode {
            #[inline]
            fn eq(&self, other: &IEEE754RoundingMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for IEEE754RoundingMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl IEEE754RoundingMode {
            const fn to_u32(&self) -> u32 {
                match self {
                    Self::RN => 0,
                    Self::RP => 1,
                    Self::RM => 2,
                    Self::RZ => 3,
                }
            }
        }
        impl TryFrom<u8> for IEEE754RoundingMode {
            type Error = ParseError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                Ok(
                    match value {
                        0 => Self::RN,
                        1 => Self::RP,
                        2 => Self::RM,
                        3 => Self::RZ,
                        _ => return Err(ParseError::InvalidRoundingMode(value)),
                    },
                )
            }
        }
        impl FPSCR {
            /// Sets the flags in the u32 representation of the memory.
            pub const fn set(&self, previous_value: u32) -> u32 {
                if let Self::RMode(mode) = self {
                    let mode = mode.to_u32();
                    return previous_value & !self.mask() | mode << 22;
                }
                self.mask() | previous_value
            }
            /// Clears the flags in the u32 representation of the memory.
            ///
            /// if clearing the rounding mode it defaults to
            /// [`IEEE754RoundingMode::RN`].
            pub const fn clear(&self, previous_value: u32) -> u32 {
                !self.mask() & previous_value
            }
            /// Returns the bits that are used in this register for that specific flag.
            pub const fn mask(&self) -> u32 {
                match self {
                    Self::N => Self::bitmask::<31, 31>(),
                    Self::Z => Self::bitmask::<30, 30>(),
                    Self::C => Self::bitmask::<29, 29>(),
                    Self::V => Self::bitmask::<28, 28>(),
                    Self::AHP => Self::bitmask::<26, 26>(),
                    Self::DN => Self::bitmask::<25, 25>(),
                    Self::FZ => Self::bitmask::<24, 24>(),
                    Self::RMode(_) => Self::bitmask::<22, 23>(),
                    Self::IDC => Self::bitmask::<7, 7>(),
                    Self::IXC => Self::bitmask::<4, 4>(),
                    Self::UFC => Self::bitmask::<3, 3>(),
                    Self::OFC => Self::bitmask::<2, 2>(),
                    Self::DZC => Self::bitmask::<1, 1>(),
                    Self::IOC => Self::bitmask::<0, 0>(),
                }
            }
            /// Creates a u32 bitmask.
            const fn bitmask<const START: u32, const END: u32>() -> u32 {
                (((1 << (END - START + 1) as u32) as u32) - 1_u32) << START
            }
        }
        /// Register lists lifted from a bit vector to allow
        /// type level representations
        pub struct RegisterList {
            /// All of the registers in the register list.
            pub registers: Vec<Register>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RegisterList {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "RegisterList",
                    "registers",
                    &&self.registers,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RegisterList {
            #[inline]
            fn clone(&self) -> RegisterList {
                RegisterList {
                    registers: ::core::clone::Clone::clone(&self.registers),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RegisterList {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RegisterList {
            #[inline]
            fn eq(&self, other: &RegisterList) -> bool {
                self.registers == other.registers
            }
        }
        impl TryFrom<u16> for Register {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                (value as u8).try_into()
            }
        }
        impl IntoIterator for RegisterList {
            type IntoIter = <Vec<Register> as IntoIterator>::IntoIter;
            type Item = Register;
            fn into_iter(self) -> Self::IntoIter {
                self.registers.into_iter()
            }
        }
        impl From<Register> for RegisterList {
            fn from(value: Register) -> Self {
                Self {
                    registers: <[_]>::into_vec(::alloc::boxed::box_new([value])),
                }
            }
        }
        impl TryFrom<u16> for RegisterList {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                let mut registers = ::alloc::vec::Vec::new();
                for i in 0..16_u8 {
                    if (value >> i) & 0b1 == 0b1 {
                        registers.push(i.try_into()?)
                    }
                }
                Ok(Self { registers })
            }
        }
    }
    pub mod set_flags {
        //! Defines setflags options.
        //!
        //! Since some operations in the Armv7-m and v6-m ISAs flag setting
        //! behavior is dependent on wether or not the cpu is currently executing
        //! in a conditional block we need to reflect this behavior in the disassembler.
        /// Enumerates the possible SetFlags values
        pub enum SetFlags {
            /// Pre-determined.
            Literal(bool),
            /// Depends on wether or not the code is in an IT block or not.
            ///
            /// ```ignore
            /// let set_flags = !in_it_block ^ SetFlags::InitBlock(value)
            /// ```
            InITBlock(bool),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SetFlags {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SetFlags::Literal(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Literal",
                            &__self_0,
                        )
                    }
                    SetFlags::InITBlock(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "InITBlock",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SetFlags {
            #[inline]
            fn clone(&self) -> SetFlags {
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SetFlags {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SetFlags {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SetFlags {
            #[inline]
            fn eq(&self, other: &SetFlags) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (SetFlags::Literal(__self_0), SetFlags::Literal(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (
                            SetFlags::InITBlock(__self_0),
                            SetFlags::InITBlock(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl From<bool> for SetFlags {
            fn from(value: bool) -> Self {
                Self::Literal(value)
            }
        }
        /// Extracts the set flag option.
        ///
        /// If it depends on wether we are in an IT block or not
        /// we get the result of
        /// ```ignore
        /// let set_flags = !in_it_block ^ SetFlags::InitBlock(value)
        /// ```
        pub trait LocalUnwrap {
            /// Extracts the set flag option.
            ///
            /// If it depends on wether we are in an IT block or not
            /// we get the result of
            /// ```ignore
            /// let set_flags = !in_it_block ^ SetFlags::InitBlock(value)
            /// ```
            fn local_unwrap(self, in_it_block: bool) -> bool
            where
                Self: Sized;
        }
        impl LocalUnwrap for Option<SetFlags> {
            fn local_unwrap(self, in_it_block: bool) -> bool {
                match self {
                    Some(SetFlags::Literal(b)) => b,
                    Some(SetFlags::InITBlock(b)) => (!in_it_block) ^ b,
                    None => false,
                }
            }
        }
    }
    pub mod shift {
        //! Enumerates and parses shift operations.
        use crate::ArchError;
        /// Enumerates the shift types that are defined in the system.
        pub enum Shift {
            /// Logical left shift.
            Lsl,
            /// Logical right sift.
            Lsr,
            /// Arithmetic right shift.
            Asr,
            /// Rotate right with extend.
            Rrx,
            /// Rotate right.
            Ror,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Shift {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Shift::Lsl => "Lsl",
                        Shift::Lsr => "Lsr",
                        Shift::Asr => "Asr",
                        Shift::Rrx => "Rrx",
                        Shift::Ror => "Ror",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Shift {
            #[inline]
            fn clone(&self) -> Shift {
                match self {
                    Shift::Lsl => Shift::Lsl,
                    Shift::Lsr => Shift::Lsr,
                    Shift::Asr => Shift::Asr,
                    Shift::Rrx => Shift::Rrx,
                    Shift::Ror => Shift::Ror,
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Shift {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Shift {
            #[inline]
            fn eq(&self, other: &Shift) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        /// Denotes a shift defined in the encoding.
        ///
        /// These shifts are typically applied to a [`Register`](crate::arch::register).
        pub struct ImmShift {
            /// How far should the value be shifted.
            pub shift_n: u8,
            /// What type of shift should be applied.
            pub shift_t: Shift,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ImmShift {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ImmShift",
                    "shift_n",
                    &self.shift_n,
                    "shift_t",
                    &&self.shift_t,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ImmShift {
            #[inline]
            fn clone(&self) -> ImmShift {
                ImmShift {
                    shift_n: ::core::clone::Clone::clone(&self.shift_n),
                    shift_t: ::core::clone::Clone::clone(&self.shift_t),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ImmShift {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ImmShift {
            #[inline]
            fn eq(&self, other: &ImmShift) -> bool {
                self.shift_n == other.shift_n && self.shift_t == other.shift_t
            }
        }
        impl TryFrom<u8> for Shift {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                match value {
                    0 => Ok(Self::Lsl),
                    1 => Ok(Self::Asr),
                    2 => Ok(Self::Asr),
                    3 => Ok(Self::Ror),
                    _ => {
                        Err(
                            ArchError::InvalidField(
                                ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("Shift, {0} valid options are 0 -> 3", value),
                                    );
                                    res
                                }),
                            ),
                        )
                    }
                }
            }
        }
        impl From<(Shift, u8)> for ImmShift {
            fn from(value: (Shift, u8)) -> Self {
                match value {
                    (Shift::Lsr, 0) => {
                        Self {
                            shift_t: Shift::Lsr,
                            shift_n: 32,
                        }
                    }
                    (Shift::Asr, 0) => {
                        Self {
                            shift_t: Shift::Lsr,
                            shift_n: 32,
                        }
                    }
                    (Shift::Ror, 0) => {
                        Self {
                            shift_t: Shift::Rrx,
                            shift_n: 1,
                        }
                    }
                    (shift_t, shift_n) => Self { shift_t, shift_n },
                }
            }
        }
    }
    pub mod wrapper_types {
        //! Creates a few helper types to make translations clearer.
        use crate::{arch::Mask, ArchError};
        impl Imm12 {
            /// Expands the value using [`expand_imm_c`](Imm12::expand_imm_c) and
            /// discards the carry flag.
            pub fn expand_imm(self) -> u32 {
                self.expand_imm_c().0
            }
            /// Expands the immediate value in the manner described in the
            /// [`documentation`](
            ///     https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwjc6YCk0fiEAxUSLhAIHU-1BY8QFnoECBQQAQ&url=https%3A%2F%2Fdocumentation-service.arm.com%2Fstatic%2F5f8fef3af86e16515cdbf816%3Ftoken%3D&usg=AOvVaw1Pwok2Ulie5wtDRP5IwyNw&opi=89978449
            /// )
            pub fn expand_imm_c(self) -> (u32, Option<bool>) {
                let repr: u16 = self.into();
                let zero = 0;
                if repr.mask::<10, 11>() == 0 {
                    let bits = repr.mask::<0, 7>();
                    let mask = repr.mask::<8, 9>();
                    return (
                        match mask {
                            0 => bits.into(),
                            1 => {
                                let mut counter: usize = { 8 + 8 + 8 + 0 };
                                let mut sum: u32 = (zero as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 8;
                                    sum |= ((bits as u32) << counter) as u32;
                                    counter -= 8;
                                    sum |= ((zero as u32) << counter) as u32;
                                    counter -= 8;
                                    sum |= ((bits as u32) << counter) as u32;
                                }
                                sum
                            }
                            2 => {
                                let mut counter: usize = { 8 + 8 + 8 + 0 };
                                let mut sum: u32 = (bits as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 8;
                                    sum |= ((zero as u32) << counter) as u32;
                                    counter -= 8;
                                    sum |= ((bits as u32) << counter) as u32;
                                    counter -= 8;
                                    sum |= ((zero as u32) << counter) as u32;
                                }
                                sum
                            }
                            3 => {
                                let mut counter: usize = { 8 + 8 + 8 + 0 };
                                let mut sum: u32 = (bits as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 8;
                                    sum |= ((bits as u32) << counter) as u32;
                                    counter -= 8;
                                    sum |= ((bits as u32) << counter) as u32;
                                    counter -= 8;
                                    sum |= ((bits as u32) << counter) as u32;
                                }
                                sum
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("Masking function broken"),
                                    ),
                                );
                            }
                        },
                        None,
                    );
                }
                let to_rotate = (1 << 7) | repr.mask::<0, 6>() as u32;
                let ret = to_rotate.rotate_right(repr.mask::<7, 11>() as u32);
                let c = ret.mask::<31, 31>() == 1;
                (ret, Some(c))
            }
            /// Returns the underlying representation of the value.
            pub fn inner(self) -> u16 {
                self.val
            }
        }
        mod sealed {
            pub trait SignBit {
                /// Bit index in the source value
                const BIT: usize;
            }
        }
        /// Replaces all bits after `BIT` with the value of `BIT`.
        pub fn sign_extend<const BIT: usize>(el: &u32) -> i32 {
            let np1: u32 = 1 << BIT;
            let sign = *el & np1;
            if sign == 0 {
                return *el as i32;
            }
            let mask: u32 = if sign != 0 { !0 } else { 0 };
            let mask = mask ^ ((1 << (1)) - 1_u32);
            let ret = mask | *el;
            ret as i32
        }
        /// Replaces all bits after `BIT` with the value of `BIT`.
        pub fn sign_extend_u32<const BIT: usize>(el: &u32) -> u32 {
            let np1: u32 = 1 << BIT;
            let sign = *el & np1;
            if sign == 0 {
                return *el;
            }
            let mask: u32 = if sign != 0 { !0 } else { 0 };
            let mask = mask ^ ((1 << (1)) - 1_u32);
            mask | *el
        }
        /// Allows the implementor to be extended with the value at index `BIT`.
        pub trait SignExtendGeneric<T: Sized> {
            /// Extends the rest of the value with the bit at index BIT.
            /// indexes start at 0
            fn sign_extend<const BIT: usize>(&mut self) -> T;
        }
        /// Allows the implementor to be extended with the value at index defined by
        /// SignBit.
        pub trait SignExtend<T: Sized>: sealed::SignBit {
            /// The number of bits in the target
            const TARGET_SIZE: usize = std::mem::size_of::<T>() * 8;
            /// Extends the rest of the value with the bit at index BIT.
            /// indexes start at 0
            fn sign_extend(&mut self) -> T;
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm2 {
            val: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm2 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm2",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm2 {
            #[inline]
            fn clone(&self) -> Imm2 {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm2 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm2 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm2 {
            #[inline]
            fn eq(&self, other: &Imm2) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm2 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u16> for Imm2 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u8> for Imm2 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm3 {
            val: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm3 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm3",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm3 {
            #[inline]
            fn clone(&self) -> Imm3 {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm3 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm3 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm3 {
            #[inline]
            fn eq(&self, other: &Imm3) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm3 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u16> for Imm3 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u8> for Imm3 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm4 {
            val: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm4 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm4",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm4 {
            #[inline]
            fn clone(&self) -> Imm4 {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm4 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm4 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm4 {
            #[inline]
            fn eq(&self, other: &Imm4) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm4 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u16> for Imm4 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u8> for Imm4 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm5 {
            val: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm5 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm5",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm5 {
            #[inline]
            fn clone(&self) -> Imm5 {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm5 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm5 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm5 {
            #[inline]
            fn eq(&self, other: &Imm5) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm5 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u16> for Imm5 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u8> for Imm5 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm8 {
            val: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm8 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm8",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm8 {
            #[inline]
            fn clone(&self) -> Imm8 {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm8 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm8 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm8 {
            #[inline]
            fn eq(&self, other: &Imm8) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm8 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u16> for Imm8 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        impl TryFrom<u8> for Imm8 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u8 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm9 {
            val: u16,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm9 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm9",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm9 {
            #[inline]
            fn clone(&self) -> Imm9 {
                let _: ::core::clone::AssertParamIsClone<u16>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm9 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm9 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm9 {
            #[inline]
            fn eq(&self, other: &Imm9) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm9 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u16 })
            }
        }
        impl TryFrom<u16> for Imm9 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u16 })
            }
        }
        impl TryFrom<u8> for Imm9 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u16 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm12 {
            val: u16,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm12 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm12",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm12 {
            #[inline]
            fn clone(&self) -> Imm12 {
                let _: ::core::clone::AssertParamIsClone<u16>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm12 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm12 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm12 {
            #[inline]
            fn eq(&self, other: &Imm12) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm12 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u16 })
            }
        }
        impl TryFrom<u16> for Imm12 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u16 })
            }
        }
        impl TryFrom<u8> for Imm12 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u16 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm21 {
            val: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm21 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm21",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm21 {
            #[inline]
            fn clone(&self) -> Imm21 {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm21 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm21 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm21 {
            #[inline]
            fn eq(&self, other: &Imm21) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm21 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        impl TryFrom<u16> for Imm21 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        impl TryFrom<u8> for Imm21 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm22 {
            val: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm22 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm22",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm22 {
            #[inline]
            fn clone(&self) -> Imm22 {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm22 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm22 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm22 {
            #[inline]
            fn eq(&self, other: &Imm22) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm22 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        impl TryFrom<u16> for Imm22 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        impl TryFrom<u8> for Imm22 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        /// A size limited immediate value.
        ///
        /// These can be sign or zero
        /// extended in to longer representations.
        pub struct Imm25 {
            val: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Imm25 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Imm25",
                    "val",
                    &&self.val,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Imm25 {
            #[inline]
            fn clone(&self) -> Imm25 {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Imm25 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Imm25 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Imm25 {
            #[inline]
            fn eq(&self, other: &Imm25) -> bool {
                self.val == other.val
            }
        }
        impl TryFrom<u32> for Imm25 {
            type Error = ArchError;
            fn try_from(value: u32) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u32>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u32 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u32;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        impl TryFrom<u16> for Imm25 {
            type Error = ArchError;
            fn try_from(value: u16) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u16>() * 8 < (<Self as sealed::SignBit>::BIT + 1)
                {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u16 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u16;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        impl TryFrom<u8> for Imm25 {
            type Error = ArchError;
            fn try_from(value: u8) -> Result<Self, Self::Error> {
                if std::mem::size_of::<u8>() * 8 < (<Self as sealed::SignBit>::BIT + 1) {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                let max: u8 = (((1 as u32) << (<Self as sealed::SignBit>::BIT + 1)) - 1)
                    as u8;
                if value > max {
                    return Err(ArchError::InvalidField("Immediate".to_string()));
                }
                Ok(Self { val: value as u32 })
            }
        }
        impl From<Imm2> for u8 {
            fn from(val: Imm2) -> u8 {
                val.val as u8
            }
        }
        impl From<Imm2> for u16 {
            fn from(val: Imm2) -> u16 {
                val.val as u16
            }
        }
        impl From<Imm2> for u32 {
            fn from(val: Imm2) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm3> for u8 {
            fn from(val: Imm3) -> u8 {
                val.val as u8
            }
        }
        impl From<Imm3> for u16 {
            fn from(val: Imm3) -> u16 {
                val.val as u16
            }
        }
        impl From<Imm3> for u32 {
            fn from(val: Imm3) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm4> for u8 {
            fn from(val: Imm4) -> u8 {
                val.val as u8
            }
        }
        impl From<Imm4> for u16 {
            fn from(val: Imm4) -> u16 {
                val.val as u16
            }
        }
        impl From<Imm4> for u32 {
            fn from(val: Imm4) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm5> for u8 {
            fn from(val: Imm5) -> u8 {
                val.val as u8
            }
        }
        impl From<Imm5> for u16 {
            fn from(val: Imm5) -> u16 {
                val.val as u16
            }
        }
        impl From<Imm5> for u32 {
            fn from(val: Imm5) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm8> for u8 {
            fn from(val: Imm8) -> u8 {
                val.val as u8
            }
        }
        impl From<Imm8> for u16 {
            fn from(val: Imm8) -> u16 {
                val.val as u16
            }
        }
        impl From<Imm8> for u32 {
            fn from(val: Imm8) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm9> for u16 {
            fn from(val: Imm9) -> u16 {
                val.val as u16
            }
        }
        impl From<Imm9> for u32 {
            fn from(val: Imm9) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm12> for u16 {
            fn from(val: Imm12) -> u16 {
                val.val as u16
            }
        }
        impl From<Imm12> for u32 {
            fn from(val: Imm12) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm21> for u32 {
            fn from(val: Imm21) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm22> for u32 {
            fn from(val: Imm22) -> u32 {
                val.val as u32
            }
        }
        impl From<Imm25> for u32 {
            fn from(val: Imm25) -> u32 {
                val.val as u32
            }
        }
        impl sealed::SignBit for Imm2 {
            const BIT: usize = 1;
        }
        impl SignExtend<i32> for Imm2 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<i16> for Imm2 {
            fn sign_extend(&mut self) -> i16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as i16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as i16
            }
        }
        impl SignExtend<i8> for Imm2 {
            fn sign_extend(&mut self) -> i8 {
                let np1: u8 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u8) & np1;
                if sign == 0 {
                    return self.val as i8;
                }
                let mask: u8 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u8));
                let ret = mask | (self.val as u8);
                ret as i8
            }
        }
        impl SignExtend<u32> for Imm2 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl SignExtend<u16> for Imm2 {
            fn sign_extend(&mut self) -> u16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as u16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as u16
            }
        }
        impl SignExtend<u8> for Imm2 {
            fn sign_extend(&mut self) -> u8 {
                let np1: u8 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u8) & np1;
                if sign == 0 {
                    return self.val as u8;
                }
                let mask: u8 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u8));
                let ret = mask | (self.val as u8);
                ret as u8
            }
        }
        impl sealed::SignBit for Imm3 {
            const BIT: usize = 2;
        }
        impl SignExtend<i32> for Imm3 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<i16> for Imm3 {
            fn sign_extend(&mut self) -> i16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as i16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as i16
            }
        }
        impl SignExtend<i8> for Imm3 {
            fn sign_extend(&mut self) -> i8 {
                let np1: u8 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u8) & np1;
                if sign == 0 {
                    return self.val as i8;
                }
                let mask: u8 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u8));
                let ret = mask | (self.val as u8);
                ret as i8
            }
        }
        impl SignExtend<u32> for Imm3 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl SignExtend<u16> for Imm3 {
            fn sign_extend(&mut self) -> u16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as u16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as u16
            }
        }
        impl SignExtend<u8> for Imm3 {
            fn sign_extend(&mut self) -> u8 {
                let np1: u8 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u8) & np1;
                if sign == 0 {
                    return self.val as u8;
                }
                let mask: u8 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u8));
                let ret = mask | (self.val as u8);
                ret as u8
            }
        }
        impl sealed::SignBit for Imm4 {
            const BIT: usize = 3;
        }
        impl SignExtend<i32> for Imm4 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<i16> for Imm4 {
            fn sign_extend(&mut self) -> i16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as i16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as i16
            }
        }
        impl SignExtend<i8> for Imm4 {
            fn sign_extend(&mut self) -> i8 {
                let np1: u8 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u8) & np1;
                if sign == 0 {
                    return self.val as i8;
                }
                let mask: u8 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u8));
                let ret = mask | (self.val as u8);
                ret as i8
            }
        }
        impl SignExtend<u32> for Imm4 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl SignExtend<u16> for Imm4 {
            fn sign_extend(&mut self) -> u16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as u16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as u16
            }
        }
        impl SignExtend<u8> for Imm4 {
            fn sign_extend(&mut self) -> u8 {
                let np1: u8 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u8) & np1;
                if sign == 0 {
                    return self.val as u8;
                }
                let mask: u8 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u8));
                let ret = mask | (self.val as u8);
                ret as u8
            }
        }
        impl sealed::SignBit for Imm5 {
            const BIT: usize = 4;
        }
        impl SignExtend<i32> for Imm5 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<i16> for Imm5 {
            fn sign_extend(&mut self) -> i16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as i16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as i16
            }
        }
        impl SignExtend<i8> for Imm5 {
            fn sign_extend(&mut self) -> i8 {
                let np1: u8 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u8) & np1;
                if sign == 0 {
                    return self.val as i8;
                }
                let mask: u8 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u8));
                let ret = mask | (self.val as u8);
                ret as i8
            }
        }
        impl SignExtend<u32> for Imm5 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl SignExtend<u16> for Imm5 {
            fn sign_extend(&mut self) -> u16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as u16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as u16
            }
        }
        impl SignExtend<u8> for Imm5 {
            fn sign_extend(&mut self) -> u8 {
                let np1: u8 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u8) & np1;
                if sign == 0 {
                    return self.val as u8;
                }
                let mask: u8 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u8));
                let ret = mask | (self.val as u8);
                ret as u8
            }
        }
        impl sealed::SignBit for Imm8 {
            const BIT: usize = 7;
        }
        impl SignExtend<i32> for Imm8 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<i16> for Imm8 {
            fn sign_extend(&mut self) -> i16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as i16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as i16
            }
        }
        impl SignExtend<u32> for Imm8 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl SignExtend<u16> for Imm8 {
            fn sign_extend(&mut self) -> u16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as u16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as u16
            }
        }
        impl sealed::SignBit for Imm9 {
            const BIT: usize = 8;
        }
        impl SignExtend<i32> for Imm9 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<i16> for Imm9 {
            fn sign_extend(&mut self) -> i16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as i16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as i16
            }
        }
        impl SignExtend<u32> for Imm9 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl SignExtend<u16> for Imm9 {
            fn sign_extend(&mut self) -> u16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as u16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as u16
            }
        }
        impl sealed::SignBit for Imm12 {
            const BIT: usize = 11;
        }
        impl SignExtend<i32> for Imm12 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<i16> for Imm12 {
            fn sign_extend(&mut self) -> i16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as i16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as i16
            }
        }
        impl SignExtend<u32> for Imm12 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl SignExtend<u16> for Imm12 {
            fn sign_extend(&mut self) -> u16 {
                let np1: u16 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u16) & np1;
                if sign == 0 {
                    return self.val as u16;
                }
                let mask: u16 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u16));
                let ret = mask | (self.val as u16);
                ret as u16
            }
        }
        impl sealed::SignBit for Imm21 {
            const BIT: usize = 20;
        }
        impl SignExtend<i32> for Imm21 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<u32> for Imm21 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl sealed::SignBit for Imm22 {
            const BIT: usize = 21;
        }
        impl SignExtend<i32> for Imm22 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<u32> for Imm22 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
        impl sealed::SignBit for Imm25 {
            const BIT: usize = 24;
        }
        impl SignExtend<i32> for Imm25 {
            fn sign_extend(&mut self) -> i32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as i32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as i32
            }
        }
        impl SignExtend<u32> for Imm25 {
            fn sign_extend(&mut self) -> u32 {
                let np1: u32 = (1 << <Self as sealed::SignBit>::BIT);
                let sign = (self.val as u32) & np1;
                if sign == 0 {
                    return self.val as u32;
                }
                let mask: u32 = if sign != 0 { !0 } else { 0 };
                let mask = mask
                    ^ ((1 << (<Self as sealed::SignBit>::BIT + 1)) - (1 as u32));
                let ret = mask | (self.val as u32);
                ret as u32
            }
        }
    }
    pub use condition::{Condition, ITCondition};
    pub use coproc::CoProcessor;
    pub use register::{Register, RegisterList};
    pub use set_flags::SetFlags;
    pub use shift::{ImmShift, Shift};
    pub use wrapper_types::*;
    /// Enumerates all of the possible errors in this crate.
    pub enum ArchError {
        /// Thrown when trying to parse a [`Condition`] from
        /// an invalid encoding.
        InvalidCondition,
        /// Thrown when trying to parse a [`Register`] from an
        /// invalid encoding.
        InvalidRegister(u8),
        /// Thrown when trying to parse a specific field type from an invalid
        /// encoding.
        InvalidField(String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ArchError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ArchError::InvalidCondition => {
                    ::core::fmt::Formatter::write_str(f, "InvalidCondition")
                }
                ArchError::InvalidRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "InvalidRegister",
                        &__self_0,
                    )
                }
                ArchError::InvalidField(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "InvalidField",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ArchError {
        #[inline]
        fn clone(&self) -> ArchError {
            match self {
                ArchError::InvalidCondition => ArchError::InvalidCondition,
                ArchError::InvalidRegister(__self_0) => {
                    ArchError::InvalidRegister(::core::clone::Clone::clone(__self_0))
                }
                ArchError::InvalidField(__self_0) => {
                    ArchError::InvalidField(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    /// Masks out a set of bits from the number
    pub(crate) trait Mask {
        /// Masks out bits start -> end from the number
        fn mask<const START: usize, const END: usize>(&self) -> Self;
    }
    impl Mask for u16 {
        fn mask<const START: usize, const END: usize>(&self) -> u16 {
            let intermediate = self >> START;
            let mask = ((1 << (END - START + 1) as u16) as u16) - 1_u16;
            intermediate & mask
        }
    }
    impl Mask for u32 {
        fn mask<const START: usize, const END: usize>(&self) -> u32 {
            let intermediate = self >> START;
            let mask = ((1 << (END - START + 1) as u32) as u32) - 1_u32;
            intermediate & mask
        }
    }
}
mod asm {
    //! Defines the statements available in armv7.
    use crate::ParseError;
    pub mod b16 {
        //! Defines all of the 16 bit instructions.
        pub mod a_5_2 {
            //! Parses instructions based on the table A5.2.1
            use paste::paste;
            use super::Mask;
            use crate::{
                arch, arch::Register, instruction, operation,
                prelude::{ImmShift, SetFlags, Shift},
                Parse, ParseError, ToOperation,
            };
            pub enum A5_2 {
                Lsl(Lsl),
                Lsr(Lsr),
                Asr(Asr),
                Add(Add),
                Sub(Sub),
                AddImmediate3(AddImmediate3),
                SubImmediate3(SubImmediate3),
                Mov(Mov),
                Cmp(Cmp),
                AddImmediate8(AddImmediate8),
                SubImmediate8(SubImmediate8),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_2::Lsl(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Lsl",
                                &__self_0,
                            )
                        }
                        A5_2::Lsr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Lsr",
                                &__self_0,
                            )
                        }
                        A5_2::Asr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Asr",
                                &__self_0,
                            )
                        }
                        A5_2::Add(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Add",
                                &__self_0,
                            )
                        }
                        A5_2::Sub(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sub",
                                &__self_0,
                            )
                        }
                        A5_2::AddImmediate3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "AddImmediate3",
                                &__self_0,
                            )
                        }
                        A5_2::SubImmediate3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubImmediate3",
                                &__self_0,
                            )
                        }
                        A5_2::Mov(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mov",
                                &__self_0,
                            )
                        }
                        A5_2::Cmp(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cmp",
                                &__self_0,
                            )
                        }
                        A5_2::AddImmediate8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "AddImmediate8",
                                &__self_0,
                            )
                        }
                        A5_2::SubImmediate8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubImmediate8",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_2 {
                #[allow(dead_code)]
                pub(crate) fn parse_lsl<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Lsl(Lsl::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_lsr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Lsr(Lsr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_asr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Asr(Asr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_add<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Add(Add::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sub<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sub(Sub::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_addimmediate3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::AddImmediate3(AddImmediate3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_subimmediate3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::SubImmediate3(SubImmediate3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mov<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mov(Mov::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cmp<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cmp(Cmp::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_addimmediate8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::AddImmediate8(AddImmediate8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_subimmediate8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::SubImmediate8(SubImmediate8::parse(iter)?))
                }
            }
            /**Instruction Lsl from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- imm of type u8 from bit 6 to bit 10
*/
            pub struct Lsl {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 6 to 10

*/
                pub(crate) imm: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Lsl {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Lsl",
                        "rd",
                        &self.rd,
                        "rm",
                        &self.rm,
                        "imm",
                        &&self.imm,
                    )
                }
            }
            impl Parse for Lsl {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Lsl")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>()).try_into().map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>()).try_into().map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rd, rm, imm };
                    Ok(ret)
                }
            }
            /**Instruction Lsr from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- imm of type u8 from bit 6 to bit 10
*/
            pub struct Lsr {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 6 to 10

*/
                pub(crate) imm: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Lsr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Lsr",
                        "rd",
                        &self.rd,
                        "rm",
                        &self.rm,
                        "imm",
                        &&self.imm,
                    )
                }
            }
            impl Parse for Lsr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Lsr")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>()).try_into().map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>()).try_into().map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rd, rm, imm };
                    Ok(ret)
                }
            }
            /**Instruction Asr from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- imm5 of type u8 from bit 6 to bit 10
*/
            pub struct Asr {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 6 to 10

*/
                pub(crate) imm5: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Asr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Asr",
                        "rd",
                        &self.rd,
                        "rm",
                        &self.rm,
                        "imm5",
                        &&self.imm5,
                    )
                }
            }
            impl Parse for Asr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Asr")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>()).try_into().map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>()).try_into().map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rd, rm, imm5 };
                    Ok(ret)
                }
            }
            /**Instruction Add from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Add {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Add {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Add",
                        "rd",
                        &self.rd,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Add {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Add")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>()).try_into().map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>()).try_into().map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>()).try_into().map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction Sub from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Sub {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sub {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sub",
                        "rd",
                        &self.rd,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Sub {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sub")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>()).try_into().map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>()).try_into().map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>()).try_into().map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction AddImmediate3 from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- imm of type u8 from bit 6 to bit 8
*/
            pub struct AddImmediate3 {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) imm: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AddImmediate3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "AddImmediate3",
                        "rd",
                        &self.rd,
                        "rn",
                        &self.rn,
                        "imm",
                        &&self.imm,
                    )
                }
            }
            impl Parse for AddImmediate3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("AddImmediate3")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>()).try_into().map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>()).try_into().map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                    };
                    let ret = Self { rd, rn, imm };
                    Ok(ret)
                }
            }
            /**Instruction SubImmediate3 from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- imm of type u8 from bit 6 to bit 8
*/
            pub struct SubImmediate3 {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) imm: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubImmediate3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "SubImmediate3",
                        "rd",
                        &self.rd,
                        "rn",
                        &self.rn,
                        "imm",
                        &&self.imm,
                    )
                }
            }
            impl Parse for SubImmediate3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("SubImmediate3")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>()).try_into().map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>()).try_into().map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                    };
                    let ret = Self { rd, rn, imm };
                    Ok(ret)
                }
            }
            /**Instruction Mov from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 8 to bit 10
*/
            /**- imm of type u8 from bit 0 to bit 7
*/
            pub struct Mov {
                /**bit 8 to 10

*/
                pub(crate) rd: Register,
                /**bit 0 to 7

*/
                pub(crate) imm: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mov {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Mov",
                        "rd",
                        &self.rd,
                        "imm",
                        &&self.imm,
                    )
                }
            }
            impl Parse for Mov {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mov")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>()).try_into().map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let ret = Self { rd, imm };
                    Ok(ret)
                }
            }
            /**Instruction Cmp from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rn of type Register from bit 8 to bit 10
*/
            /**- imm of type u8 from bit 0 to bit 7
*/
            pub struct Cmp {
                /**bit 8 to 10

*/
                pub(crate) rn: Register,
                /**bit 0 to 7

*/
                pub(crate) imm: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cmp {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Cmp",
                        "rn",
                        &self.rn,
                        "imm",
                        &&self.imm,
                    )
                }
            }
            impl Parse for Cmp {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cmp")),
                    }?;
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>()).try_into().map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let ret = Self { rn, imm };
                    Ok(ret)
                }
            }
            /**Instruction AddImmediate8 from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rdn of type Register from bit 8 to bit 10
*/
            /**- imm of type u8 from bit 0 to bit 7
*/
            pub struct AddImmediate8 {
                /**bit 8 to 10

*/
                pub(crate) rdn: Register,
                /**bit 0 to 7

*/
                pub(crate) imm: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AddImmediate8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "AddImmediate8",
                        "rdn",
                        &self.rdn,
                        "imm",
                        &&self.imm,
                    )
                }
            }
            impl Parse for AddImmediate8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("AddImmediate8")),
                    }?;
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>()).try_into().map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let ret = Self { rdn, imm };
                    Ok(ret)
                }
            }
            /**Instruction SubImmediate8 from table A5_2

*/
            /**Contains the following fields:
*/
            /**- rdn of type Register from bit 8 to bit 10
*/
            /**- imm of type u8 from bit 0 to bit 7
*/
            pub struct SubImmediate8 {
                /**bit 8 to 10

*/
                pub(crate) rdn: Register,
                /**bit 0 to 7

*/
                pub(crate) imm: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubImmediate8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "SubImmediate8",
                        "rdn",
                        &self.rdn,
                        "imm",
                        &&self.imm,
                    )
                }
            }
            impl Parse for SubImmediate8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("SubImmediate8")),
                    }?;
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>()).try_into().map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let ret = Self { rdn, imm };
                    Ok(ret)
                }
            }
            impl Parse for A5_2 {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(val) => Ok(val),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let opcode = word.mask::<9, 13>();
                    match opcode >> 2 {
                        0 => return Ok(Self::Lsl(Lsl::parse(iter)?)),
                        1 => return Ok(Self::Lsr(Lsr::parse(iter)?)),
                        2 => {
                            let ret = Ok(Self::Asr(Asr::parse(iter)?));
                            return ret;
                        }
                        4 => return Ok(Self::Mov(Mov::parse(iter)?)),
                        5 => return Ok(Self::Cmp(Cmp::parse(iter)?)),
                        6 => return Ok(Self::AddImmediate8(AddImmediate8::parse(iter)?)),
                        7 => return Ok(Self::SubImmediate8(SubImmediate8::parse(iter)?)),
                        _ => {}
                    };
                    match opcode {
                        0b01100 => Ok(Self::Add(Add::parse(iter)?)),
                        0b01101 => Ok(Self::Sub(Sub::parse(iter)?)),
                        0b01110 => Ok(Self::AddImmediate3(AddImmediate3::parse(iter)?)),
                        0b01111 => Ok(Self::SubImmediate3(SubImmediate3::parse(iter)?)),
                        _ => Err(ParseError::Invalid16Bit("A5_2")),
                    }
                }
            }
            impl ToOperation for A5_2 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Lsl(lsl) => {
                            let shift = crate::arch::shift::ImmShift::from((
                                Shift::Lsl,
                                lsl.imm,
                            ));
                            operation::LslImmediateBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(lsl.rd)
                                .set_rm(lsl.rm)
                                .set_imm(shift.shift_n)
                                .complete()
                                .into()
                        }
                        Self::Lsr(lsr) => {
                            let shift = ImmShift::from((Shift::Lsr, lsr.imm));
                            operation::LsrImmediateBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(lsr.rd)
                                .set_rm(lsr.rm)
                                .set_imm(shift.shift_n)
                                .complete()
                                .into()
                        }
                        Self::Asr(asr) => {
                            let shift = ImmShift::from((Shift::Asr, asr.imm5));
                            operation::AsrImmediateBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(asr.rd)
                                .set_rm(asr.rm)
                                .set_imm(shift.shift_n.into())
                                .complete()
                                .into()
                        }
                        Self::Add(add) => {
                            operation::AddRegisterBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(Some(add.rd))
                                .set_rn(add.rn)
                                .set_rm(add.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Sub(sub) => {
                            operation::SubRegisterBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(Some(sub.rd))
                                .set_rn(sub.rn)
                                .set_rm(sub.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::AddImmediate3(add) => {
                            operation::AddImmediateBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(Some(add.rd))
                                .set_rn(add.rn)
                                .set_imm(add.imm as u32)
                                .complete()
                                .into()
                        }
                        Self::SubImmediate3(sub) => {
                            operation::SubImmediateBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(Some(sub.rd))
                                .set_rn(sub.rn)
                                .set_imm(sub.imm as u32)
                                .complete()
                                .into()
                        }
                        Self::Mov(mov) => {
                            operation::MovImmediateBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(mov.rd)
                                .set_imm(mov.imm as u32)
                                .set_carry(None)
                                .complete()
                                .into()
                        }
                        Self::Cmp(cmp) => {
                            operation::CmpImmediateBuilder::new()
                                .set_rn(cmp.rn)
                                .set_imm(cmp.imm as u32)
                                .complete()
                                .into()
                        }
                        Self::AddImmediate8(add) => {
                            operation::AddImmediateBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(None)
                                .set_rn(add.rdn)
                                .set_imm(add.imm as u32)
                                .complete()
                                .into()
                        }
                        Self::SubImmediate8(sub) => {
                            operation::SubImmediateBuilder::new()
                                .set_s(Some(SetFlags::InITBlock(false)))
                                .set_rd(None)
                                .set_rn(sub.rdn)
                                .set_imm(sub.imm as u32)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a_5_3 {
            use paste::paste;
            use super::Mask;
            use crate::{
                arch, arch::Register, instruction, operation, Parse, ParseError,
                ToOperation,
            };
            pub enum A5_3 {
                And(And),
                Eor(Eor),
                Lsl(Lsl),
                Lsr(Lsr),
                Asr(Asr),
                Adc(Adc),
                Sbc(Sbc),
                Ror(Ror),
                Tst(Tst),
                Rsb(Rsb),
                Cmp(Cmp),
                Cmn(Cmn),
                Orr(Orr),
                Mul(Mul),
                Bic(Bic),
                Mvn(Mvn),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_3::And(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "And",
                                &__self_0,
                            )
                        }
                        A5_3::Eor(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Eor",
                                &__self_0,
                            )
                        }
                        A5_3::Lsl(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Lsl",
                                &__self_0,
                            )
                        }
                        A5_3::Lsr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Lsr",
                                &__self_0,
                            )
                        }
                        A5_3::Asr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Asr",
                                &__self_0,
                            )
                        }
                        A5_3::Adc(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Adc",
                                &__self_0,
                            )
                        }
                        A5_3::Sbc(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sbc",
                                &__self_0,
                            )
                        }
                        A5_3::Ror(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ror",
                                &__self_0,
                            )
                        }
                        A5_3::Tst(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Tst",
                                &__self_0,
                            )
                        }
                        A5_3::Rsb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rsb",
                                &__self_0,
                            )
                        }
                        A5_3::Cmp(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cmp",
                                &__self_0,
                            )
                        }
                        A5_3::Cmn(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cmn",
                                &__self_0,
                            )
                        }
                        A5_3::Orr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Orr",
                                &__self_0,
                            )
                        }
                        A5_3::Mul(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mul",
                                &__self_0,
                            )
                        }
                        A5_3::Bic(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bic",
                                &__self_0,
                            )
                        }
                        A5_3::Mvn(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mvn",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_3 {
                #[allow(dead_code)]
                pub(crate) fn parse_and<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::And(And::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_eor<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Eor(Eor::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_lsl<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Lsl(Lsl::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_lsr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Lsr(Lsr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_asr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Asr(Asr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_adc<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Adc(Adc::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sbc<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sbc(Sbc::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ror<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ror(Ror::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_tst<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Tst(Tst::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rsb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rsb(Rsb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cmp<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cmp(Cmp::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cmn<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cmn(Cmn::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_orr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Orr(Orr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mul<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mul(Mul::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bic<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Bic(Bic::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mvn<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mvn(Mvn::parse(iter)?))
                }
            }
            /**Instruction And from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct And {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for And {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "And",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for And {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("And")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Eor from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Eor {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Eor {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Eor",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Eor {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Eor")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Lsl from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Lsl {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Lsl {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Lsl",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Lsl {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Lsl")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Lsr from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Lsr {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Lsr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Lsr",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Lsr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Lsr")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Asr from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Asr {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Asr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Asr",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Asr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Asr")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Adc from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Adc {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Adc {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Adc",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Adc {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Adc")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Sbc from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Sbc {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sbc {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Sbc",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Sbc {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sbc")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Ror from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Ror {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ror {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Ror",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Ror {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ror")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Tst from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rn of type Register from bit 0 to bit 2
*/
            pub struct Tst {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Tst {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Tst",
                        "rm",
                        &self.rm,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Tst {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Tst")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rn };
                    Ok(ret)
                }
            }
            /**Instruction Rsb from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            pub struct Rsb {
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rsb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Rsb",
                        "rn",
                        &self.rn,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Rsb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rsb")),
                    }?;
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rn, rd };
                    Ok(ret)
                }
            }
            /**Instruction Cmp from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rn of type Register from bit 0 to bit 2
*/
            pub struct Cmp {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cmp {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Cmp",
                        "rm",
                        &self.rm,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Cmp {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cmp")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rn };
                    Ok(ret)
                }
            }
            /**Instruction Cmn from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rn of type Register from bit 0 to bit 2
*/
            pub struct Cmn {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cmn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Cmn",
                        "rm",
                        &self.rm,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Cmn {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cmn")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rn };
                    Ok(ret)
                }
            }
            /**Instruction Orr from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Orr {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Orr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Orr",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Orr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Orr")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Mul from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rdm of type Register from bit 0 to bit 2
*/
            pub struct Mul {
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 0 to 2

*/
                pub(crate) rdm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mul {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Mul",
                        "rn",
                        &self.rn,
                        "rdm",
                        &&self.rdm,
                    )
                }
            }
            impl Parse for Mul {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mul")),
                    }?;
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rn, rdm };
                    Ok(ret)
                }
            }
            /**Instruction Bic from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rdn of type Register from bit 0 to bit 2
*/
            pub struct Bic {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rdn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Bic",
                        "rm",
                        &self.rm,
                        "rdn",
                        &&self.rdn,
                    )
                }
            }
            impl Parse for Bic {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Bic")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdn };
                    Ok(ret)
                }
            }
            /**Instruction Mvn from table A5_3

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            pub struct Mvn {
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mvn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Mvn",
                        "rm",
                        &self.rm,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Mvn {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mvn")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd };
                    Ok(ret)
                }
            }
            impl Parse for A5_3 {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let first_byte = match iter.peek::<1>() as Option<u8> {
                        Some(b) => Ok(b),
                        None => Err(ParseError::Invalid16Bit("A5_3")),
                    }?;
                    let second_byte = match iter.peek::<2>() as Option<u8> {
                        Some(b) => Ok(b),
                        None => Err(ParseError::Invalid16Bit("A5_3")),
                    }?;
                    let op = ((first_byte & 0b11) << 2) | (second_byte >> 6);
                    match op {
                        0b0 => Ok(Self::And(And::parse(iter)?)),
                        0b01 => Ok(Self::Eor(Eor::parse(iter)?)),
                        0b10 => Ok(Self::Lsl(Lsl::parse(iter)?)),
                        0b011 => Ok(Self::Lsr(Lsr::parse(iter)?)),
                        0b100 => Ok(Self::Asr(Asr::parse(iter)?)),
                        0b101 => Ok(Self::Adc(Adc::parse(iter)?)),
                        0b110 => Ok(Self::Sbc(Sbc::parse(iter)?)),
                        0b111 => Ok(Self::Ror(Ror::parse(iter)?)),
                        0b1000 => Ok(Self::Tst(Tst::parse(iter)?)),
                        0b1001 => Ok(Self::Rsb(Rsb::parse(iter)?)),
                        0b1010 => Ok(Self::Cmp(Cmp::parse(iter)?)),
                        0b1011 => Ok(Self::Cmn(Cmn::parse(iter)?)),
                        0b1100 => Ok(Self::Orr(Orr::parse(iter)?)),
                        0b1101 => Ok(Self::Mul(Mul::parse(iter)?)),
                        0b1110 => Ok(Self::Bic(Bic::parse(iter)?)),
                        0b1111 => Ok(Self::Mvn(Mvn::parse(iter)?)),
                        _ => Err(ParseError::Invalid16Bit("A5_3")),
                    }
                }
            }
            impl ToOperation for A5_3 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::And(and) => {
                            operation::AndRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(None)
                                .set_rn(and.rdn)
                                .set_rm(and.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Eor(eor) => {
                            operation::EorRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(None)
                                .set_rn(eor.rdn)
                                .set_rm(eor.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Lsl(lsl) => {
                            operation::LslRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(lsl.rdn)
                                .set_rn(lsl.rdn)
                                .set_rm(lsl.rm)
                                .complete()
                                .into()
                        }
                        Self::Lsr(lsr) => {
                            operation::LsrRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(lsr.rdn)
                                .set_rn(lsr.rdn)
                                .set_rm(lsr.rm)
                                .complete()
                                .into()
                        }
                        Self::Asr(asr) => {
                            operation::AsrRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(asr.rdn)
                                .set_rn(asr.rdn)
                                .set_rm(asr.rm)
                                .complete()
                                .into()
                        }
                        Self::Adc(adc) => {
                            operation::AdcRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(None)
                                .set_rn(adc.rdn)
                                .set_rm(adc.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Sbc(sbc) => {
                            operation::SbcRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(None)
                                .set_rn(sbc.rdn)
                                .set_rm(sbc.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Ror(ror) => {
                            operation::RorRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(ror.rdn)
                                .set_rn(ror.rdn)
                                .set_rm(ror.rm)
                                .complete()
                                .into()
                        }
                        Self::Tst(tst) => {
                            operation::TstRegisterBuilder::new()
                                .set_rn(tst.rn)
                                .set_rm(tst.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Rsb(rsb) => {
                            operation::RsbImmediateBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(Some(rsb.rd))
                                .set_rn(rsb.rn)
                                .set_imm(0)
                                .complete()
                                .into()
                        }
                        Self::Cmp(cmp) => {
                            operation::CmpRegisterBuilder::new()
                                .set_rn(cmp.rn)
                                .set_rm(cmp.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Cmn(cmn) => {
                            operation::CmnRegisterBuilder::new()
                                .set_rn(cmn.rn)
                                .set_rm(cmn.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Orr(orr) => {
                            operation::OrrRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(None)
                                .set_rn(orr.rdn)
                                .set_rm(orr.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Mul(mul) => {
                            operation::MulBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(Some(mul.rdm))
                                .set_rn(mul.rn)
                                .set_rm(mul.rdm)
                                .complete()
                                .into()
                        }
                        Self::Bic(bic) => {
                            operation::BicRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(Some(bic.rdn))
                                .set_rn(bic.rdn)
                                .set_rm(bic.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Mvn(mvn) => {
                            operation::MvnRegisterBuilder::new()
                                .set_s(Some(arch::SetFlags::InITBlock(false)))
                                .set_rd(mvn.rd)
                                .set_rm(mvn.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a_5_4 {
            use paste::paste;
            use super::Mask;
            use crate::{
                arch::Register, combine, instruction, operation, Parse, ParseError,
                Stream, ToOperation,
            };
            pub enum A5_4 {
                Add(Add),
                Cmp(Cmp),
                Mov(Mov),
                Bx(Bx),
                Blx(Blx),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_4 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_4::Add(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Add",
                                &__self_0,
                            )
                        }
                        A5_4::Cmp(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cmp",
                                &__self_0,
                            )
                        }
                        A5_4::Mov(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mov",
                                &__self_0,
                            )
                        }
                        A5_4::Bx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bx",
                                &__self_0,
                            )
                        }
                        A5_4::Blx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Blx",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_4 {
                #[allow(dead_code)]
                pub(crate) fn parse_add<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Add(Add::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cmp<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cmp(Cmp::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mov<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mov(Mov::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Bx(Bx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_blx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Blx(Blx::parse(iter)?))
                }
            }
            /**Instruction Add from table A5_4

*/
            /**Contains the following fields:
*/
            /**- rdn of type u8 from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 6
*/
            /**- dn of type u8 from bit 7 to bit 7
*/
            pub struct Add {
                /**bit 0 to 2

*/
                pub(crate) rdn: u8,
                /**bit 3 to 6

*/
                pub(crate) rm: Register,
                /**bit 7 to 7

*/
                pub(crate) dn: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Add {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Add",
                        "rdn",
                        &self.rdn,
                        "rm",
                        &self.rm,
                        "dn",
                        &&self.dn,
                    )
                }
            }
            impl Parse for Add {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Add")),
                    }?;
                    let rdn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 6>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<7, 7>() as u8)
                    };
                    let ret = Self { rdn, rm, dn };
                    Ok(ret)
                }
            }
            /**Instruction Cmp from table A5_4

*/
            /**Contains the following fields:
*/
            /**- rn of type u8 from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 6
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            pub struct Cmp {
                /**bit 0 to 2

*/
                pub(crate) rn: u8,
                /**bit 3 to 6

*/
                pub(crate) rm: Register,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cmp {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Cmp",
                        "rn",
                        &self.rn,
                        "rm",
                        &self.rm,
                        "n",
                        &&self.n,
                    )
                }
            }
            impl Parse for Cmp {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cmp")),
                    }?;
                    let rn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 6>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<7, 7>() as u8)
                    };
                    let ret = Self { rn, rm, n };
                    Ok(ret)
                }
            }
            /**Instruction Mov from table A5_4

*/
            /**Contains the following fields:
*/
            /**- rd of type u8 from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 6
*/
            /**- d of type u8 from bit 7 to bit 7
*/
            pub struct Mov {
                /**bit 0 to 2

*/
                pub(crate) rd: u8,
                /**bit 3 to 6

*/
                pub(crate) rm: Register,
                /**bit 7 to 7

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mov {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Mov",
                        "rd",
                        &self.rd,
                        "rm",
                        &self.rm,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for Mov {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mov")),
                    }?;
                    let rd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 6>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<7, 7>() as u8)
                    };
                    let ret = Self { rd, rm, d };
                    Ok(ret)
                }
            }
            /**Instruction Bx from table A5_4

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 6
*/
            pub struct Bx {
                /**bit 3 to 6

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Bx",
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Bx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Bx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 6>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm };
                    Ok(ret)
                }
            }
            /**Instruction Blx from table A5_4

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 3 to bit 6
*/
            pub struct Blx {
                /**bit 3 to 6

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Blx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Blx",
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Blx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Blx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 6>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm };
                    Ok(ret)
                }
            }
            impl Parse for A5_4 {
                type Target = Self;
                fn parse<T: Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let first_byte = match iter.peek::<1>() as Option<u8> {
                        Some(b) => Ok(b),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let second_byte = match iter.peek::<2>() as Option<u8> {
                        Some(b) => Ok(b),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op = ((first_byte & 0b11) << 2) | (second_byte >> 6);
                    if op & 0b1100 == 00 {
                        return Ok(Self::Add(Add::parse(iter)?));
                    }
                    if op == 0b0100 {
                        return Err(ParseError::Unpredictable);
                    }
                    if op == 0b0101 || op & 0b1110 == 0b0110 {
                        return Ok(Self::Cmp(Cmp::parse(iter)?));
                    }
                    if op & 0b1100 == 0b1000 {
                        return Ok(Self::Mov(Mov::parse(iter)?));
                    }
                    if op & 0b1110 == 0b1100 {
                        return Ok(Self::Bx(Bx::parse(iter)?));
                    }
                    if op & 0b1110 == 0b1110 {
                        return Ok(Self::Blx(Blx::parse(iter)?));
                    }
                    Err(ParseError::Invalid16Bit("A5_4"))
                }
            }
            impl ToOperation for A5_4 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Add(el) => {
                            let (dn, rdn) = (el.dn, el.rdn);
                            let reg: Register = {
                                let mut counter: usize = { 3 + 0 };
                                let mut sum: u8 = (dn as u8) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 3;
                                    sum |= ((rdn as u8) << counter) as u8;
                                }
                                sum
                            }
                                .try_into()
                                .unwrap();
                            operation::AddRegister::builder()
                                .set_s(Some(false.into()))
                                .set_rd(Some(reg))
                                .set_rn(reg)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Cmp(el) => {
                            let (n, rn) = (el.n, el.rn);
                            let reg: Register = {
                                let mut counter: usize = { 3 + 0 };
                                let mut sum: u8 = (n as u8) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 3;
                                    sum |= ((rn as u8) << counter) as u8;
                                }
                                sum
                            }
                                .try_into()
                                .unwrap();
                            operation::CmpRegister::builder()
                                .set_rn(reg)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Mov(el) => {
                            let (d, rd) = (el.d, el.rd);
                            let reg: Register = {
                                let mut counter: usize = { 3 + 0 };
                                let mut sum: u8 = (d as u8) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 3;
                                    sum |= ((rd as u8) << counter) as u8;
                                }
                                sum
                            }
                                .try_into()
                                .unwrap();
                            operation::MovRegister::builder()
                                .set_s(Some(false))
                                .set_rd(reg)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Bx(el) => {
                            operation::Bx::builder().set_rm(el.rm).complete().into()
                        }
                        Self::Blx(el) => {
                            operation::Blx::builder().set_rm(el.rm).complete().into()
                        }
                    }
                }
            }
        }
        pub mod a_5_5 {
            use paste::paste;
            use super::Mask;
            use crate::{
                arch::Register, instruction, operation, Parse, ParseError, Stream,
                ToOperation,
            };
            pub enum A5_5 {
                Str(Str),
                Strh(Strh),
                Strb(Strb),
                Ldrsb(Ldrsb),
                Ldr(Ldr),
                Ldrh(Ldrh),
                Ldrb(Ldrb),
                Ldrsh(Ldrsh),
                StrI(StrI),
                LdrI(LdrI),
                StrbI(StrbI),
                LdrbI(LdrbI),
                StrhI(StrhI),
                LdrhI(LdrhI),
                StrRI(StrRI),
                LdrRI(LdrRI),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_5 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_5::Str(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Str",
                                &__self_0,
                            )
                        }
                        A5_5::Strh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Strh",
                                &__self_0,
                            )
                        }
                        A5_5::Strb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Strb",
                                &__self_0,
                            )
                        }
                        A5_5::Ldrsb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrsb",
                                &__self_0,
                            )
                        }
                        A5_5::Ldr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldr",
                                &__self_0,
                            )
                        }
                        A5_5::Ldrh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrh",
                                &__self_0,
                            )
                        }
                        A5_5::Ldrb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrb",
                                &__self_0,
                            )
                        }
                        A5_5::Ldrsh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrsh",
                                &__self_0,
                            )
                        }
                        A5_5::StrI(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrI",
                                &__self_0,
                            )
                        }
                        A5_5::LdrI(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrI",
                                &__self_0,
                            )
                        }
                        A5_5::StrbI(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrbI",
                                &__self_0,
                            )
                        }
                        A5_5::LdrbI(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrbI",
                                &__self_0,
                            )
                        }
                        A5_5::StrhI(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrhI",
                                &__self_0,
                            )
                        }
                        A5_5::LdrhI(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrhI",
                                &__self_0,
                            )
                        }
                        A5_5::StrRI(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrRI",
                                &__self_0,
                            )
                        }
                        A5_5::LdrRI(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrRI",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_5 {
                #[allow(dead_code)]
                pub(crate) fn parse_str<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Str(Str::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strh<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Strh(Strh::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Strb(Strb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrsb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrsb(Ldrsb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldr(Ldr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrh<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrh(Ldrh::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrb(Ldrb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrsh<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrsh(Ldrsh::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_stri<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrI(StrI::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldri<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrI(LdrI::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strbi<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrbI(StrbI::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrbi<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrbI(LdrbI::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strhi<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrhI(StrhI::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrhi<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrhI(LdrhI::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strri<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrRI(StrRI::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrri<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrRI(LdrRI::parse(iter)?))
                }
            }
            /**Instruction Str from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Str {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Str {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Str",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Str {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Str")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction Strh from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Strh {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Strh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Strh",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Strh {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Strh")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction Strb from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Strb {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Strb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Strb",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Strb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Strb")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction Ldrsb from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Ldrsb {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrsb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrsb",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Ldrsb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrsb")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction Ldr from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Ldr {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldr",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Ldr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldr")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction Ldrh from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Ldrh {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrh",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Ldrh {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrh")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction Ldrb from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Ldrb {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrb",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Ldrb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrb")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction Ldrsh from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- rm of type Register from bit 6 to bit 8
*/
            pub struct Ldrsh {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 8

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrsh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrsh",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Ldrsh {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrsh")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 8>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn, rm };
                    Ok(ret)
                }
            }
            /**Instruction StrI from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- imm5 of type u8 from bit 6 to bit 10
*/
            pub struct StrI {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 10

*/
                pub(crate) imm5: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrI {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "StrI",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "imm5",
                        &&self.imm5,
                    )
                }
            }
            impl Parse for StrI {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrI")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rt, rn, imm5 };
                    Ok(ret)
                }
            }
            /**Instruction LdrI from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- imm5 of type u8 from bit 6 to bit 10
*/
            pub struct LdrI {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 10

*/
                pub(crate) imm5: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrI {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrI",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "imm5",
                        &&self.imm5,
                    )
                }
            }
            impl Parse for LdrI {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrI")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rt, rn, imm5 };
                    Ok(ret)
                }
            }
            /**Instruction StrbI from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- imm5 of type u8 from bit 6 to bit 10
*/
            pub struct StrbI {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 10

*/
                pub(crate) imm5: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrbI {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "StrbI",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "imm5",
                        &&self.imm5,
                    )
                }
            }
            impl Parse for StrbI {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrbI")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rt, rn, imm5 };
                    Ok(ret)
                }
            }
            /**Instruction LdrbI from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- imm5 of type u8 from bit 6 to bit 10
*/
            pub struct LdrbI {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 10

*/
                pub(crate) imm5: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrbI {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrbI",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "imm5",
                        &&self.imm5,
                    )
                }
            }
            impl Parse for LdrbI {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrbI")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rt, rn, imm5 };
                    Ok(ret)
                }
            }
            /**Instruction StrhI from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- imm5 of type u8 from bit 6 to bit 10
*/
            pub struct StrhI {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 10

*/
                pub(crate) imm5: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrhI {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "StrhI",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "imm5",
                        &&self.imm5,
                    )
                }
            }
            impl Parse for StrhI {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrhI")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rt, rn, imm5 };
                    Ok(ret)
                }
            }
            /**Instruction LdrhI from table A5_5

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 0 to bit 2
*/
            /**- rn of type Register from bit 3 to bit 5
*/
            /**- imm5 of type u8 from bit 6 to bit 10
*/
            pub struct LdrhI {
                /**bit 0 to 2

*/
                pub(crate) rt: Register,
                /**bit 3 to 5

*/
                pub(crate) rn: Register,
                /**bit 6 to 10

*/
                pub(crate) imm5: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrhI {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrhI",
                        "rt",
                        &self.rt,
                        "rn",
                        &self.rn,
                        "imm5",
                        &&self.imm5,
                    )
                }
            }
            impl Parse for LdrhI {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrhI")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<6, 10>() as u8)
                    };
                    let ret = Self { rt, rn, imm5 };
                    Ok(ret)
                }
            }
            /**Instruction StrRI from table A5_5

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 8 to bit 10
*/
            pub struct StrRI {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 10

*/
                pub(crate) rt: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrRI {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "StrRI",
                        "imm8",
                        &self.imm8,
                        "rt",
                        &&self.rt,
                    )
                }
            }
            impl Parse for StrRI {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrRI")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rt };
                    Ok(ret)
                }
            }
            /**Instruction LdrRI from table A5_5

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 8 to bit 10
*/
            pub struct LdrRI {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 10

*/
                pub(crate) rt: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrRI {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "LdrRI",
                        "imm8",
                        &self.imm8,
                        "rt",
                        &&self.rt,
                    )
                }
            }
            impl Parse for LdrRI {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrRI")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rt };
                    Ok(ret)
                }
            }
            impl Parse for A5_5 {
                type Target = Self;
                #[allow(unused_assignments)]
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word = match iter.peek::<1>() as Option<u16> {
                        Some(u) => Ok(u),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op1 = word.mask::<12, 15>();
                    let op2 = word.mask::<9, 11>();
                    if !(op2 <= 7) {
                        ::core::panicking::panic("assertion failed: op2 <= 7")
                    }
                    if op1 == 0b0101 {
                        return match op2 {
                            0 => Ok(Self::Str(Str::parse(iter)?)),
                            1 => Ok(Self::Strh(Strh::parse(iter)?)),
                            2 => Ok(Self::Strb(Strb::parse(iter)?)),
                            3 => Ok(Self::Ldrsb(Ldrsb::parse(iter)?)),
                            4 => Ok(Self::Ldr(Ldr::parse(iter)?)),
                            5 => Ok(Self::Ldrh(Ldrh::parse(iter)?)),
                            6 => Ok(Self::Ldrb(Ldrb::parse(iter)?)),
                            7 => Ok(Self::Ldrsh(Ldrsh::parse(iter)?)),
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("Ureachable due to previous asserts"),
                                    ),
                                );
                            }
                        };
                    }
                    if op1 == 0b0110 {
                        return Ok(
                            if op2 & 0b100 == 0 {
                                Self::StrI(StrI::parse(iter)?)
                            } else {
                                Self::LdrI(LdrI::parse(iter)?)
                            },
                        );
                    }
                    if op1 == 0b0111 {
                        return Ok(
                            if op2 & 0b100 == 0 {
                                Self::StrbI(StrbI::parse(iter)?)
                            } else {
                                Self::LdrbI(LdrbI::parse(iter)?)
                            },
                        );
                    }
                    if op1 == 0b1000 {
                        return Ok(
                            if op2 & 0b100 == 0 {
                                Self::StrhI(StrhI::parse(iter)?)
                            } else {
                                Self::LdrhI(LdrhI::parse(iter)?)
                            },
                        );
                    }
                    if op1 == 0b1001 {
                        return Ok(
                            if op2 & 0b100 == 0 {
                                Self::StrRI(StrRI::parse(iter)?)
                            } else {
                                Self::LdrRI(LdrRI::parse(iter)?)
                            },
                        );
                    }
                    Err(ParseError::Invalid16Bit("A5_5"))
                }
            }
            impl ToOperation for A5_5 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Str(el) => {
                            operation::StrRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Strh(el) => {
                            operation::StrhRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Strb(el) => {
                            operation::StrbRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Ldr(el) => {
                            operation::LdrRegister::builder()
                                .set_w(Some(false))
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Ldrh(el) => {
                            operation::LdrhRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Ldrsb(el) => {
                            operation::LdrsbRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::Ldrb(el) => {
                            operation::LdrbRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .set_add(Some(true))
                                .complete()
                                .into()
                        }
                        Self::Ldrsh(el) => {
                            operation::LdrshRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(None)
                                .complete()
                                .into()
                        }
                        Self::StrI(el) => {
                            operation::StrImmediate::builder()
                                .set_w(Some(false))
                                .set_index(Some(true))
                                .set_add(true)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm((el.imm5 as u32) << 2)
                                .complete()
                                .into()
                        }
                        Self::LdrI(el) => {
                            operation::LdrImmediate::builder()
                                .set_w(Some(false))
                                .set_add(true)
                                .set_index(true)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm((el.imm5 as u32) << 2)
                                .complete()
                                .into()
                        }
                        Self::StrbI(el) => {
                            operation::StrbImmediate::builder()
                                .set_w(Some(false))
                                .set_index(Some(true))
                                .set_add(true)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm5 as u32)
                                .complete()
                                .into()
                        }
                        Self::LdrbI(el) => {
                            operation::LdrbImmediate::builder()
                                .set_w(Some(false))
                                .set_add(Some(true))
                                .set_index(true)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm5 as u32))
                                .complete()
                                .into()
                        }
                        Self::StrhI(el) => {
                            operation::StrhImmediate::builder()
                                .set_index(true)
                                .set_add(true)
                                .set_w(false)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some((el.imm5 as u32) << 1))
                                .complete()
                                .into()
                        }
                        Self::LdrhI(el) => {
                            operation::LdrhImmediate::builder()
                                .set_w(Some(false))
                                .set_add(Some(true))
                                .set_index(Some(true))
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm((el.imm5 as u32) << 1)
                                .complete()
                                .into()
                        }
                        Self::StrRI(el) => {
                            operation::StrImmediate::builder()
                                .set_w(Some(false))
                                .set_index(Some(true))
                                .set_add(true)
                                .set_rt(el.rt)
                                .set_rn(13_u8.try_into().unwrap())
                                .set_imm((el.imm8 as u32) << 2)
                                .complete()
                                .into()
                        }
                        Self::LdrRI(el) => {
                            operation::LdrImmediate::builder()
                                .set_w(Some(false))
                                .set_add(true)
                                .set_index(true)
                                .set_rt(el.rt)
                                .set_rn(13u8.try_into().unwrap())
                                .set_imm((el.imm8 as u32) << 2)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a_5_6 {
            use paste::paste;
            use super::{a_5_7::A5_7, Mask};
            use crate::{
                arch::{Register, RegisterList},
                combine, instruction, operation, Parse, ParseError, ToOperation,
            };
            pub enum A5_6 {
                Cps(Cps),
                AddImmediateToSP(AddImmediateToSP),
                SubImmediateFromSp(SubImmediateFromSp),
                Cbz(Cbz),
                Sxth(Sxth),
                Sxtb(Sxtb),
                Uxth(Uxth),
                Uxtb(Uxtb),
                Cbnz(Cbnz),
                Push(Push),
                Rev(Rev),
                Rev16(Rev16),
                Revsh(Revsh),
                Pop(Pop),
                Bkpt(Bkpt),
                ///Externally defined instruction or set of instructions [`A5_7`]
                SubtableA5_7(A5_7),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_6 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_6::Cps(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cps",
                                &__self_0,
                            )
                        }
                        A5_6::AddImmediateToSP(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "AddImmediateToSP",
                                &__self_0,
                            )
                        }
                        A5_6::SubImmediateFromSp(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubImmediateFromSp",
                                &__self_0,
                            )
                        }
                        A5_6::Cbz(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cbz",
                                &__self_0,
                            )
                        }
                        A5_6::Sxth(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sxth",
                                &__self_0,
                            )
                        }
                        A5_6::Sxtb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sxtb",
                                &__self_0,
                            )
                        }
                        A5_6::Uxth(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uxth",
                                &__self_0,
                            )
                        }
                        A5_6::Uxtb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uxtb",
                                &__self_0,
                            )
                        }
                        A5_6::Cbnz(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cbnz",
                                &__self_0,
                            )
                        }
                        A5_6::Push(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Push",
                                &__self_0,
                            )
                        }
                        A5_6::Rev(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rev",
                                &__self_0,
                            )
                        }
                        A5_6::Rev16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rev16",
                                &__self_0,
                            )
                        }
                        A5_6::Revsh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Revsh",
                                &__self_0,
                            )
                        }
                        A5_6::Pop(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Pop",
                                &__self_0,
                            )
                        }
                        A5_6::Bkpt(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bkpt",
                                &__self_0,
                            )
                        }
                        A5_6::SubtableA5_7(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubtableA5_7",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_6 {
                #[allow(dead_code)]
                pub(crate) fn parse_cps<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cps(Cps::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_addimmediatetosp<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::AddImmediateToSP(AddImmediateToSP::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_subimmediatefromsp<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::SubImmediateFromSp(SubImmediateFromSp::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cbz<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cbz(Cbz::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sxth<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sxth(Sxth::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sxtb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sxtb(Sxtb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uxth<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uxth(Uxth::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uxtb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uxtb(Uxtb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cbnz<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cbnz(Cbnz::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_push<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Push(Push::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rev<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rev(Rev::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rev16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rev16(Rev16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_revsh<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Revsh(Revsh::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pop<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Pop(Pop::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bkpt<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Bkpt(Bkpt::parse(iter)?))
                }
            }
            /**Instruction Cps from table A5_6

*/
            /**Contains the following fields:
*/
            /**- f of type u8 from bit 0 to bit 0
*/
            /**- i of type u8 from bit 1 to bit 1
*/
            /**- im of type u8 from bit 4 to bit 4
*/
            pub struct Cps {
                /**bit 0 to 0

*/
                pub(crate) f: u8,
                /**bit 1 to 1

*/
                pub(crate) i: u8,
                /**bit 4 to 4

*/
                pub(crate) im: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cps {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Cps",
                        "f",
                        &self.f,
                        "i",
                        &self.i,
                        "im",
                        &&self.im,
                    )
                }
            }
            impl Parse for Cps {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cps")),
                    }?;
                    let f: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 0>() as u8)
                    };
                    let i: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<1, 1>() as u8)
                    };
                    let im: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<4, 4>() as u8)
                    };
                    let ret = Self { f, i, im };
                    Ok(ret)
                }
            }
            /**Instruction AddImmediateToSP from table A5_6

*/
            /**Contains the following fields:
*/
            /**- imm7 of type u8 from bit 0 to bit 6
*/
            pub struct AddImmediateToSP {
                /**bit 0 to 6

*/
                pub(crate) imm7: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for AddImmediateToSP {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "AddImmediateToSP",
                        "imm7",
                        &&self.imm7,
                    )
                }
            }
            impl Parse for AddImmediateToSP {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("AddImmediateToSP")),
                    }?;
                    let imm7: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 6>() as u8)
                    };
                    let ret = Self { imm7 };
                    Ok(ret)
                }
            }
            /**Instruction SubImmediateFromSp from table A5_6

*/
            /**Contains the following fields:
*/
            /**- imm7 of type u8 from bit 0 to bit 6
*/
            pub struct SubImmediateFromSp {
                /**bit 0 to 6

*/
                pub(crate) imm7: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubImmediateFromSp {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SubImmediateFromSp",
                        "imm7",
                        &&self.imm7,
                    )
                }
            }
            impl Parse for SubImmediateFromSp {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("SubImmediateFromSp")),
                    }?;
                    let imm7: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 6>() as u8)
                    };
                    let ret = Self { imm7 };
                    Ok(ret)
                }
            }
            /**Instruction Cbz from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rn of type Register from bit 0 to bit 2
*/
            /**- imm5 of type u8 from bit 3 to bit 7
*/
            /**- op of type u8 from bit 11 to bit 11
*/
            pub struct Cbz {
                /**bit 0 to 2

*/
                pub(crate) rn: Register,
                /**bit 3 to 7

*/
                pub(crate) imm5: u8,
                /**bit 11 to 11

*/
                pub(crate) op: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cbz {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Cbz",
                        "rn",
                        &self.rn,
                        "imm5",
                        &self.imm5,
                        "op",
                        &&self.op,
                    )
                }
            }
            impl Parse for Cbz {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cbz")),
                    }?;
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 7>() as u8)
                    };
                    let op: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<11, 11>() as u8)
                    };
                    let ret = Self { rn, imm5, op };
                    Ok(ret)
                }
            }
            /**Instruction Sxth from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            pub struct Sxth {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sxth {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Sxth",
                        "rd",
                        &self.rd,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Sxth {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sxth")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rm };
                    Ok(ret)
                }
            }
            /**Instruction Sxtb from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            pub struct Sxtb {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sxtb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Sxtb",
                        "rd",
                        &self.rd,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Sxtb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sxtb")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rm };
                    Ok(ret)
                }
            }
            /**Instruction Uxth from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            pub struct Uxth {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uxth {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Uxth",
                        "rd",
                        &self.rd,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Uxth {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uxth")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rm };
                    Ok(ret)
                }
            }
            /**Instruction Uxtb from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            pub struct Uxtb {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uxtb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Uxtb",
                        "rd",
                        &self.rd,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Uxtb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uxtb")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rm };
                    Ok(ret)
                }
            }
            /**Instruction Cbnz from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rn of type Register from bit 0 to bit 2
*/
            /**- imm5 of type u8 from bit 3 to bit 7
*/
            /**- op of type u8 from bit 11 to bit 11
*/
            pub struct Cbnz {
                /**bit 0 to 2

*/
                pub(crate) rn: Register,
                /**bit 3 to 7

*/
                pub(crate) imm5: u8,
                /**bit 11 to 11

*/
                pub(crate) op: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cbnz {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Cbnz",
                        "rn",
                        &self.rn,
                        "imm5",
                        &self.imm5,
                        "op",
                        &&self.op,
                    )
                }
            }
            impl Parse for Cbnz {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cbnz")),
                    }?;
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm5: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 7>() as u8)
                    };
                    let op: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<11, 11>() as u8)
                    };
                    let ret = Self { rn, imm5, op };
                    Ok(ret)
                }
            }
            /**Instruction Push from table A5_6

*/
            /**Contains the following fields:
*/
            /**- register_list of type RegisterList from bit 0 to bit 7
*/
            /**- m of type u8 from bit 8 to bit 8
*/
            pub struct Push {
                /**bit 0 to 7

*/
                pub(crate) register_list: RegisterList,
                /**bit 8 to 8

*/
                pub(crate) m: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Push {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Push",
                        "register_list",
                        &self.register_list,
                        "m",
                        &&self.m,
                    )
                }
            }
            impl Parse for Push {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Push")),
                    }?;
                    let register_list: RegisterList = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>()).try_into().map_err(|e| map(e))?
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 8>() as u8)
                    };
                    let ret = Self { register_list, m };
                    Ok(ret)
                }
            }
            /**Instruction Rev from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            pub struct Rev {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rev {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Rev",
                        "rd",
                        &self.rd,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Rev {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rev")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rm };
                    Ok(ret)
                }
            }
            /**Instruction Rev16 from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            pub struct Rev16 {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rev16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Rev16",
                        "rd",
                        &self.rd,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Rev16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rev16")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rm };
                    Ok(ret)
                }
            }
            /**Instruction Revsh from table A5_6

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 2
*/
            /**- rm of type Register from bit 3 to bit 5
*/
            pub struct Revsh {
                /**bit 0 to 2

*/
                pub(crate) rd: Register,
                /**bit 3 to 5

*/
                pub(crate) rm: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Revsh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Revsh",
                        "rd",
                        &self.rd,
                        "rm",
                        &&self.rm,
                    )
                }
            }
            impl Parse for Revsh {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Revsh")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 2>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<3, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rm };
                    Ok(ret)
                }
            }
            /**Instruction Pop from table A5_6

*/
            /**Contains the following fields:
*/
            /**- register_list of type u16 from bit 0 to bit 7
*/
            /**- p of type u16 from bit 8 to bit 8
*/
            pub struct Pop {
                /**bit 0 to 7

*/
                pub(crate) register_list: u16,
                /**bit 8 to 8

*/
                pub(crate) p: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Pop {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Pop",
                        "register_list",
                        &self.register_list,
                        "p",
                        &&self.p,
                    )
                }
            }
            impl Parse for Pop {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Pop")),
                    }?;
                    let register_list: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>())
                    };
                    let p: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 8>() as u16)
                    };
                    let ret = Self { register_list, p };
                    Ok(ret)
                }
            }
            /**Instruction Bkpt from table A5_6

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            pub struct Bkpt {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bkpt {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Bkpt",
                        "imm8",
                        &&self.imm8,
                    )
                }
            }
            impl Parse for Bkpt {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Bkpt")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let ret = Self { imm8 };
                    Ok(ret)
                }
            }
            impl Parse for A5_6 {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let opcode = match iter.peek::<1>() as Option<u16> {
                        Some(u) => Ok(u.mask::<5, 11>()),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    if opcode == 0b0110011 {
                        return Ok(Self::Cps(Cps::parse(iter)?));
                    }
                    if opcode >> 2 == 0 {
                        return Ok(
                            Self::AddImmediateToSP(AddImmediateToSP::parse(iter)?),
                        );
                    }
                    if opcode & 0b1111100 == 0b100 {
                        return Ok(
                            Self::SubImmediateFromSp(SubImmediateFromSp::parse(iter)?),
                        );
                    }
                    if opcode & 0b1111000 == 0b1000 {
                        return Ok(Self::Cbz(Cbz::parse(iter)?));
                    }
                    if opcode & 0b1111110 == 0b10000 {
                        return Ok(Self::Sxth(Sxth::parse(iter)?));
                    }
                    if opcode & 0b1111110 == 0b10010 {
                        return Ok(Self::Sxtb(Sxtb::parse(iter)?));
                    }
                    if opcode & 0b1111110 == 0b10100 {
                        return Ok(Self::Uxth(Uxth::parse(iter)?));
                    }
                    if opcode & 0b1111110 == 0b10110 {
                        return Ok(Self::Uxtb(Uxtb::parse(iter)?));
                    }
                    if opcode & 0b1111000 == 0b0011000 {
                        return Ok(Self::Cbz(Cbz::parse(iter)?));
                    }
                    if opcode & 0b1110000 == 0b0100000 {
                        return Ok(Self::Push(Push::parse(iter)?));
                    }
                    if opcode & 0b1111000 == 0b1001000 {
                        return Ok(Self::Cbnz(Cbnz::parse(iter)?));
                    }
                    if opcode & 0b1111110 == 0b1010000 {
                        return Ok(Self::Rev(Rev::parse(iter)?));
                    }
                    if opcode & 0b1111110 == 0b1010010 {
                        return Ok(Self::Rev16(Rev16::parse(iter)?));
                    }
                    if opcode & 0b1111110 == 0b1010110 {
                        return Ok(Self::Revsh(Revsh::parse(iter)?));
                    }
                    if opcode & 0b1111000 == 0b1011000 {
                        return Ok(Self::Cbnz(Cbnz::parse(iter)?));
                    }
                    if opcode & 0b1110000 == 0b1100000 {
                        return Ok(Self::Pop(Pop::parse(iter)?));
                    }
                    if opcode & 0b1111000 == 0b1110000 {
                        return Ok(Self::Bkpt(Bkpt::parse(iter)?));
                    }
                    if opcode & 0b1111000 == 0b1111000 {
                        return Ok(Self::SubtableA5_7(A5_7::parse(iter)?));
                    }
                    Err(ParseError::Invalid16Bit("A5_6"))
                }
            }
            impl ToOperation for A5_6 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Cps(el) => {
                            operation::Cps::builder()
                                .set_enable(el.im == 0)
                                .set_disable(el.im == 1)
                                .set_affect_pri(el.i == 1)
                                .set_affect_fault(el.f == 1)
                                .complete()
                                .into()
                        }
                        Self::AddImmediateToSP(el) => {
                            operation::AddSPImmediate::builder()
                                .set_s(Some(false))
                                .set_rd(None)
                                .set_imm((el.imm7 as u32) << 2)
                                .complete()
                                .into()
                        }
                        Self::SubImmediateFromSp(el) => {
                            operation::SubSpMinusImmediate::builder()
                                .set_s(Some(false))
                                .set_rd(None)
                                .set_imm((el.imm7 as u32) << 2)
                                .complete()
                                .into()
                        }
                        Self::Cbz(el) => {
                            operation::Cbz::builder()
                                .set_non(Some(el.op == 1))
                                .set_rn(el.rn)
                                .set_imm((el.imm5 as u32) << 1)
                                .complete()
                                .into()
                        }
                        Self::Sxth(el) => {
                            operation::Sxth::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_rotation(None)
                                .complete()
                                .into()
                        }
                        Self::Sxtb(el) => {
                            operation::Sxtb::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_rotation(None)
                                .complete()
                                .into()
                        }
                        Self::Uxth(el) => {
                            operation::Uxth::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_rotation(None)
                                .complete()
                                .into()
                        }
                        Self::Uxtb(el) => {
                            operation::Uxtb::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_rotation(None)
                                .complete()
                                .into()
                        }
                        Self::Push(el) => {
                            let mut el = el;
                            if el.m == 1 {
                                el.register_list.registers.push(Register::LR);
                            }
                            operation::Push::builder()
                                .set_registers(el.register_list)
                                .complete()
                                .into()
                        }
                        Self::Rev(el) => {
                            operation::Rev::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Rev16(el) => {
                            operation::Rev16::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Revsh(el) => {
                            operation::Revsh::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Cbnz(el) => {
                            operation::Cbz::builder()
                                .set_non(Some(el.op == 1))
                                .set_rn(el.rn)
                                .set_imm((el.imm5 as u32) << 1)
                                .complete()
                                .into()
                        }
                        Self::Pop(el) => {
                            let registers = el.register_list;
                            let p = el.p;
                            let registers = {
                                let mut counter: usize = { 7 + 8 + 0 };
                                let mut sum: u16 = (p as u16) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 7;
                                    sum |= ((0 as u16) << counter) as u16;
                                    counter -= 8;
                                    sum |= ((registers as u16) << counter) as u16;
                                }
                                sum
                            }
                                .try_into()
                                .unwrap();
                            operation::Pop::builder()
                                .set_registers(registers)
                                .complete()
                                .into()
                        }
                        Self::Bkpt(el) => {
                            operation::Bkpt::builder()
                                .set_imm(el.imm8 as u32)
                                .complete()
                                .into()
                        }
                        Self::SubtableA5_7(el) => el.encoding_specific_operations(),
                    }
                }
            }
        }
        pub mod a_5_7 {
            //! Parses instructions based on the table A5.2.1
            #![allow(dead_code)]
            use paste::paste;
            use super::Mask;
            use crate::{
                arch::Condition, instruction, operation, Parse, ParseError, ToOperation,
            };
            pub enum A5_7 {
                It(It),
                Nop(Nop),
                Yield(Yield),
                Wfe(Wfe),
                Wfi(Wfi),
                Sev(Sev),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_7 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_7::It(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "It",
                                &__self_0,
                            )
                        }
                        A5_7::Nop(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Nop",
                                &__self_0,
                            )
                        }
                        A5_7::Yield(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Yield",
                                &__self_0,
                            )
                        }
                        A5_7::Wfe(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Wfe",
                                &__self_0,
                            )
                        }
                        A5_7::Wfi(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Wfi",
                                &__self_0,
                            )
                        }
                        A5_7::Sev(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sev",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_7 {
                #[allow(dead_code)]
                pub(crate) fn parse_it<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::It(It::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_nop<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Nop(Nop::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_yield<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Yield(Yield::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_wfe<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Wfe(Wfe::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_wfi<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Wfi(Wfi::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sev<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sev(Sev::parse(iter)?))
                }
            }
            /**Instruction It from table A5_7

*/
            /**Contains the following fields:
*/
            /**- mask of type u8 from bit 0 to bit 3
*/
            /**- firstcond of type Condition from bit 4 to bit 7
*/
            pub struct It {
                /**bit 0 to 3

*/
                pub(crate) mask: u8,
                /**bit 4 to 7

*/
                pub(crate) firstcond: Condition,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for It {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "It",
                        "mask",
                        &self.mask,
                        "firstcond",
                        &&self.firstcond,
                    )
                }
            }
            impl Parse for It {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("It")),
                    }?;
                    let mask: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 3>() as u8)
                    };
                    let firstcond: Condition = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<4, 7>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { mask, firstcond };
                    Ok(ret)
                }
            }
            /**Instruction Nop from table A5_7

*/
            /**Contains the following fields:
*/
            pub struct Nop {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Nop {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Nop")
                }
            }
            impl Parse for Nop {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Nop")),
                    }?;
                    let ret = Self {};
                    Ok(ret)
                }
            }
            /**Instruction Yield from table A5_7

*/
            /**Contains the following fields:
*/
            pub struct Yield {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Yield {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Yield")
                }
            }
            impl Parse for Yield {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Yield")),
                    }?;
                    let ret = Self {};
                    Ok(ret)
                }
            }
            /**Instruction Wfe from table A5_7

*/
            /**Contains the following fields:
*/
            pub struct Wfe {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Wfe {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Wfe")
                }
            }
            impl Parse for Wfe {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Wfe")),
                    }?;
                    let ret = Self {};
                    Ok(ret)
                }
            }
            /**Instruction Wfi from table A5_7

*/
            /**Contains the following fields:
*/
            pub struct Wfi {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Wfi {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Wfi")
                }
            }
            impl Parse for Wfi {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Wfi")),
                    }?;
                    let ret = Self {};
                    Ok(ret)
                }
            }
            /**Instruction Sev from table A5_7

*/
            /**Contains the following fields:
*/
            pub struct Sev {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Sev {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Sev")
                }
            }
            impl Parse for Sev {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sev")),
                    }?;
                    let ret = Self {};
                    Ok(ret)
                }
            }
            impl Parse for A5_7 {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = iter.next()?;
                    let opb = word.mask::<0, 3>();
                    let opa = word.mask::<4, 7>();
                    if opb != 0 {
                        return Ok(Self::It(It::parse(iter)?));
                    }
                    Ok(
                        match opa {
                            0 => Self::Nop(Nop::parse(iter)?),
                            1 => Self::Yield(Yield::parse(iter)?),
                            2 => Self::Wfe(Wfe::parse(iter)?),
                            3 => Self::Wfi(Wfi::parse(iter)?),
                            4 => Self::Sev(Sev::parse(iter)?),
                            _ => return Err(ParseError::Invalid16Bit("A5_7")),
                        },
                    )
                }
            }
            impl ToOperation for A5_7 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::It(it) => {
                            operation::It::builder()
                                .set_conds((it.firstcond, it.mask).into())
                                .complete()
                                .into()
                        }
                        Self::Nop(_) => operation::Nop::builder().complete().into(),
                        Self::Yield(_) => operation::Yield::builder().complete().into(),
                        Self::Wfe(_) => operation::Wfe::builder().complete().into(),
                        Self::Wfi(_) => operation::Wfi::builder().complete().into(),
                        Self::Sev(_) => operation::Sev::builder().complete().into(),
                    }
                }
            }
        }
        pub mod a_5_8 {
            use paste::paste;
            use super::Mask;
            use crate::{
                arch::{wrapper_types::Imm8, Condition, Imm9, SignExtend},
                instruction, operation, Parse, ParseError, Stream, ToOperation,
            };
            pub enum A5_8 {
                B(B),
                Svc(Svc),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_8::B(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "B",
                                &__self_0,
                            )
                        }
                        A5_8::Svc(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Svc",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_8 {
                #[allow(dead_code)]
                pub(crate) fn parse_b<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::B(B::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_svc<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Svc(Svc::parse(iter)?))
                }
            }
            /**Instruction B from table A5_8

*/
            /**Contains the following fields:
*/
            /**- imm8 of type Imm8 from bit 0 to bit 7
*/
            /**- cond of type Condition from bit 8 to bit 11
*/
            pub struct B {
                /**bit 0 to 7

*/
                pub(crate) imm8: Imm8,
                /**bit 8 to 11

*/
                pub(crate) cond: Condition,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for B {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "B",
                        "imm8",
                        &self.imm8,
                        "cond",
                        &&self.cond,
                    )
                }
            }
            impl Parse for B {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("B")),
                    }?;
                    let imm8: Imm8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let cond: Condition = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, cond };
                    Ok(ret)
                }
            }
            /**Instruction Svc from table A5_8

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            pub struct Svc {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Svc {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Svc",
                        "imm8",
                        &&self.imm8,
                    )
                }
            }
            impl Parse for Svc {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Svc")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let ret = Self { imm8 };
                    Ok(ret)
                }
            }
            impl Parse for A5_8 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let opcode = match iter.peek::<1>() as Option<u8> {
                        Some(u) => Ok(u & 0b1111),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    if opcode == 0b1111 {
                        return Ok(Self::Svc(Svc::parse(iter)?));
                    }
                    if opcode == 0b1110 {
                        return Err(ParseError::Unpredictable);
                    }
                    Ok(Self::B(B::parse(iter)?))
                }
            }
            impl ToOperation for A5_8 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::B(el) => {
                            let intermediate: u16 = el.imm8.into();
                            let value: u32 = Imm9::try_from(intermediate << 1)
                                .expect("Imm9 is broken")
                                .sign_extend();
                            operation::B::builder()
                                .set_condition(el.cond)
                                .set_imm(value)
                                .complete()
                                .into()
                        }
                        Self::Svc(el) => {
                            operation::Svc::builder().set_imm(el.imm8).complete().into()
                        }
                    }
                }
            }
        }
        pub mod simply_defined {
            use paste::paste;
            use super::Mask;
            use crate::{
                arch::{Condition, Imm12, Register, RegisterList, SignExtend},
                instruction, operation, Parse, ParseError, ToOperation,
            };
            /**Instruction Ldr

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 8 to bit 10
*/
            pub struct Ldr {
                ///bit 0 to 7
                pub(crate) imm8: u8,
                ///bit 8 to 10
                pub(crate) rt: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Ldr",
                        "imm8",
                        &self.imm8,
                        "rt",
                        &&self.rt,
                    )
                }
            }
            impl Parse for Ldr {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldr")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    Ok(Self { imm8, rt })
                }
            }
            /**Instruction Adr

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 10
*/
            pub struct Adr {
                ///bit 0 to 7
                pub(crate) imm8: u8,
                ///bit 8 to 10
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Adr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Adr",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Adr {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Adr")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    Ok(Self { imm8, rd })
                }
            }
            /**Instruction Add

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 10
*/
            pub struct Add {
                ///bit 0 to 7
                pub(crate) imm8: u8,
                ///bit 8 to 10
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Add {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Add",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Add {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Add")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    Ok(Self { imm8, rd })
                }
            }
            /**Instruction Stm

*/
            /**Contains the following fields:
*/
            /**- register_list of type RegisterList from bit 0 to bit 7
*/
            /**- rn of type Register from bit 8 to bit 10
*/
            pub struct Stm {
                ///bit 0 to 7
                pub(crate) register_list: RegisterList,
                ///bit 8 to 10
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Stm {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Stm",
                        "register_list",
                        &self.register_list,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Stm {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Stm")),
                    }?;
                    let register_list: RegisterList = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>()).try_into().map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    Ok(Self { register_list, rn })
                }
            }
            /**Instruction Ldm

*/
            /**Contains the following fields:
*/
            /**- register_list of type RegisterList from bit 0 to bit 7
*/
            /**- rn of type Register from bit 8 to bit 10
*/
            pub struct Ldm {
                ///bit 0 to 7
                pub(crate) register_list: RegisterList,
                ///bit 8 to 10
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldm {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Ldm",
                        "register_list",
                        &self.register_list,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldm {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldm")),
                    }?;
                    let register_list: RegisterList = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 7>()).try_into().map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<8, 10>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    Ok(Self { register_list, rn })
                }
            }
            /**Instruction B

*/
            /**Contains the following fields:
*/
            /**- imm11 of type u16 from bit 0 to bit 10
*/
            pub struct B {
                ///bit 0 to 10
                pub(crate) imm11: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for B {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "B",
                        "imm11",
                        &&self.imm11,
                    )
                }
            }
            impl Parse for B {
                type Target = Self;
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("B")),
                    }?;
                    let imm11: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u16).mask::<0, 10>() as u16)
                    };
                    Ok(Self { imm11 })
                }
            }
            impl ToOperation for Ldr {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    operation::LdrLiteral::builder()
                        .set_imm((self.imm8 as u32) << 2)
                        .set_add(true)
                        .set_rt(self.rt)
                        .complete()
                        .into()
                }
            }
            impl ToOperation for Adr {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    operation::Adr::builder()
                        .set_imm((self.imm8 as u32) << 2)
                        .set_add(true)
                        .set_rd(self.rd)
                        .complete()
                        .into()
                }
            }
            impl ToOperation for Add {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    operation::AddSPImmediate::builder()
                        .set_imm((self.imm8 as u32) << 2)
                        .set_rd(Some(self.rd))
                        .set_s(Some(false))
                        .complete()
                        .into()
                }
            }
            impl ToOperation for Stm {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    operation::Stm::builder()
                        .set_w(Some(true))
                        .set_rn(self.rn)
                        .set_registers(self.register_list)
                        .complete()
                        .into()
                }
            }
            impl ToOperation for Ldm {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    operation::Ldm::builder()
                        .set_w(Some(!self.register_list.registers.contains(&self.rn)))
                        .set_rn(self.rn)
                        .set_registers(self.register_list)
                        .complete()
                        .into()
                }
            }
            impl ToOperation for B {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    let mut imm: Imm12 = ((self.imm11) << 1).try_into().unwrap();
                    operation::B::builder()
                        .set_condition(Condition::None)
                        .set_imm(imm.sign_extend())
                        .complete()
                        .into()
                }
            }
        }
        use super::Mask;
        use crate::{
            asm::b16::{
                a_5_2::A5_2, a_5_3::A5_3, a_5_4::A5_4, a_5_5::A5_5, a_5_6::A5_6,
                a_5_8::A5_8,
            },
            Parse, ParseError, ToOperation,
        };
        /// A 16-bit wide instruction
        pub enum B16 {}
        impl B16 {
            fn parse_internal<T: crate::Stream>(
                iter: &mut T,
            ) -> Result<crate::operation::Operation, crate::ParseError> {
                let word: Option<u16> = iter.peek::<1>();
                let opcode: u16 = (match word {
                    Some(val) => val,
                    None => return Err(ParseError::IncompleteProgram),
                })
                    .mask::<10, 15>();
                match opcode {
                    0b010000 => {
                        return Ok(A5_3::parse(iter)?.encoding_specific_operations());
                    }
                    0b010001 => {
                        return Ok(A5_4::parse(iter)?.encoding_specific_operations());
                    }
                    _ => {}
                };
                match opcode >> 1 {
                    0b01001 => {
                        return Ok(
                            simply_defined::Ldr::parse(iter)?
                                .encoding_specific_operations(),
                        );
                    }
                    0b10100 => {
                        return Ok(
                            simply_defined::Adr::parse(iter)?
                                .encoding_specific_operations(),
                        );
                    }
                    0b10101 => {
                        return Ok(
                            simply_defined::Add::parse(iter)?
                                .encoding_specific_operations(),
                        );
                    }
                    0b11000 => {
                        return Ok(
                            simply_defined::Stm::parse(iter)?
                                .encoding_specific_operations(),
                        );
                    }
                    0b11001 => {
                        return Ok(
                            simply_defined::Ldm::parse(iter)?
                                .encoding_specific_operations(),
                        );
                    }
                    0b11100 => {
                        return Ok(
                            simply_defined::B::parse(iter)?
                                .encoding_specific_operations(),
                        );
                    }
                    _ => {}
                };
                match opcode >> 2 {
                    0b0101 => {
                        return Ok(A5_5::parse(iter)?.encoding_specific_operations());
                    }
                    0b1011 => {
                        return Ok(A5_6::parse(iter)?.encoding_specific_operations());
                    }
                    0b1101 => {
                        return Ok(A5_8::parse(iter)?.encoding_specific_operations());
                    }
                    _ => {}
                };
                if opcode >> 3 == 0b011 || opcode >> 3 == 0b100 {
                    return Ok(A5_5::parse(iter)?.encoding_specific_operations());
                }
                if opcode >> 4 == 0 {
                    return Ok(A5_2::parse(iter)?.encoding_specific_operations());
                }
                Err(ParseError::Invalid16Bit("Half word"))
            }
        }
        impl Parse for B16 {
            type Target = (usize, crate::operation::Operation);
            fn parse<T: crate::Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
            where
                Self: Sized,
            {
                let ret = Self::parse_internal(iter)?;
                let _: u16 = match iter.consume::<1>() {
                    Some(val) => val[0],
                    None => return Err(ParseError::IncompleteProgram),
                };
                Ok((16, ret))
            }
        }
    }
    pub mod b32 {
        pub mod a5_10 {
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                combine, instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_10 {
                And(And),
                Tst(Tst),
                Bic(Bic),
                Orr(Orr),
                Mov(Mov),
                Orn(Orn),
                Mvn(Mvn),
                Eor(Eor),
                Teq(Teq),
                Add(Add),
                Cmn(Cmn),
                Adc(Adc),
                Sbc(Sbc),
                Sub(Sub),
                Cmp(Cmp),
                Rsb(Rsb),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_10 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_10::And(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "And",
                                &__self_0,
                            )
                        }
                        A5_10::Tst(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Tst",
                                &__self_0,
                            )
                        }
                        A5_10::Bic(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bic",
                                &__self_0,
                            )
                        }
                        A5_10::Orr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Orr",
                                &__self_0,
                            )
                        }
                        A5_10::Mov(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mov",
                                &__self_0,
                            )
                        }
                        A5_10::Orn(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Orn",
                                &__self_0,
                            )
                        }
                        A5_10::Mvn(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mvn",
                                &__self_0,
                            )
                        }
                        A5_10::Eor(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Eor",
                                &__self_0,
                            )
                        }
                        A5_10::Teq(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Teq",
                                &__self_0,
                            )
                        }
                        A5_10::Add(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Add",
                                &__self_0,
                            )
                        }
                        A5_10::Cmn(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cmn",
                                &__self_0,
                            )
                        }
                        A5_10::Adc(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Adc",
                                &__self_0,
                            )
                        }
                        A5_10::Sbc(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sbc",
                                &__self_0,
                            )
                        }
                        A5_10::Sub(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sub",
                                &__self_0,
                            )
                        }
                        A5_10::Cmp(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cmp",
                                &__self_0,
                            )
                        }
                        A5_10::Rsb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rsb",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_10 {
                #[allow(dead_code)]
                pub(crate) fn parse_and<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::And(And::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_tst<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Tst(Tst::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bic<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Bic(Bic::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_orr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Orr(Orr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mov<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mov(Mov::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_orn<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Orn(Orn::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mvn<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mvn(Mvn::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_eor<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Eor(Eor::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_teq<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Teq(Teq::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_add<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Add(Add::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cmn<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cmn(Cmn::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_adc<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Adc(Adc::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sbc<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sbc(Sbc::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sub<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sub(Sub::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cmp<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cmp(Cmp::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rsb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rsb(Rsb::parse(iter)?))
                }
            }
            /**Instruction And from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct And {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for And {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "And",
                        names,
                        values,
                    )
                }
            }
            impl Parse for And {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("And")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Tst from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Tst {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Tst {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Tst",
                        "imm8",
                        &self.imm8,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &self.rn,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Tst {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Tst")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, imm3, rn, i };
                    Ok(ret)
                }
            }
            /**Instruction Bic from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Bic {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Bic",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Bic {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Bic")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Orr from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Orr {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Orr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Orr",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Orr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Orr")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Mov from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Mov {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mov {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Mov",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "s",
                        &self.s,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Mov {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mov")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Orn from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Orn {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Orn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Orn",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Orn {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Orn")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Mvn from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Mvn {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mvn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Mvn",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "s",
                        &self.s,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Mvn {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mvn")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Eor from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Eor {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Eor {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Eor",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Eor {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Eor")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Teq from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Teq {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Teq {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Teq",
                        "imm8",
                        &self.imm8,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &self.rn,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Teq {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Teq")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, imm3, rn, i };
                    Ok(ret)
                }
            }
            /**Instruction Add from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Add {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Add {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Add",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Add {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Add")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Cmn from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Cmn {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cmn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Cmn",
                        "imm8",
                        &self.imm8,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &self.rn,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Cmn {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cmn")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, imm3, rn, i };
                    Ok(ret)
                }
            }
            /**Instruction Adc from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Adc {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Adc {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Adc",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Adc {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Adc")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Sbc from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Sbc {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sbc {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Sbc",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Sbc {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sbc")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Sub from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Sub {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sub {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Sub",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Sub {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sub")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            /**Instruction Cmp from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Cmp {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cmp {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Cmp",
                        "imm8",
                        &self.imm8,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &self.rn,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Cmp {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cmp")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, imm3, rn, i };
                    Ok(ret)
                }
            }
            /**Instruction Rsb from table A5_10

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Rsb {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rsb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "rd", "imm3", "rn", "s", "i"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &self.s,
                        &&self.i,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Rsb",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Rsb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rsb")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, s, i };
                    Ok(ret)
                }
            }
            impl Parse for A5_10 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let rd: u32 = (word.mask::<8, 11>());
                    let rn: u32 = (word.mask::<16, 19>());
                    let op: u32 = (word.mask::<21, 24>());
                    if op == 0 {
                        if rd != 0b1111 {
                            return Ok(Self::And(And::parse(iter)?));
                        }
                        return Ok(Self::Tst(Tst::parse(iter)?));
                    }
                    if op == 0b10 {
                        if rn != 0b1111 {
                            return Ok(Self::Orr(Orr::parse(iter)?));
                        }
                        return Ok(Self::Mov(Mov::parse(iter)?));
                    }
                    if op == 0b11 {
                        if rn != 0b1111 {
                            return Ok(Self::Orn(Orn::parse(iter)?));
                        }
                        return Ok(Self::Mvn(Mvn::parse(iter)?));
                    }
                    if op == 0b100 {
                        if rd != 0b1111 {
                            return Ok(Self::Eor(Eor::parse(iter)?));
                        }
                        return Ok(Self::Teq(Teq::parse(iter)?));
                    }
                    if op == 0b1000 {
                        if rd != 0b1111 {
                            return Ok(Self::Add(Add::parse(iter)?));
                        }
                        return Ok(Self::Cmn(Cmn::parse(iter)?));
                    }
                    if op == 0b1101 {
                        if rd != 0b1111 {
                            return Ok(Self::Sub(Sub::parse(iter)?));
                        }
                        return Ok(Self::Cmp(Cmp::parse(iter)?));
                    }
                    match op {
                        1 => Ok(Self::Bic(Bic::parse(iter)?)),
                        0b1010 => Ok(Self::Adc(Adc::parse(iter)?)),
                        0b1011 => Ok(Self::Sbc(Sbc::parse(iter)?)),
                        0b1110 => Ok(Self::Rsb(Rsb::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_10")),
                    }
                }
            }
            impl ToOperation for A5_10 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    use A5_10::*;
                    match self {
                        And(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let (imm, carry) = imm.expand_imm_c();
                            operation::AndImmediateBuilder::new()
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .set_rd(Some(el.rd))
                                .set_s(Some(el.s))
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Tst(el) => {
                            let imm = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: Imm12 = Imm12::try_into(imm).unwrap();
                            let (imm, carry) = imm.expand_imm_c();
                            operation::TstImmediateBuilder::new()
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Bic(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let (imm, carry) = imm.expand_imm_c();
                            operation::BicImmediateBuilder::new()
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .set_rd(Some(el.rd))
                                .set_s(Some(el.s))
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Orr(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let (imm, carry) = imm.expand_imm_c();
                            operation::OrrImmediateBuilder::new()
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .set_rd(Some(el.rd))
                                .set_s(Some(el.s))
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Mov(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let (imm, carry) = imm.expand_imm_c();
                            operation::MovImmediateBuilder::new()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_imm(imm)
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Orn(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let (imm, carry) = imm.expand_imm_c();
                            operation::OrnImmediateBuilder::new()
                                .set_s(Some(el.s))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Mvn(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let (imm, carry) = imm.expand_imm_c();
                            operation::MvnImmediateBuilder::new()
                                .set_s(Some(el.s))
                                .set_rd(el.rd)
                                .set_imm(imm)
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Eor(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let (imm, carry) = imm.expand_imm_c();
                            operation::EorImmediateBuilder::new()
                                .set_s(Some(el.s))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Teq(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let (imm, carry) = imm.expand_imm_c();
                            operation::TeqImmediateBuilder::new()
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .set_carry(carry)
                                .complete()
                                .into()
                        }
                        Add(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: u32 = imm.expand_imm();
                            operation::AddImmediateBuilder::new()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Cmn(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: u32 = imm.expand_imm();
                            operation::CmnImmediateBuilder::new()
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Adc(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: u32 = imm.expand_imm();
                            operation::AdcImmediateBuilder::new()
                                .set_s(Some(el.s))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Sbc(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: u32 = imm.expand_imm();
                            operation::SbcImmediateBuilder::new()
                                .set_s(Some(el.s))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Sub(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: u32 = imm.expand_imm();
                            operation::SubImmediateBuilder::new()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Cmp(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: u32 = imm.expand_imm();
                            operation::CmpImmediateBuilder::new()
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Rsb(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: u32 = imm.expand_imm();
                            operation::RsbImmediateBuilder::new()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_12 {
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                combine, instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_12 {
                Add(Add),
                Adr(Adr),
                Mov(Mov),
                Sub(Sub),
                Movt(Movt),
                Ssat(Ssat),
                Ssat16(Ssat16),
                Sbfx(Sbfx),
                Bfi(Bfi),
                Bfc(Bfc),
                Usat(Usat),
                Usat16(Usat16),
                Ubfx(Ubfx),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_12 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_12::Add(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Add",
                                &__self_0,
                            )
                        }
                        A5_12::Adr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Adr",
                                &__self_0,
                            )
                        }
                        A5_12::Mov(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mov",
                                &__self_0,
                            )
                        }
                        A5_12::Sub(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sub",
                                &__self_0,
                            )
                        }
                        A5_12::Movt(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Movt",
                                &__self_0,
                            )
                        }
                        A5_12::Ssat(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ssat",
                                &__self_0,
                            )
                        }
                        A5_12::Ssat16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ssat16",
                                &__self_0,
                            )
                        }
                        A5_12::Sbfx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sbfx",
                                &__self_0,
                            )
                        }
                        A5_12::Bfi(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bfi",
                                &__self_0,
                            )
                        }
                        A5_12::Bfc(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bfc",
                                &__self_0,
                            )
                        }
                        A5_12::Usat(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usat",
                                &__self_0,
                            )
                        }
                        A5_12::Usat16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usat16",
                                &__self_0,
                            )
                        }
                        A5_12::Ubfx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ubfx",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_12 {
                #[allow(dead_code)]
                pub(crate) fn parse_add<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Add(Add::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_adr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Adr(Adr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mov<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mov(Mov::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sub<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sub(Sub::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_movt<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Movt(Movt::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ssat<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ssat(Ssat::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ssat16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ssat16(Ssat16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sbfx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sbfx(Sbfx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bfi<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Bfi(Bfi::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bfc<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Bfc(Bfc::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_usat<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Usat(Usat::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_usat16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Usat16(Usat16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ubfx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ubfx(Ubfx::parse(iter)?))
                }
            }
            /**Instruction Add from table A5_12

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Add {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Add {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Add",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &self.rn,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Add {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Add")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, i };
                    Ok(ret)
                }
            }
            /**Instruction Adr from table A5_12

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            /**- add of type bool from bit 21 to bit 21
*/
            pub struct Adr {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
                /**bit 21 to 21

*/
                pub(crate) add: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Adr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Adr",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "i",
                        &self.i,
                        "add",
                        &&self.add,
                    )
                }
            }
            impl Parse for Adr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Adr")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let add: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rd, imm3, i, add };
                    Ok(ret)
                }
            }
            /**Instruction Mov from table A5_12

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- imm4 of type Register from bit 16 to bit 19
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Mov {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) imm4: Register,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mov {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Mov",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "imm4",
                        &self.imm4,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Mov {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mov")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let imm4: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, imm4, i };
                    Ok(ret)
                }
            }
            /**Instruction Sub from table A5_12

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Sub {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sub {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Sub",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &self.rn,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Sub {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sub")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, rn, i };
                    Ok(ret)
                }
            }
            /**Instruction Movt from table A5_12

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u16 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u16 from bit 12 to bit 14
*/
            /**- imm4 of type Register from bit 16 to bit 19
*/
            /**- i of type u16 from bit 26 to bit 26
*/
            pub struct Movt {
                /**bit 0 to 7

*/
                pub(crate) imm8: u16,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u16,
                /**bit 16 to 19

*/
                pub(crate) imm4: Register,
                /**bit 26 to 26

*/
                pub(crate) i: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Movt {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Movt",
                        "imm8",
                        &self.imm8,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "imm4",
                        &self.imm4,
                        "i",
                        &&self.i,
                    )
                }
            }
            impl Parse for Movt {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Movt")),
                    }?;
                    let imm8: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u16)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u16)
                    };
                    let imm4: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let i: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u16)
                    };
                    let ret = Self { imm8, rd, imm3, imm4, i };
                    Ok(ret)
                }
            }
            /**Instruction Ssat from table A5_12

*/
            /**Contains the following fields:
*/
            /**- sat_imm of type u8 from bit 0 to bit 4
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- sh of type u8 from bit 21 to bit 21
*/
            pub struct Ssat {
                /**bit 0 to 4

*/
                pub(crate) sat_imm: u8,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) sh: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ssat {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "sat_imm",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "sh",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sat_imm,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.sh,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Ssat",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Ssat {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ssat")),
                    }?;
                    let sat_imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let sh: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                    };
                    let ret = Self {
                        sat_imm,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        sh,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Ssat16 from table A5_12

*/
            /**Contains the following fields:
*/
            /**- sat_imm of type u8 from bit 0 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ssat16 {
                /**bit 0 to 4

*/
                pub(crate) sat_imm: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ssat16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ssat16",
                        "sat_imm",
                        &self.sat_imm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ssat16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ssat16")),
                    }?;
                    let sat_imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { sat_imm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Sbfx from table A5_12

*/
            /**Contains the following fields:
*/
            /**- widthm1 of type u8 from bit 0 to bit 4
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sbfx {
                /**bit 0 to 4

*/
                pub(crate) widthm1: u8,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sbfx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Sbfx",
                        "widthm1",
                        &self.widthm1,
                        "imm2",
                        &self.imm2,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sbfx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sbfx")),
                    }?;
                    let widthm1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        widthm1,
                        imm2,
                        rd,
                        imm3,
                        rn,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Bfi from table A5_12

*/
            /**Contains the following fields:
*/
            /**- msb of type u8 from bit 0 to bit 4
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Bfi {
                /**bit 0 to 4

*/
                pub(crate) msb: u8,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bfi {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Bfi",
                        "msb",
                        &self.msb,
                        "imm2",
                        &self.imm2,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Bfi {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Bfi")),
                    }?;
                    let msb: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { msb, imm2, rd, imm3, rn };
                    Ok(ret)
                }
            }
            /**Instruction Bfc from table A5_12

*/
            /**Contains the following fields:
*/
            /**- msb of type u8 from bit 0 to bit 4
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            pub struct Bfc {
                /**bit 0 to 4

*/
                pub(crate) msb: u8,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bfc {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Bfc",
                        "msb",
                        &self.msb,
                        "imm2",
                        &self.imm2,
                        "rd",
                        &self.rd,
                        "imm3",
                        &&self.imm3,
                    )
                }
            }
            impl Parse for Bfc {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Bfc")),
                    }?;
                    let msb: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let ret = Self { msb, imm2, rd, imm3 };
                    Ok(ret)
                }
            }
            /**Instruction Usat from table A5_12

*/
            /**Contains the following fields:
*/
            /**- sat_imm of type u8 from bit 0 to bit 4
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- sh of type u8 from bit 21 to bit 21
*/
            pub struct Usat {
                /**bit 0 to 4

*/
                pub(crate) sat_imm: u8,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) sh: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Usat {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "sat_imm",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "sh",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sat_imm,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.sh,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Usat",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Usat {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Usat")),
                    }?;
                    let sat_imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let sh: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                    };
                    let ret = Self {
                        sat_imm,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        sh,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Usat16 from table A5_12

*/
            /**Contains the following fields:
*/
            /**- sat_imm of type u8 from bit 0 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Usat16 {
                /**bit 0 to 4

*/
                pub(crate) sat_imm: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Usat16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Usat16",
                        "sat_imm",
                        &self.sat_imm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Usat16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Usat16")),
                    }?;
                    let sat_imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { sat_imm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ubfx from table A5_12

*/
            /**Contains the following fields:
*/
            /**- widthm1 of type u8 from bit 0 to bit 4
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ubfx {
                /**bit 0 to 4

*/
                pub(crate) widthm1: u8,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ubfx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Ubfx",
                        "widthm1",
                        &self.widthm1,
                        "imm2",
                        &self.imm2,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ubfx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ubfx")),
                    }?;
                    let widthm1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        widthm1,
                        imm2,
                        rd,
                        imm3,
                        rn,
                    };
                    Ok(ret)
                }
            }
            impl Parse for A5_12 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let _word: u32 = match iter.peek::<1>() {
                        Some(word) => word,
                        _ => {
                            #[cold]
                            #[track_caller]
                            #[inline(never)]
                            const fn panic_cold_explicit() -> ! {
                                ::core::panicking::panic_explicit()
                            }
                            panic_cold_explicit();
                        }
                    };
                    let word: u16 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let rn = word.mask::<0, 3>();
                    let op = word.mask::<4, 8>();
                    let word: u16 = match iter.peek::<2>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let second_halfword_req = word.mask::<6, 7>() == 0
                        && word.mask::<12, 14>() == 0;
                    match (op, rn, second_halfword_req) {
                        (0, 0b1111, _) => Ok(Self::Adr(Adr::parse(iter)?)),
                        (0, _, _) => Ok(Self::Add(Add::parse(iter)?)),
                        (0b00100, _, _) => Ok(Self::Mov(Mov::parse(iter)?)),
                        (0b01010, 0b1111, _) => Ok(Self::Adr(Adr::parse(iter)?)),
                        (0b01010, _, _) => Ok(Self::Sub(Sub::parse(iter)?)),
                        (0b01100, _, _) => Ok(Self::Movt(Movt::parse(iter)?)),
                        (0b10000, _, _) | (0b10010, _, false) => {
                            Ok(Self::Ssat(Ssat::parse(iter)?))
                        }
                        (0b10010, _, true) => Ok(Self::Ssat16(Ssat16::parse(iter)?)),
                        (0b10100, _, _) => Ok(Self::Sbfx(Sbfx::parse(iter)?)),
                        (0b10110, 0b1111, _) => Ok(Self::Bfc(Bfc::parse(iter)?)),
                        (0b10110, _, _) => Ok(Self::Bfi(Bfi::parse(iter)?)),
                        (0b11000, _, _) | (0b11010, _, false) => {
                            Ok(Self::Usat(Usat::parse(iter)?))
                        }
                        (0b11010, _, true) => Ok(Self::Usat16(Usat16::parse(iter)?)),
                        (0b11100, _, _) => Ok(Self::Ubfx(Ubfx::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_12")),
                    }
                }
            }
            impl ToOperation for A5_12 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Add(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            operation::AddImmediateBuilder::new()
                                .set_s(Some(false.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm.into())
                                .complete()
                                .into()
                        }
                        Self::Adr(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            operation::AdrBuilder::new()
                                .set_rd(el.rd)
                                .set_add(!el.add)
                                .set_imm(imm.into())
                                .complete()
                                .into()
                        }
                        Self::Mov(el) => {
                            let imm: u32 = {
                                let imm4 = el.imm4;
                                let (i, imm3, imm8) = (el.i, el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 1 + 3 + 8 + 0 };
                                    let mut sum: u32 = (imm4 as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 1;
                                        sum |= ((i as u32) << counter) as u32;
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            operation::MovImmediateBuilder::new()
                                .set_s(Some(false.into()))
                                .set_rd(el.rd)
                                .set_imm(imm)
                                .set_carry(None)
                                .complete()
                                .into()
                        }
                        Self::Sub(el) => {
                            let imm: Imm12 = {
                                let i = el.i;
                                let (imm3, imm8) = (el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 3 + 8 + 0 };
                                    let mut sum: u32 = (i as u32) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 3;
                                        sum |= ((imm3 as u32) << counter) as u32;
                                        counter -= 8;
                                        sum |= ((imm8 as u32) << counter) as u32;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            let imm: u32 = imm.into();
                            operation::SubImmediateBuilder::new()
                                .set_s(Some(false.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Self::Movt(el) => {
                            let imm: u16 = {
                                let imm4 = el.imm4;
                                let (i, imm3, imm8) = (el.i, el.imm3, el.imm8);
                                match {
                                    let mut counter: usize = { 1 + 3 + 8 + 0 };
                                    let mut sum: u16 = (imm4 as u16) << counter;
                                    #[allow(unused_assignments)]
                                    {
                                        counter -= 1;
                                        sum |= ((i as u16) << counter) as u16;
                                        counter -= 3;
                                        sum |= ((imm3 as u16) << counter) as u16;
                                        counter -= 8;
                                        sum |= ((imm8 as u16) << counter) as u16;
                                    }
                                    sum
                                }
                                    .try_into()
                                {
                                    Ok(w) => w,
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("This should never happen"),
                                            ),
                                        );
                                    }
                                }
                            };
                            operation::MovtBuilder::new()
                                .set_rd(el.rd)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Self::Ssat(el) => {
                            let (imm3, imm2, sh) = (el.imm3, el.imm2, el.sh << 1);
                            let shift_n: u8 = {
                                let mut counter: usize = { 2 + 0 };
                                let mut sum: u8 = (imm3 as u8) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 2;
                                    sum |= ((imm2 as u8) << counter) as u8;
                                }
                                sum
                            };
                            let shift: Shift = sh.try_into().unwrap();
                            let shift = ImmShift::from((shift, shift_n));
                            operation::SsatBuilder::new()
                                .set_rd(el.rd)
                                .set_imm(el.sat_imm as u32 + 1)
                                .set_rn(el.rn)
                                .set_shift(Some(shift))
                                .complete()
                                .into()
                        }
                        Self::Bfi(el) => {
                            let (msb, imm3, imm2) = (el.msb, el.imm3, el.imm2);
                            let lsb = {
                                let mut counter: usize = { 2 + 0 };
                                let mut sum: u32 = (imm3 as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 2;
                                    sum |= ((imm2 as u32) << counter) as u32;
                                }
                                sum
                            };
                            operation::BfiBuilder::new()
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_lsb(lsb)
                                .set_msb(msb as u32)
                                .complete()
                                .into()
                        }
                        Self::Bfc(el) => {
                            let (msb, imm3, imm2) = (el.msb, el.imm3, el.imm2);
                            let lsb = {
                                let mut counter: usize = { 2 + 0 };
                                let mut sum: u32 = (imm3 as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 2;
                                    sum |= ((imm2 as u32) << counter) as u32;
                                }
                                sum
                            };
                            operation::BfcBuilder::new()
                                .set_rd(el.rd)
                                .set_lsb(lsb)
                                .set_msb(msb as u32)
                                .complete()
                                .into()
                        }
                        Self::Usat(el) => {
                            let (imm3, imm2, sh) = (el.imm3, el.imm2, el.sh << 1);
                            let shift_n: u8 = {
                                let mut counter: usize = { 2 + 0 };
                                let mut sum: u8 = (imm3 as u8) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 2;
                                    sum |= ((imm2 as u8) << counter) as u8;
                                }
                                sum
                            };
                            let shift: Shift = sh.try_into().unwrap();
                            let shift = ImmShift::from((shift, shift_n));
                            operation::UsatBuilder::new()
                                .set_rd(el.rd)
                                .set_imm(el.sat_imm as u32)
                                .set_rn(el.rn)
                                .set_shift(Some(shift))
                                .complete()
                                .into()
                        }
                        Self::Sbfx(el) => {
                            let (imm3, imm2) = (el.imm3, el.imm2);
                            let lsbit = {
                                let mut counter: usize = { 2 + 0 };
                                let mut sum: u8 = (imm3 as u8) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 2;
                                    sum |= ((imm2 as u8) << counter) as u8;
                                }
                                sum
                            };
                            operation::SbfxBuilder::new()
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_lsb(lsbit as u32)
                                .set_width(el.widthm1 as u32 + 1)
                                .complete()
                                .into()
                        }
                        Self::Ubfx(el) => {
                            let (imm3, imm2) = (el.imm3, el.imm2);
                            let lsbit = {
                                let mut counter: usize = { 2 + 0 };
                                let mut sum: u8 = (imm3 as u8) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 2;
                                    sum |= ((imm2 as u8) << counter) as u8;
                                }
                                sum
                            };
                            operation::UbfxBuilder::new()
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_lsb(lsbit as u32)
                                .set_width(el.widthm1 as u32 + 1)
                                .complete()
                                .into()
                        }
                        Self::Ssat16(el) => {
                            let saturate_to = el.sat_imm + 1;
                            operation::Ssat16Builder::new()
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_imm(saturate_to as u32)
                                .complete()
                                .into()
                        }
                        Self::Usat16(el) => {
                            let saturate_to = el.sat_imm;
                            operation::Usat16Builder::new()
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_imm(saturate_to as u32)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_13 {
            use paste::paste;
            use crate::{
                asm::{
                    b32::{a5_14::A5_14, a5_15::A5_15},
                    LocalTryInto, Mask,
                },
                combine, instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_13 {
                BT3(BT3),
                Msr(Msr),
                ///Externally defined instruction or set of instructions [`A5_14`]
                SubtableA5_14(A5_14),
                ///Externally defined instruction or set of instructions [`A5_15`]
                SubtableA5_15(A5_15),
                Mrs(Mrs),
                Udf(Udf),
                BT4(BT4),
                Bl(Bl),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_13 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_13::BT3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "BT3",
                                &__self_0,
                            )
                        }
                        A5_13::Msr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Msr",
                                &__self_0,
                            )
                        }
                        A5_13::SubtableA5_14(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubtableA5_14",
                                &__self_0,
                            )
                        }
                        A5_13::SubtableA5_15(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubtableA5_15",
                                &__self_0,
                            )
                        }
                        A5_13::Mrs(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mrs",
                                &__self_0,
                            )
                        }
                        A5_13::Udf(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Udf",
                                &__self_0,
                            )
                        }
                        A5_13::BT4(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "BT4",
                                &__self_0,
                            )
                        }
                        A5_13::Bl(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bl",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_13 {
                #[allow(dead_code)]
                pub(crate) fn parse_bt3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::BT3(BT3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_msr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Msr(Msr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mrs<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mrs(Mrs::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_udf<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Udf(Udf::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bt4<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::BT4(BT4::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bl<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Bl(Bl::parse(iter)?))
                }
            }
            /**Instruction BT3 from table A5_13

*/
            /**Contains the following fields:
*/
            /**- imm11 of type u16 from bit 0 to bit 10
*/
            /**- j2 of type bool from bit 11 to bit 11
*/
            /**- j1 of type bool from bit 13 to bit 13
*/
            /**- imm6 of type u16 from bit 16 to bit 21
*/
            /**- cond of type Condition from bit 22 to bit 25
*/
            /**- s of type bool from bit 26 to bit 26
*/
            pub struct BT3 {
                /**bit 0 to 10

*/
                pub(crate) imm11: u16,
                /**bit 11 to 11

*/
                pub(crate) j2: bool,
                /**bit 13 to 13

*/
                pub(crate) j1: bool,
                /**bit 16 to 21

*/
                pub(crate) imm6: u16,
                /**bit 22 to 25

*/
                pub(crate) cond: Condition,
                /**bit 26 to 26

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for BT3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm11", "j2", "j1", "imm6", "cond", "s"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm11,
                        &self.j2,
                        &self.j1,
                        &self.imm6,
                        &self.cond,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "BT3",
                        names,
                        values,
                    )
                }
            }
            impl Parse for BT3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("BT3")),
                    }?;
                    let imm11: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 10>() as u16)
                    };
                    let j2: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<11, 11>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let j1: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<13, 13>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm6: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 21>() as u16)
                    };
                    let cond: Condition = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 25>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        imm11,
                        j2,
                        j1,
                        imm6,
                        cond,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Msr from table A5_13

*/
            /**Contains the following fields:
*/
            /**- sysm of type u8 from bit 0 to bit 7
*/
            /**- mask of type Imm2 from bit 10 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Msr {
                /**bit 0 to 7

*/
                pub(crate) sysm: u8,
                /**bit 10 to 11

*/
                pub(crate) mask: Imm2,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Msr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Msr",
                        "sysm",
                        &self.sysm,
                        "mask",
                        &self.mask,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Msr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Msr")),
                    }?;
                    let sysm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let mask: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { sysm, mask, rn };
                    Ok(ret)
                }
            }
            /**Instruction Mrs from table A5_13

*/
            /**Contains the following fields:
*/
            /**- sysm of type u8 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Mrs {
                /**bit 0 to 7

*/
                pub(crate) sysm: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mrs {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Mrs",
                        "sysm",
                        &self.sysm,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Mrs {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mrs")),
                    }?;
                    let sysm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { sysm, rd };
                    Ok(ret)
                }
            }
            /**Instruction Udf from table A5_13

*/
            /**Contains the following fields:
*/
            /**- imm12 of type u16 from bit 0 to bit 11
*/
            /**- imm4 of type u16 from bit 0 to bit 3
*/
            pub struct Udf {
                /**bit 0 to 11

*/
                pub(crate) imm12: u16,
                /**bit 0 to 3

*/
                pub(crate) imm4: u16,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Udf {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Udf",
                        "imm12",
                        &self.imm12,
                        "imm4",
                        &&self.imm4,
                    )
                }
            }
            impl Parse for Udf {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Udf")),
                    }?;
                    let imm12: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                    };
                    let imm4: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u16)
                    };
                    let ret = Self { imm12, imm4 };
                    Ok(ret)
                }
            }
            /**Instruction BT4 from table A5_13

*/
            /**Contains the following fields:
*/
            /**- imm11 of type u32 from bit 0 to bit 10
*/
            /**- j2 of type bool from bit 11 to bit 11
*/
            /**- j1 of type bool from bit 13 to bit 13
*/
            /**- imm10 of type u32 from bit 16 to bit 25
*/
            /**- s of type bool from bit 26 to bit 26
*/
            pub struct BT4 {
                /**bit 0 to 10

*/
                pub(crate) imm11: u32,
                /**bit 11 to 11

*/
                pub(crate) j2: bool,
                /**bit 13 to 13

*/
                pub(crate) j1: bool,
                /**bit 16 to 25

*/
                pub(crate) imm10: u32,
                /**bit 26 to 26

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for BT4 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "BT4",
                        "imm11",
                        &self.imm11,
                        "j2",
                        &self.j2,
                        "j1",
                        &self.j1,
                        "imm10",
                        &self.imm10,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for BT4 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("BT4")),
                    }?;
                    let imm11: u32 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 10>())
                    };
                    let j2: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<11, 11>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let j1: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<13, 13>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm10: u32 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 25>())
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm11, j2, j1, imm10, s };
                    Ok(ret)
                }
            }
            /**Instruction Bl from table A5_13

*/
            /**Contains the following fields:
*/
            /**- imm11 of type u32 from bit 0 to bit 10
*/
            /**- j2 of type bool from bit 11 to bit 11
*/
            /**- j1 of type bool from bit 13 to bit 13
*/
            /**- imm10 of type u32 from bit 16 to bit 25
*/
            /**- s of type bool from bit 26 to bit 26
*/
            pub struct Bl {
                /**bit 0 to 10

*/
                pub(crate) imm11: u32,
                /**bit 11 to 11

*/
                pub(crate) j2: bool,
                /**bit 13 to 13

*/
                pub(crate) j1: bool,
                /**bit 16 to 25

*/
                pub(crate) imm10: u32,
                /**bit 26 to 26

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bl {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Bl",
                        "imm11",
                        &self.imm11,
                        "j2",
                        &self.j2,
                        "j1",
                        &self.j1,
                        "imm10",
                        &self.imm10,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Bl {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Bl")),
                    }?;
                    let imm11: u32 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 10>())
                    };
                    let j2: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<11, 11>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let j1: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<13, 13>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm10: u32 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 25>())
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<26, 26>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm11, j2, j1, imm10, s };
                    Ok(ret)
                }
            }
            impl Parse for A5_13 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op1 = word.mask::<12, 14>();
                    let op = word.mask::<20, 26>();
                    if op1 & 0b101 == 0 {
                        if (op >> 3) & 0b111 != 0b111 {
                            return Ok(Self::BT3(BT3::parse(iter)?));
                        }
                        if op >> 1 == 0b11100 {
                            return Ok(Self::Msr(Msr::parse(iter)?));
                        }
                        if op >> 1 == 0b011111 {
                            return Ok(Self::Mrs(Mrs::parse(iter)?));
                        }
                        if op == 0b0111010 {
                            return Ok(Self::SubtableA5_14(A5_14::parse(iter)?));
                        }
                        if op == 0b0111011 {
                            return Ok(Self::SubtableA5_15(A5_15::parse(iter)?));
                        }
                    }
                    if op1 == 0b10 {
                        return Ok(Self::Udf(Udf::parse(iter)?));
                    }
                    if op1 & 0b101 == 0b001 {
                        return Ok(Self::BT4(BT4::parse(iter)?));
                    }
                    if op1 & 0b101 == 0b101 {
                        return Ok(Self::Bl(Bl::parse(iter)?));
                    }
                    Err(ParseError::Invalid32Bit("A5_13"))
                }
            }
            impl ToOperation for A5_13 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::BT3(el) => {
                            let (s, j2, j1, imm6, imm11) = (
                                el.s,
                                el.j2,
                                el.j1,
                                el.imm6,
                                el.imm11,
                            );
                            let mut imm: Imm21 = {
                                let mut counter: usize = { 1 + 1 + 6 + 11 + 1 + 0 };
                                let mut sum: u32 = (s as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((j2 as u32) << counter) as u32;
                                    counter -= 1;
                                    sum |= ((j1 as u32) << counter) as u32;
                                    counter -= 6;
                                    sum |= ((imm6 as u32) << counter) as u32;
                                    counter -= 11;
                                    sum |= ((imm11 as u32) << counter) as u32;
                                    counter -= 1;
                                    sum |= ((0 as u32) << counter) as u32;
                                }
                                sum
                            }
                                .try_into()
                                .unwrap();
                            operation::BBuilder::new()
                                .set_condition(el.cond)
                                .set_imm(imm.sign_extend())
                                .complete()
                                .into()
                        }
                        Self::BT4(el) => {
                            let (s, j2, j1, imm10, imm11) = (
                                el.s,
                                el.j2,
                                el.j1,
                                el.imm10,
                                el.imm11,
                            );
                            let i1 = !(j1 ^ s);
                            let i2 = !(j2 ^ s);
                            let mut imm: Imm25 = {
                                let mut counter: usize = { 1 + 1 + 10 + 11 + 1 + 0 };
                                let mut sum: u32 = (s as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((i1 as u32) << counter) as u32;
                                    counter -= 1;
                                    sum |= ((i2 as u32) << counter) as u32;
                                    counter -= 10;
                                    sum |= ((imm10 as u32) << counter) as u32;
                                    counter -= 11;
                                    sum |= ((imm11 as u32) << counter) as u32;
                                    counter -= 1;
                                    sum |= ((0 as u32) << counter) as u32;
                                }
                                sum
                            }
                                .try_into()
                                .unwrap();
                            operation::BBuilder::new()
                                .set_condition(Condition::None)
                                .set_imm(imm.sign_extend())
                                .complete()
                                .into()
                        }
                        Self::Msr(el) => {
                            operation::Msr::builder()
                                .set_rn(el.rn)
                                .set_mask(el.mask)
                                .set_sysm(el.sysm)
                                .complete()
                                .into()
                        }
                        Self::Mrs(el) => {
                            operation::Mrs::builder()
                                .set_rd(el.rd)
                                .set_sysm(el.sysm)
                                .complete()
                                .into()
                        }
                        Self::Bl(el) => {
                            let (s, j2, j1, imm10, imm11) = (
                                el.s,
                                el.j2,
                                el.j1,
                                el.imm10,
                                el.imm11,
                            );
                            let (i1, i2) = (!(j1 ^ s), !(j2 ^ s));
                            let num = {
                                let mut counter: usize = { 1 + 1 + 10 + 11 + 1 + 0 };
                                let mut sum: u32 = (s as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((i1 as u32) << counter) as u32;
                                    counter -= 1;
                                    sum |= ((i2 as u32) << counter) as u32;
                                    counter -= 10;
                                    sum |= ((imm10 as u32) << counter) as u32;
                                    counter -= 11;
                                    sum |= ((imm11 as u32) << counter) as u32;
                                    counter -= 1;
                                    sum |= ((0 as u32) << counter) as u32;
                                }
                                sum
                            };
                            let mut imm: Imm25 = num
                                .try_into()
                                .map_err(|e| {
                                    {
                                        ::std::io::_print(
                                            format_args!("tried to fit {0} into Imm25\n", num),
                                        );
                                    };
                                    e
                                })
                                .unwrap();
                            operation::BlBuilder::new()
                                .set_imm(imm.sign_extend())
                                .complete()
                                .into()
                        }
                        Self::SubtableA5_14(table) => {
                            table.encoding_specific_operations()
                        }
                        Self::SubtableA5_15(table) => {
                            table.encoding_specific_operations()
                        }
                        Self::Udf(udf) => {
                            let (imm4, imm12) = (udf.imm4, udf.imm12);
                            let imm = {
                                let mut counter: usize = { 12 + 0 };
                                let mut sum: u32 = (imm4 as u32) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 12;
                                    sum |= ((imm12 as u32) << counter) as u32;
                                }
                                sum
                            };
                            operation::UdfBuilder::new().set_imm(imm).complete().into()
                        }
                    }
                }
            }
        }
        pub mod a5_14 {
            //! Defines marker instructions
            //!
            //! These have one or no fields but might have side-effects
            use crate::{asm::Mask, prelude::*, ParseError, ToOperation};
            /// Defines some maker instructions
            pub enum A5_14 {
                /// No operation
                Nop,
                /// Yield
                Yield,
                /// Wait for event
                Wfe,
                /// Wait for interrupt
                Wfi,
                /// Send event
                Sev,
                /// Debug
                Dbg(u8),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_14 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_14::Nop => ::core::fmt::Formatter::write_str(f, "Nop"),
                        A5_14::Yield => ::core::fmt::Formatter::write_str(f, "Yield"),
                        A5_14::Wfe => ::core::fmt::Formatter::write_str(f, "Wfe"),
                        A5_14::Wfi => ::core::fmt::Formatter::write_str(f, "Wfi"),
                        A5_14::Sev => ::core::fmt::Formatter::write_str(f, "Sev"),
                        A5_14::Dbg(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Dbg",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl Parse for A5_14 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<2>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op1 = word.mask::<8, 10>();
                    let op2 = word.mask::<0, 8>();
                    if op1 != 0 {
                        return Err(ParseError::Undefined);
                    }
                    match op2 {
                        0 => return Ok(Self::Nop),
                        1 => return Ok(Self::Yield),
                        2 => return Ok(Self::Wfe),
                        3 => return Ok(Self::Wfi),
                        4 => return Ok(Self::Sev),
                        _ => {}
                    }
                    if op2 >> 4 == 0b1111 {
                        let option: u8 = (op2 & 0b1111) as u8;
                        return Ok(Self::Dbg(option));
                    }
                    Err(ParseError::Invalid32Bit("A5_14"))
                }
            }
            impl ToOperation for A5_14 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Nop => operation::NopBuilder::new().complete().into(),
                        Self::Yield => operation::YieldBuilder::new().complete().into(),
                        Self::Wfe => operation::WfeBuilder::new().complete().into(),
                        Self::Wfi => operation::WfiBuilder::new().complete().into(),
                        Self::Sev => operation::SevBuilder::new().complete().into(),
                        Self::Dbg(el) => {
                            operation::DbgBuilder::new().set_option(el).complete().into()
                        }
                    }
                }
            }
        }
        pub mod a5_15 {
            use crate::{asm::Mask, prelude::*, ParseError, ToOperation};
            /// Defines some maker instructions
            pub enum A5_15 {
                /// Clear exclusive
                Clrex,
                /// Data synchronization barrier
                Dsb(u8),
                /// Data memory barrier
                Dmb(u8),
                /// Instruction synchronization barrier
                Isb(u8),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_15 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_15::Clrex => ::core::fmt::Formatter::write_str(f, "Clrex"),
                        A5_15::Dsb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Dsb",
                                &__self_0,
                            )
                        }
                        A5_15::Dmb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Dmb",
                                &__self_0,
                            )
                        }
                        A5_15::Isb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Isb",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl Parse for A5_15 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u16 = match iter.peek::<2>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op = word.mask::<4, 7>();
                    let inner_op = word.mask::<0, 3>() as u8;
                    match op {
                        0b10 => Ok(Self::Clrex),
                        0b100 => Ok(Self::Dsb(inner_op)),
                        0b101 => Ok(Self::Dmb(inner_op)),
                        0b110 => Ok(Self::Isb(inner_op)),
                        _ => Err(ParseError::Invalid32Bit("A5_14")),
                    }
                }
            }
            impl ToOperation for A5_15 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Clrex => operation::ClrexBuilder::new().complete().into(),
                        Self::Dsb(opt) => {
                            operation::DsbBuilder::new()
                                .set_option(Some(opt))
                                .complete()
                                .into()
                        }
                        Self::Dmb(opt) => {
                            operation::DmbBuilder::new()
                                .set_option(Some(opt))
                                .complete()
                                .into()
                        }
                        Self::Isb(opt) => {
                            operation::IsbBuilder::new()
                                .set_option(Some(opt.try_into().unwrap()))
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_16 {
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                combine, instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_16 {
                Stm(Stm),
                Ldm(Ldm),
                Pop(Pop),
                Stmdb(Stmdb),
                Push(Push),
                Ldmdb(Ldmdb),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_16::Stm(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Stm",
                                &__self_0,
                            )
                        }
                        A5_16::Ldm(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldm",
                                &__self_0,
                            )
                        }
                        A5_16::Pop(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Pop",
                                &__self_0,
                            )
                        }
                        A5_16::Stmdb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Stmdb",
                                &__self_0,
                            )
                        }
                        A5_16::Push(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Push",
                                &__self_0,
                            )
                        }
                        A5_16::Ldmdb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldmdb",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_16 {
                #[allow(dead_code)]
                pub(crate) fn parse_stm<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Stm(Stm::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldm<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldm(Ldm::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pop<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Pop(Pop::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_stmdb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Stmdb(Stmdb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_push<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Push(Push::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldmdb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldmdb(Ldmdb::parse(iter)?))
                }
            }
            /**Instruction Stm from table A5_16

*/
            /**Contains the following fields:
*/
            /**- register_list of type u16 from bit 0 to bit 12
*/
            /**- m of type bool from bit 14 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            pub struct Stm {
                /**bit 0 to 12

*/
                pub(crate) register_list: u16,
                /**bit 14 to 14

*/
                pub(crate) m: bool,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Stm {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Stm",
                        "register_list",
                        &self.register_list,
                        "m",
                        &self.m,
                        "rn",
                        &self.rn,
                        "w",
                        &&self.w,
                    )
                }
            }
            impl Parse for Stm {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Stm")),
                    }?;
                    let register_list: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 12>() as u16)
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<14, 14>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { register_list, m, rn, w };
                    Ok(ret)
                }
            }
            /**Instruction Ldm from table A5_16

*/
            /**Contains the following fields:
*/
            /**- register_list of type u16 from bit 0 to bit 12
*/
            /**- m of type bool from bit 14 to bit 14
*/
            /**- p of type bool from bit 15 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            pub struct Ldm {
                /**bit 0 to 12

*/
                pub(crate) register_list: u16,
                /**bit 14 to 14

*/
                pub(crate) m: bool,
                /**bit 15 to 15

*/
                pub(crate) p: bool,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldm {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Ldm",
                        "register_list",
                        &self.register_list,
                        "m",
                        &self.m,
                        "p",
                        &self.p,
                        "rn",
                        &self.rn,
                        "w",
                        &&self.w,
                    )
                }
            }
            impl Parse for Ldm {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldm")),
                    }?;
                    let register_list: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 12>() as u16)
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<14, 14>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<15, 15>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { register_list, m, p, rn, w };
                    Ok(ret)
                }
            }
            /**Instruction Pop from table A5_16

*/
            /**Contains the following fields:
*/
            /**- register_list of type u16 from bit 0 to bit 12
*/
            /**- m of type bool from bit 14 to bit 14
*/
            /**- p of type bool from bit 15 to bit 15
*/
            pub struct Pop {
                /**bit 0 to 12

*/
                pub(crate) register_list: u16,
                /**bit 14 to 14

*/
                pub(crate) m: bool,
                /**bit 15 to 15

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Pop {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Pop",
                        "register_list",
                        &self.register_list,
                        "m",
                        &self.m,
                        "p",
                        &&self.p,
                    )
                }
            }
            impl Parse for Pop {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Pop")),
                    }?;
                    let register_list: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 12>() as u16)
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<14, 14>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<15, 15>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { register_list, m, p };
                    Ok(ret)
                }
            }
            /**Instruction Stmdb from table A5_16

*/
            /**Contains the following fields:
*/
            /**- register_list of type u16 from bit 0 to bit 12
*/
            /**- m of type bool from bit 14 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            pub struct Stmdb {
                /**bit 0 to 12

*/
                pub(crate) register_list: u16,
                /**bit 14 to 14

*/
                pub(crate) m: bool,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Stmdb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Stmdb",
                        "register_list",
                        &self.register_list,
                        "m",
                        &self.m,
                        "rn",
                        &self.rn,
                        "w",
                        &&self.w,
                    )
                }
            }
            impl Parse for Stmdb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Stmdb")),
                    }?;
                    let register_list: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 12>() as u16)
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<14, 14>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { register_list, m, rn, w };
                    Ok(ret)
                }
            }
            /**Instruction Push from table A5_16

*/
            /**Contains the following fields:
*/
            /**- register_list of type u16 from bit 0 to bit 12
*/
            /**- m of type bool from bit 14 to bit 14
*/
            pub struct Push {
                /**bit 0 to 12

*/
                pub(crate) register_list: u16,
                /**bit 14 to 14

*/
                pub(crate) m: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Push {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Push",
                        "register_list",
                        &self.register_list,
                        "m",
                        &&self.m,
                    )
                }
            }
            impl Parse for Push {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Push")),
                    }?;
                    let register_list: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 12>() as u16)
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<14, 14>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { register_list, m };
                    Ok(ret)
                }
            }
            /**Instruction Ldmdb from table A5_16

*/
            /**Contains the following fields:
*/
            /**- register_list of type u16 from bit 0 to bit 12
*/
            /**- m of type bool from bit 14 to bit 14
*/
            /**- p of type bool from bit 15 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            pub struct Ldmdb {
                /**bit 0 to 12

*/
                pub(crate) register_list: u16,
                /**bit 14 to 14

*/
                pub(crate) m: bool,
                /**bit 15 to 15

*/
                pub(crate) p: bool,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldmdb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Ldmdb",
                        "register_list",
                        &self.register_list,
                        "m",
                        &self.m,
                        "p",
                        &self.p,
                        "rn",
                        &self.rn,
                        "w",
                        &&self.w,
                    )
                }
            }
            impl Parse for Ldmdb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldmdb")),
                    }?;
                    let register_list: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 12>() as u16)
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<14, 14>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<15, 15>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { register_list, m, p, rn, w };
                    Ok(ret)
                }
            }
            impl Parse for A5_16 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(val) => Ok(val),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op = word.mask::<23, 24>();
                    let l = (word.mask::<20, 20>() as u8).local_try_into()?;
                    let w = word.mask::<21, 21>();
                    let rn = word.mask::<16, 19>();
                    let wrn = w << 4 | rn;
                    if op == 1 {
                        if !l {
                            return Ok(Self::Stm(Stm::parse(iter)?));
                        }
                        if wrn == 0b11101 {
                            return Ok(Self::Pop(Pop::parse(iter)?));
                        }
                        return Ok(Self::Ldm(Ldm::parse(iter)?));
                    }
                    if op != 2 {
                        return Err(ParseError::Invalid32Bit("A5_16"));
                    }
                    if l {
                        return Ok(Self::Ldmdb(Ldmdb::parse(iter)?));
                    }
                    if wrn == 0b11101 {
                        return Ok(Self::Push(Push::parse(iter)?));
                    }
                    Ok(Self::Stmdb(Stmdb::parse(iter)?))
                }
            }
            impl ToOperation for A5_16 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Stm(el) => {
                            let (m, registers) = (el.m, el.register_list);
                            let registers = {
                                let mut counter: usize = { 1 + 13 + 0 };
                                let mut sum: u16 = (m as u16) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((0 as u16) << counter) as u16;
                                    counter -= 13;
                                    sum |= ((registers as u16) << counter) as u16;
                                }
                                sum
                            };
                            operation::Stm::builder()
                                .set_w(Some(el.w))
                                .set_rn(el.rn)
                                .set_registers(registers.try_into().unwrap())
                                .complete()
                                .into()
                        }
                        Self::Ldm(el) => {
                            let (p, m, registers) = (el.p, el.m, el.register_list);
                            let registers = {
                                let mut counter: usize = { 1 + 1 + 13 + 0 };
                                let mut sum: u16 = (p as u16) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((m as u16) << counter) as u16;
                                    counter -= 1;
                                    sum |= ((0 as u16) << counter) as u16;
                                    counter -= 13;
                                    sum |= ((registers as u16) << counter) as u16;
                                }
                                sum
                            };
                            operation::Ldm::builder()
                                .set_w(Some(el.w))
                                .set_rn(el.rn)
                                .set_registers(registers.try_into().unwrap())
                                .complete()
                                .into()
                        }
                        Self::Pop(el) => {
                            let (p, m, registers) = (el.p, el.m, el.register_list);
                            let registers = {
                                let mut counter: usize = { 1 + 1 + 13 + 0 };
                                let mut sum: u16 = (p as u16) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((m as u16) << counter) as u16;
                                    counter -= 1;
                                    sum |= ((0 as u16) << counter) as u16;
                                    counter -= 13;
                                    sum |= ((registers as u16) << counter) as u16;
                                }
                                sum
                            };
                            operation::Pop::builder()
                                .set_registers(registers.try_into().unwrap())
                                .complete()
                                .into()
                        }
                        Self::Stmdb(el) => {
                            let (m, registers) = (el.m, el.register_list);
                            let registers = {
                                let mut counter: usize = { 1 + 13 + 0 };
                                let mut sum: u16 = (m as u16) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((0 as u16) << counter) as u16;
                                    counter -= 13;
                                    sum |= ((registers as u16) << counter) as u16;
                                }
                                sum
                            };
                            operation::Stmdb::builder()
                                .set_w(Some(el.w))
                                .set_rn(el.rn)
                                .set_registers(registers.try_into().unwrap())
                                .complete()
                                .into()
                        }
                        Self::Push(el) => {
                            let (m, registers) = (el.m, el.register_list);
                            let registers = {
                                let mut counter: usize = { 1 + 13 + 0 };
                                let mut sum: u16 = (m as u16) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((0 as u16) << counter) as u16;
                                    counter -= 13;
                                    sum |= ((registers as u16) << counter) as u16;
                                }
                                sum
                            };
                            operation::Push::builder()
                                .set_registers(registers.try_into().unwrap())
                                .complete()
                                .into()
                        }
                        Self::Ldmdb(el) => {
                            let (p, m, registers) = (el.p, el.m, el.register_list);
                            let registers = {
                                let mut counter: usize = { 1 + 1 + 13 + 0 };
                                let mut sum: u16 = (p as u16) << counter;
                                #[allow(unused_assignments)]
                                {
                                    counter -= 1;
                                    sum |= ((m as u16) << counter) as u16;
                                    counter -= 1;
                                    sum |= ((0 as u16) << counter) as u16;
                                    counter -= 13;
                                    sum |= ((registers as u16) << counter) as u16;
                                }
                                sum
                            };
                            operation::Ldmdb::builder()
                                .set_w(Some(el.w))
                                .set_rn(el.rn)
                                .set_registers(registers.try_into().unwrap())
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_17 {
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_17 {
                Strex(Strex),
                Ldrex(Ldrex),
                Strd(Strd),
                Ldrd(Ldrd),
                Strexb(Strexb),
                Strexh(Strexh),
                Tbb(Tbb),
                Ldrexb(Ldrexb),
                Ldrexh(Ldrexh),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_17 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_17::Strex(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Strex",
                                &__self_0,
                            )
                        }
                        A5_17::Ldrex(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrex",
                                &__self_0,
                            )
                        }
                        A5_17::Strd(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Strd",
                                &__self_0,
                            )
                        }
                        A5_17::Ldrd(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrd",
                                &__self_0,
                            )
                        }
                        A5_17::Strexb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Strexb",
                                &__self_0,
                            )
                        }
                        A5_17::Strexh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Strexh",
                                &__self_0,
                            )
                        }
                        A5_17::Tbb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Tbb",
                                &__self_0,
                            )
                        }
                        A5_17::Ldrexb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrexb",
                                &__self_0,
                            )
                        }
                        A5_17::Ldrexh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrexh",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_17 {
                #[allow(dead_code)]
                pub(crate) fn parse_strex<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Strex(Strex::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrex<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrex(Ldrex::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strd<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Strd(Strd::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrd<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrd(Ldrd::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strexb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Strexb(Strexb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strexh<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Strexh(Strexh::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_tbb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Tbb(Tbb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrexb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrexb(Ldrexb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrexh<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrexh(Ldrexh::parse(iter)?))
                }
            }
            /**Instruction Strex from table A5_17

*/
            /**Contains the following fields:
*/
            /**- imm of type u8 from bit 0 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Strex {
                /**bit 0 to 7

*/
                pub(crate) imm: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Strex {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Strex",
                        "imm",
                        &self.imm,
                        "rd",
                        &self.rd,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Strex {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Strex")),
                    }?;
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm, rd, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ldrex from table A5_17

*/
            /**Contains the following fields:
*/
            /**- imm of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ldrex {
                /**bit 0 to 7

*/
                pub(crate) imm: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrex {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrex",
                        "imm",
                        &self.imm,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldrex {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrex")),
                    }?;
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Strd from table A5_17

*/
            /**Contains the following fields:
*/
            /**- imm of type u8 from bit 0 to bit 7
*/
            /**- rt2 of type Register from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            /**- u of type bool from bit 23 to bit 23
*/
            /**- p of type bool from bit 24 to bit 24
*/
            pub struct Strd {
                /**bit 0 to 7

*/
                pub(crate) imm: u8,
                /**bit 8 to 11

*/
                pub(crate) rt2: Register,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
                /**bit 24 to 24

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Strd {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm", "rt2", "rt", "rn", "w", "u", "p"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm,
                        &self.rt2,
                        &self.rt,
                        &self.rn,
                        &self.w,
                        &self.u,
                        &&self.p,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Strd",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Strd {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Strd")),
                    }?;
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rt2: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<24, 24>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm, rt2, rt, rn, w, u, p };
                    Ok(ret)
                }
            }
            /**Instruction Ldrd from table A5_17

*/
            /**Contains the following fields:
*/
            /**- imm of type u8 from bit 0 to bit 7
*/
            /**- rt2 of type Register from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            /**- u of type bool from bit 23 to bit 23
*/
            /**- p of type bool from bit 24 to bit 24
*/
            pub struct Ldrd {
                /**bit 0 to 7

*/
                pub(crate) imm: u8,
                /**bit 8 to 11

*/
                pub(crate) rt2: Register,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
                /**bit 24 to 24

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrd {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm", "rt2", "rt", "rn", "w", "u", "p"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm,
                        &self.rt2,
                        &self.rt,
                        &self.rn,
                        &self.w,
                        &self.u,
                        &&self.p,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Ldrd",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Ldrd {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrd")),
                    }?;
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rt2: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<24, 24>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm, rt2, rt, rn, w, u, p };
                    Ok(ret)
                }
            }
            /**Instruction Strexb from table A5_17

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 3
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Strexb {
                /**bit 0 to 3

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Strexb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Strexb",
                        "rd",
                        &self.rd,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Strexb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Strexb")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Strexh from table A5_17

*/
            /**Contains the following fields:
*/
            /**- rd of type Register from bit 0 to bit 3
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Strexh {
                /**bit 0 to 3

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Strexh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Strexh",
                        "rd",
                        &self.rd,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Strexh {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Strexh")),
                    }?;
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rd, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Tbb from table A5_17

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- h of type bool from bit 4 to bit 4
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Tbb {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) h: bool,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Tbb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Tbb",
                        "rm",
                        &self.rm,
                        "h",
                        &self.h,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Tbb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Tbb")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let h: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, h, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ldrexb from table A5_17

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ldrexb {
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrexb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Ldrexb",
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldrexb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrexb")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ldrexh from table A5_17

*/
            /**Contains the following fields:
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ldrexh {
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrexh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Ldrexh",
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldrexh {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrexh")),
                    }?;
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rt, rn };
                    Ok(ret)
                }
            }
            impl Parse for A5_17 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(val) => Ok(val),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op3 = word.mask::<4, 7>();
                    let op2 = word.mask::<20, 21>();
                    let op1 = word.mask::<23, 24>();
                    if op1 == 00 {
                        match op2 {
                            0 => return Ok(Self::Strex(Strex::parse(iter)?)),
                            1 => return Ok(Self::Ldrex(Ldrex::parse(iter)?)),
                            _ => {}
                        }
                    }
                    if (op1 >> 1 == 0 && op2 == 2) || (op1 >> 1 == 1 && op2 & 0b1 == 0) {
                        return Ok(Self::Strd(Strd::parse(iter)?));
                    }
                    if (op1 >> 1 == 0 && op2 == 3) || (op1 >> 1 == 1 && op2 & 0b1 == 1) {
                        return Ok(Self::Ldrd(Ldrd::parse(iter)?));
                    }
                    if op1 != 0b01 {
                        return Err(ParseError::Invalid32Bit("A5_17"));
                    }
                    match (op2, op3) {
                        (0, 0b100) => Ok(Self::Strexb(Strexb::parse(iter)?)),
                        (0, 0b101) => Ok(Self::Strexh(Strexh::parse(iter)?)),
                        (1, 0) | (1, 1) => Ok(Self::Tbb(Tbb::parse(iter)?)),
                        (1, 0b100) => Ok(Self::Ldrexb(Ldrexb::parse(iter)?)),
                        (1, 0b101) => Ok(Self::Ldrexh(Ldrexh::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_17")),
                    }
                }
            }
            impl ToOperation for A5_17 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Strex(el) => {
                            let imm = (el.imm as u32) << 2;
                            operation::Strex::builder()
                                .set_rd(el.rd)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(imm))
                                .complete()
                                .into()
                        }
                        Self::Ldrex(el) => {
                            let imm = (el.imm as u32) << 2;
                            operation::Ldrex::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(imm)
                                .complete()
                                .into()
                        }
                        Self::Strd(el) => {
                            operation::StrdImmediate::builder()
                                .set_w(Some(el.w))
                                .set_rt(el.rt)
                                .set_index(Some(el.p))
                                .set_rn(el.rn)
                                .set_add(el.u)
                                .set_rt2(el.rt2)
                                .set_imm(Some((el.imm as u32) << 2))
                                .complete()
                                .into()
                        }
                        Self::Ldrd(el) => {
                            operation::LdrdImmediate::builder()
                                .set_w(Some(el.w))
                                .set_add(Some(el.u))
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rt2(el.rt2)
                                .set_index(Some(el.p))
                                .set_imm((el.imm as u32) << 2)
                                .complete()
                                .into()
                        }
                        Self::Strexb(el) => {
                            operation::Strexb::builder()
                                .set_rd(el.rd)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                        Self::Strexh(el) => {
                            operation::Strexh::builder()
                                .set_rd(el.rd)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                        Self::Tbb(el) => {
                            operation::Tb::builder()
                                .set_is_tbh(Some(el.h))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Ldrexb(el) => {
                            operation::Ldrexb::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                        Self::Ldrexh(el) => {
                            operation::Ldrexh::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_18 {
            use paste::paste;
            use crate::{
                arch::wrapper_types::*, asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_18 {
                LdrImmediateT3(LdrImmediateT3),
                LdrImmediateT4(LdrImmediateT4),
                Ldrt(Ldrt),
                LdrRegister(LdrRegister),
                LdrLiteral(LdrLiteral),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_18 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_18::LdrImmediateT3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrImmediateT3",
                                &__self_0,
                            )
                        }
                        A5_18::LdrImmediateT4(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrImmediateT4",
                                &__self_0,
                            )
                        }
                        A5_18::Ldrt(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrt",
                                &__self_0,
                            )
                        }
                        A5_18::LdrRegister(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrRegister",
                                &__self_0,
                            )
                        }
                        A5_18::LdrLiteral(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrLiteral",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_18 {
                #[allow(dead_code)]
                pub(crate) fn parse_ldrimmediatet3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrImmediateT3(LdrImmediateT3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrimmediatet4<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrImmediateT4(LdrImmediateT4::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrt<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrt(Ldrt::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrregister<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrRegister(LdrRegister::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrliteral<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrLiteral(LdrLiteral::parse(iter)?))
                }
            }
            /**Instruction LdrImmediateT3 from table A5_18

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrImmediateT3 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrImmediateT3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrImmediateT3",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrImmediateT3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrImmediateT3")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrImmediateT4 from table A5_18

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- w of type bool from bit 8 to bit 8
*/
            /**- u of type bool from bit 9 to bit 9
*/
            /**- p of type bool from bit 10 to bit 10
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrImmediateT4 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 8

*/
                pub(crate) w: bool,
                /**bit 9 to 9

*/
                pub(crate) u: bool,
                /**bit 10 to 10

*/
                pub(crate) p: bool,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrImmediateT4 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "w", "u", "p", "rt", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.w,
                        &self.u,
                        &self.p,
                        &self.rt,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdrImmediateT4",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdrImmediateT4 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrImmediateT4")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<9, 9>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 10>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, w, u, p, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ldrt from table A5_18

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ldrt {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrt {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrt",
                        "imm8",
                        &self.imm8,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldrt {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrt")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrRegister from table A5_18

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type Imm2 from bit 4 to bit 5
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrRegister {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm2: Imm2,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrRegister {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "LdrRegister",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrRegister {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrRegister")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrLiteral from table A5_18

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- u of type bool from bit 23 to bit 23
*/
            pub struct LdrLiteral {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrLiteral {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrLiteral",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "u",
                        &&self.u,
                    )
                }
            }
            impl Parse for LdrLiteral {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrLiteral")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, u };
                    Ok(ret)
                }
            }
            impl Parse for A5_18 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = iter.next()?;
                    let op2 = word.mask::<6, 11>();
                    let rn = word.mask::<16, 19>();
                    let op1 = word.mask::<23, 24>();
                    if rn == 0b1111 {
                        if op1 >> 1 == 0 {
                            return Ok(Self::LdrLiteral(LdrLiteral::parse(iter)?));
                        }
                        return Err(ParseError::Invalid32Bit("A5_18"));
                    }
                    if op1 == 1 {
                        return Ok(Self::LdrImmediateT3(LdrImmediateT3::parse(iter)?));
                    }
                    if op1 == 0 {
                        if op2 & 0b100100 == 0b100100 || op2 >> 2 == 0b1100 {
                            return Ok(
                                Self::LdrImmediateT4(LdrImmediateT4::parse(iter)?),
                            );
                        }
                        if op2 >> 2 == 0b1110 {
                            return Ok(Self::Ldrt(Ldrt::parse(iter)?));
                        }
                        if op2 == 0 {
                            return Ok(Self::LdrRegister(LdrRegister::parse(iter)?));
                        }
                    }
                    Err(ParseError::Invalid32Bit("A5_18"))
                }
            }
            impl ToOperation for A5_18 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::LdrImmediateT3(el) => {
                            operation::LdrImmediate::builder()
                                .set_w(Some(false))
                                .set_add(true)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm12.into())
                                .set_index(true)
                                .complete()
                                .into()
                        }
                        Self::LdrImmediateT4(el) => {
                            operation::LdrImmediate::builder()
                                .set_w(Some(el.w))
                                .set_add(el.u)
                                .set_index(el.p)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm8 as u32)
                                .complete()
                                .into()
                        }
                        Self::Ldrt(el) => {
                            operation::Ldrt::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm8 as u32))
                                .complete()
                                .into()
                        }
                        Self::LdrRegister(el) => {
                            let shift = ImmShift::from((Shift::Lsl, el.imm2.into()));
                            operation::LdrRegister::builder()
                                .set_w(None)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(Some(shift))
                                .complete()
                                .into()
                        }
                        Self::LdrLiteral(el) => {
                            operation::LdrLiteral::builder()
                                .set_rt(el.rt)
                                .set_add(el.u)
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_19 {
            use paste::paste;
            use crate::{
                arch::wrapper_types::*, asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_19 {
                LdrhLiteral(LdrhLiteral),
                LdrhImmediateT2(LdrhImmediateT2),
                LdrhImmediateT3(LdrhImmediateT3),
                LdrhRegister(LdrhRegister),
                Ldrht(Ldrht),
                LdrshImmediateT1(LdrshImmediateT1),
                LdrshImmediateT2(LdrshImmediateT2),
                LdrshLiteral(LdrshLiteral),
                LdrshRegister(LdrshRegister),
                Ldrsht(Ldrsht),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_19 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_19::LdrhLiteral(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrhLiteral",
                                &__self_0,
                            )
                        }
                        A5_19::LdrhImmediateT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrhImmediateT2",
                                &__self_0,
                            )
                        }
                        A5_19::LdrhImmediateT3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrhImmediateT3",
                                &__self_0,
                            )
                        }
                        A5_19::LdrhRegister(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrhRegister",
                                &__self_0,
                            )
                        }
                        A5_19::Ldrht(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrht",
                                &__self_0,
                            )
                        }
                        A5_19::LdrshImmediateT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrshImmediateT1",
                                &__self_0,
                            )
                        }
                        A5_19::LdrshImmediateT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrshImmediateT2",
                                &__self_0,
                            )
                        }
                        A5_19::LdrshLiteral(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrshLiteral",
                                &__self_0,
                            )
                        }
                        A5_19::LdrshRegister(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrshRegister",
                                &__self_0,
                            )
                        }
                        A5_19::Ldrsht(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrsht",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_19 {
                #[allow(dead_code)]
                pub(crate) fn parse_ldrhliteral<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrhLiteral(LdrhLiteral::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrhimmediatet2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrhImmediateT2(LdrhImmediateT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrhimmediatet3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrhImmediateT3(LdrhImmediateT3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrhregister<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrhRegister(LdrhRegister::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrht<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrht(Ldrht::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrshimmediatet1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrshImmediateT1(LdrshImmediateT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrshimmediatet2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrshImmediateT2(LdrshImmediateT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrshliteral<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrshLiteral(LdrshLiteral::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrshregister<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrshRegister(LdrshRegister::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrsht<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrsht(Ldrsht::parse(iter)?))
                }
            }
            /**Instruction LdrhLiteral from table A5_19

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- u of type bool from bit 23 to bit 23
*/
            pub struct LdrhLiteral {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrhLiteral {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrhLiteral",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "u",
                        &&self.u,
                    )
                }
            }
            impl Parse for LdrhLiteral {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrhLiteral")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, u };
                    Ok(ret)
                }
            }
            /**Instruction LdrhImmediateT2 from table A5_19

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrhImmediateT2 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrhImmediateT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrhImmediateT2",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrhImmediateT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrhImmediateT2")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrhImmediateT3 from table A5_19

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- w of type bool from bit 8 to bit 8
*/
            /**- u of type bool from bit 9 to bit 9
*/
            /**- p of type bool from bit 10 to bit 10
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrhImmediateT3 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 8

*/
                pub(crate) w: bool,
                /**bit 9 to 9

*/
                pub(crate) u: bool,
                /**bit 10 to 10

*/
                pub(crate) p: bool,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrhImmediateT3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "w", "u", "p", "rt", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.w,
                        &self.u,
                        &self.p,
                        &self.rt,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdrhImmediateT3",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdrhImmediateT3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrhImmediateT3")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<9, 9>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 10>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, w, u, p, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrhRegister from table A5_19

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type Imm2 from bit 4 to bit 5
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrhRegister {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm2: Imm2,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrhRegister {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "LdrhRegister",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrhRegister {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrhRegister")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ldrht from table A5_19

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ldrht {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrht {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrht",
                        "imm8",
                        &self.imm8,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldrht {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrht")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrshImmediateT1 from table A5_19

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrshImmediateT1 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrshImmediateT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrshImmediateT1",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrshImmediateT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrshImmediateT1")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrshImmediateT2 from table A5_19

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- w of type bool from bit 8 to bit 8
*/
            /**- u of type bool from bit 9 to bit 9
*/
            /**- p of type bool from bit 10 to bit 10
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrshImmediateT2 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 8

*/
                pub(crate) w: bool,
                /**bit 9 to 9

*/
                pub(crate) u: bool,
                /**bit 10 to 10

*/
                pub(crate) p: bool,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrshImmediateT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "w", "u", "p", "rt", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.w,
                        &self.u,
                        &self.p,
                        &self.rt,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdrshImmediateT2",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdrshImmediateT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrshImmediateT2")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<9, 9>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 10>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, w, u, p, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrshLiteral from table A5_19

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- u of type bool from bit 23 to bit 23
*/
            pub struct LdrshLiteral {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrshLiteral {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrshLiteral",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "u",
                        &&self.u,
                    )
                }
            }
            impl Parse for LdrshLiteral {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrshLiteral")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, u };
                    Ok(ret)
                }
            }
            /**Instruction LdrshRegister from table A5_19

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type Imm2 from bit 4 to bit 5
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrshRegister {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm2: Imm2,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrshRegister {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "LdrshRegister",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrshRegister {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrshRegister")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ldrsht from table A5_19

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ldrsht {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrsht {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrsht",
                        "imm8",
                        &self.imm8,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldrsht {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrsht")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rt, rn };
                    Ok(ret)
                }
            }
            impl Parse for A5_19 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op2 = word.mask::<6, 11>();
                    let rt = word.mask::<12, 15>();
                    let rn = word.mask::<16, 19>();
                    let op1 = word.mask::<23, 24>();
                    if rt == 0b1111 {
                        return Err(
                            ParseError::Invalid32Bit("A5_19 or strangly encoded NOP"),
                        );
                    }
                    if rn == 0b1111 {
                        if op1 >> 1 == 0 {
                            return Ok(Self::LdrhLiteral(LdrhLiteral::parse(iter)?));
                        }
                        return Ok(Self::LdrshLiteral(LdrshLiteral::parse(iter)?));
                    }
                    if op1 == 0 {
                        if op2 == 0 {
                            return Ok(Self::LdrhRegister(LdrhRegister::parse(iter)?));
                        }
                        if (op2 >> 2) == 0b1100 || (op2 & 0b100100) == 0b100100 {
                            return Ok(
                                Self::LdrhImmediateT3(LdrhImmediateT3::parse(iter)?),
                            );
                        }
                        if op2 >> 2 == 0b1110 {
                            return Ok(Self::Ldrht(Ldrht::parse(iter)?));
                        }
                        return Err(ParseError::Invalid32Bit("A5_19"));
                    }
                    if op1 == 1 {
                        return Ok(Self::LdrhImmediateT2(LdrhImmediateT2::parse(iter)?));
                    }
                    if op1 == 2 {
                        if op2 & 0b100100 == 0b100100 || op2 >> 2 == 0b1100 {
                            return Ok(
                                Self::LdrshImmediateT2(LdrshImmediateT2::parse(iter)?),
                            );
                        }
                        if op2 == 0 {
                            return Ok(Self::LdrshRegister(LdrshRegister::parse(iter)?));
                        }
                        if op2 >> 2 == 0b1110 {
                            return Ok(Self::Ldrsht(Ldrsht::parse(iter)?));
                        }
                        return Err(ParseError::Invalid32Bit("A5_19"));
                    }
                    if op1 == 3 {
                        return Ok(
                            Self::LdrshImmediateT1(LdrshImmediateT1::parse(iter)?),
                        );
                    }
                    Err(ParseError::Invalid32Bit("A5_19"))
                }
            }
            impl ToOperation for A5_19 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::LdrhLiteral(el) => {
                            operation::LdrhLiteral::builder()
                                .set_rt(el.rt)
                                .set_add(Some(el.u))
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::LdrhImmediateT2(el) => {
                            operation::LdrhImmediate::builder()
                                .set_w(Some(false))
                                .set_add(Some(true))
                                .set_index(Some(true))
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::LdrhImmediateT3(el) => {
                            operation::LdrhImmediate::builder()
                                .set_w(Some(el.w))
                                .set_add(Some(el.u))
                                .set_index(Some(el.p))
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm8 as u32)
                                .complete()
                                .into()
                        }
                        Self::LdrhRegister(el) => {
                            let shift = Some(
                                ImmShift::from((Shift::Lsl, el.imm2.into())),
                            );
                            operation::LdrhRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::LdrshImmediateT1(el) => {
                            operation::LdrshImmediate::builder()
                                .set_add(true)
                                .set_index(true)
                                .set_wback(false)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm12.into()))
                                .complete()
                                .into()
                        }
                        Self::LdrshImmediateT2(el) => {
                            operation::LdrshImmediate::builder()
                                .set_add(el.u)
                                .set_index(el.p)
                                .set_wback(el.w)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm8 as u32))
                                .complete()
                                .into()
                        }
                        Self::LdrshLiteral(el) => {
                            operation::LdrshLiteral::builder()
                                .set_add(el.u)
                                .set_rt(el.rt)
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::LdrshRegister(el) => {
                            let shift = Some(
                                ImmShift::from((Shift::Lsl, el.imm2.into())),
                            );
                            operation::LdrshRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::Ldrsht(el) => {
                            operation::Ldrsht::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm8 as u32))
                                .complete()
                                .into()
                        }
                        Self::Ldrht(el) => {
                            operation::Ldrht::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm8 as u32))
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_20 {
            use paste::paste;
            use crate::{
                arch::wrapper_types::*, asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_20 {
                LdrbLiteral(LdrbLiteral),
                LdrbImmediateT2(LdrbImmediateT2),
                LdrbImmediateT3(LdrbImmediateT3),
                Ldrbt(Ldrbt),
                LdrbRegister(LdrbRegister),
                LdrsbLiteral(LdrsbLiteral),
                LdrsbImmediateT1(LdrsbImmediateT1),
                LdrsbImmediateT2(LdrsbImmediateT2),
                Ldrsbt(Ldrsbt),
                LdrsbRegister(LdrsbRegister),
                PldLiteral(PldLiteral),
                PldImmediateT1(PldImmediateT1),
                PldImmediateT2(PldImmediateT2),
                PldRegister(PldRegister),
                PliImmediateT1(PliImmediateT1),
                PliImmediateT2(PliImmediateT2),
                PliImmediateT3(PliImmediateT3),
                PliRegister(PliRegister),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_20 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_20::LdrbLiteral(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrbLiteral",
                                &__self_0,
                            )
                        }
                        A5_20::LdrbImmediateT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrbImmediateT2",
                                &__self_0,
                            )
                        }
                        A5_20::LdrbImmediateT3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrbImmediateT3",
                                &__self_0,
                            )
                        }
                        A5_20::Ldrbt(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrbt",
                                &__self_0,
                            )
                        }
                        A5_20::LdrbRegister(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrbRegister",
                                &__self_0,
                            )
                        }
                        A5_20::LdrsbLiteral(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrsbLiteral",
                                &__self_0,
                            )
                        }
                        A5_20::LdrsbImmediateT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrsbImmediateT1",
                                &__self_0,
                            )
                        }
                        A5_20::LdrsbImmediateT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrsbImmediateT2",
                                &__self_0,
                            )
                        }
                        A5_20::Ldrsbt(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ldrsbt",
                                &__self_0,
                            )
                        }
                        A5_20::LdrsbRegister(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdrsbRegister",
                                &__self_0,
                            )
                        }
                        A5_20::PldLiteral(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PldLiteral",
                                &__self_0,
                            )
                        }
                        A5_20::PldImmediateT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PldImmediateT1",
                                &__self_0,
                            )
                        }
                        A5_20::PldImmediateT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PldImmediateT2",
                                &__self_0,
                            )
                        }
                        A5_20::PldRegister(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PldRegister",
                                &__self_0,
                            )
                        }
                        A5_20::PliImmediateT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PliImmediateT1",
                                &__self_0,
                            )
                        }
                        A5_20::PliImmediateT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PliImmediateT2",
                                &__self_0,
                            )
                        }
                        A5_20::PliImmediateT3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PliImmediateT3",
                                &__self_0,
                            )
                        }
                        A5_20::PliRegister(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "PliRegister",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_20 {
                #[allow(dead_code)]
                pub(crate) fn parse_ldrbliteral<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrbLiteral(LdrbLiteral::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrbimmediatet2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrbImmediateT2(LdrbImmediateT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrbimmediatet3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrbImmediateT3(LdrbImmediateT3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrbt<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrbt(Ldrbt::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrbregister<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrbRegister(LdrbRegister::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrsbliteral<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrsbLiteral(LdrsbLiteral::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrsbimmediatet1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrsbImmediateT1(LdrsbImmediateT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrsbimmediatet2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrsbImmediateT2(LdrsbImmediateT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrsbt<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ldrsbt(Ldrsbt::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldrsbregister<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdrsbRegister(LdrsbRegister::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pldliteral<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::PldLiteral(PldLiteral::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pldimmediatet1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::PldImmediateT1(PldImmediateT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pldimmediatet2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::PldImmediateT2(PldImmediateT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pldregister<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::PldRegister(PldRegister::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pliimmediatet1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::PliImmediateT1(PliImmediateT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pliimmediatet2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::PliImmediateT2(PliImmediateT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pliimmediatet3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::PliImmediateT3(PliImmediateT3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pliregister<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::PliRegister(PliRegister::parse(iter)?))
                }
            }
            /**Instruction LdrbLiteral from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- u of type bool from bit 23 to bit 23
*/
            pub struct LdrbLiteral {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrbLiteral {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrbLiteral",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "u",
                        &&self.u,
                    )
                }
            }
            impl Parse for LdrbLiteral {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrbLiteral")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, u };
                    Ok(ret)
                }
            }
            /**Instruction LdrbImmediateT2 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrbImmediateT2 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrbImmediateT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrbImmediateT2",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrbImmediateT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrbImmediateT2")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrbImmediateT3 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- w of type bool from bit 8 to bit 8
*/
            /**- u of type bool from bit 9 to bit 9
*/
            /**- p of type bool from bit 10 to bit 10
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrbImmediateT3 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 8

*/
                pub(crate) w: bool,
                /**bit 9 to 9

*/
                pub(crate) u: bool,
                /**bit 10 to 10

*/
                pub(crate) p: bool,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrbImmediateT3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "w", "u", "p", "rt", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.w,
                        &self.u,
                        &self.p,
                        &self.rt,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdrbImmediateT3",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdrbImmediateT3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrbImmediateT3")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<9, 9>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 10>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, w, u, p, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ldrbt from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ldrbt {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrbt {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrbt",
                        "imm8",
                        &self.imm8,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldrbt {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrbt")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrbRegister from table A5_20

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type Imm2 from bit 4 to bit 5
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrbRegister {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm2: Imm2,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrbRegister {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "LdrbRegister",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrbRegister {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrbRegister")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrsbLiteral from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- u of type bool from bit 23 to bit 23
*/
            pub struct LdrsbLiteral {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrsbLiteral {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrsbLiteral",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "u",
                        &&self.u,
                    )
                }
            }
            impl Parse for LdrsbLiteral {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrsbLiteral")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, u };
                    Ok(ret)
                }
            }
            /**Instruction LdrsbImmediateT1 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrsbImmediateT1 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrsbImmediateT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "LdrsbImmediateT1",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrsbImmediateT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrsbImmediateT1")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrsbImmediateT2 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- w of type bool from bit 8 to bit 8
*/
            /**- u of type bool from bit 9 to bit 9
*/
            /**- p of type bool from bit 10 to bit 10
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrsbImmediateT2 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 8

*/
                pub(crate) w: bool,
                /**bit 9 to 9

*/
                pub(crate) u: bool,
                /**bit 10 to 10

*/
                pub(crate) p: bool,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrsbImmediateT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "w", "u", "p", "rt", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.w,
                        &self.u,
                        &self.p,
                        &self.rt,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdrsbImmediateT2",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdrsbImmediateT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrsbImmediateT2")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<9, 9>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 10>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, w, u, p, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ldrsbt from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ldrsbt {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ldrsbt {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ldrsbt",
                        "imm8",
                        &self.imm8,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ldrsbt {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ldrsbt")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction LdrsbRegister from table A5_20

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type Imm2 from bit 4 to bit 5
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct LdrsbRegister {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm2: Imm2,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdrsbRegister {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "LdrsbRegister",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for LdrsbRegister {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdrsbRegister")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction PldLiteral from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- u of type bool from bit 23 to bit 23
*/
            pub struct PldLiteral {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PldLiteral {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "PldLiteral",
                        "imm12",
                        &self.imm12,
                        "u",
                        &&self.u,
                    )
                }
            }
            impl Parse for PldLiteral {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("PldLiteral")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, u };
                    Ok(ret)
                }
            }
            /**Instruction PldImmediateT1 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct PldImmediateT1 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PldImmediateT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "PldImmediateT1",
                        "imm12",
                        &self.imm12,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for PldImmediateT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("PldImmediateT1")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rn };
                    Ok(ret)
                }
            }
            /**Instruction PldImmediateT2 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct PldImmediateT2 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PldImmediateT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "PldImmediateT2",
                        "imm8",
                        &self.imm8,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for PldImmediateT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("PldImmediateT2")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rn };
                    Ok(ret)
                }
            }
            /**Instruction PldRegister from table A5_20

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type Imm2 from bit 4 to bit 5
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct PldRegister {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm2: Imm2,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PldRegister {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "PldRegister",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for PldRegister {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("PldRegister")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rn };
                    Ok(ret)
                }
            }
            /**Instruction PliImmediateT1 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct PliImmediateT1 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PliImmediateT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "PliImmediateT1",
                        "imm12",
                        &self.imm12,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for PliImmediateT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("PliImmediateT1")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rn };
                    Ok(ret)
                }
            }
            /**Instruction PliImmediateT2 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct PliImmediateT2 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PliImmediateT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "PliImmediateT2",
                        "imm8",
                        &self.imm8,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for PliImmediateT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("PliImmediateT2")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, rn };
                    Ok(ret)
                }
            }
            /**Instruction PliImmediateT3 from table A5_20

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- u of type bool from bit 23 to bit 23
*/
            pub struct PliImmediateT3 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PliImmediateT3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "PliImmediateT3",
                        "imm12",
                        &self.imm12,
                        "u",
                        &&self.u,
                    )
                }
            }
            impl Parse for PliImmediateT3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("PliImmediateT3")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, u };
                    Ok(ret)
                }
            }
            /**Instruction PliRegister from table A5_20

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type Imm2 from bit 4 to bit 5
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct PliRegister {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm2: Imm2,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PliRegister {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "PliRegister",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for PliRegister {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("PliRegister")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rn };
                    Ok(ret)
                }
            }
            impl Parse for A5_20 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op2 = word.mask::<6, 11>();
                    let rt = word.mask::<12, 15>();
                    let rn = word.mask::<16, 19>();
                    let op1 = word.mask::<23, 24>();
                    if rt == 0b1111 {
                        if rn == 0b1111 {
                            if op1 >> 1 == 0 {
                                return Ok(Self::PldLiteral(PldLiteral::parse(iter)?));
                            }
                            return Ok(
                                Self::PliImmediateT3(PliImmediateT3::parse(iter)?),
                            );
                        }
                        if op1 == 1 {
                            return Ok(
                                Self::PldImmediateT1(PldImmediateT1::parse(iter)?),
                            );
                        }
                        if op1 == 3 {
                            return Ok(
                                Self::PliImmediateT1(PliImmediateT1::parse(iter)?),
                            );
                        }
                        if op1 == 0 {
                            if op2 == 0 {
                                return Ok(Self::PldRegister(PldRegister::parse(iter)?));
                            }
                            if (op2 >> 2) == 0b1100 {
                                return Ok(
                                    Self::PldImmediateT2(PldImmediateT2::parse(iter)?),
                                );
                            }
                            if (op2 >> 2) == 0b1110 {
                                return Err(ParseError::Unpredictable);
                            }
                            if (op2 & 0b100100) == 0b100100 {
                                return Err(ParseError::Unpredictable);
                            }
                            return Err(ParseError::Invalid32Bit("A5_20"));
                        }
                        if op1 == 2 && op2 >> 2 == 0b1100 {
                            return Ok(
                                Self::PliImmediateT2(PliImmediateT2::parse(iter)?),
                            );
                        }
                        if op1 == 2 && op2 == 0 {
                            return Ok(Self::PliRegister(PliRegister::parse(iter)?));
                        }
                        return Err(ParseError::Invalid32Bit("A5_20"));
                    }
                    if rn == 0b1111 {
                        if (op1 >> 1) == 0 {
                            return Ok(Self::LdrbLiteral(LdrbLiteral::parse(iter)?));
                        }
                        return Ok(Self::LdrsbLiteral(LdrsbLiteral::parse(iter)?));
                    }
                    if op1 == 0 {
                        if op2 == 0 {
                            return Ok(Self::LdrbRegister(LdrbRegister::parse(iter)?));
                        }
                        if op2 >> 2 == 0b1110 {
                            return Ok(Self::Ldrbt(Ldrbt::parse(iter)?));
                        }
                        if op2 >> 2 == 0b1100 {
                            return Ok(
                                Self::LdrbImmediateT3(LdrbImmediateT3::parse(iter)?),
                            );
                        }
                        if op2 & 0b100100 == 0b100100 {
                            return Ok(
                                Self::LdrbImmediateT3(LdrbImmediateT3::parse(iter)?),
                            );
                        }
                        return Err(ParseError::Invalid32Bit("A5_20"));
                    }
                    if op1 == 1 {
                        return Ok(Self::LdrbImmediateT2(LdrbImmediateT2::parse(iter)?));
                    }
                    if op1 == 3 {
                        return Ok(
                            Self::LdrsbImmediateT1(LdrsbImmediateT1::parse(iter)?),
                        );
                    }
                    if op2 == 0 {
                        return Ok(Self::LdrsbRegister(LdrsbRegister::parse(iter)?));
                    }
                    if (op2 >> 2) == 0b1110 {
                        return Ok(Self::Ldrsbt(Ldrsbt::parse(iter)?));
                    }
                    if (op2 >> 2) == 0b1100 {
                        return Ok(
                            Self::LdrsbImmediateT2(LdrsbImmediateT2::parse(iter)?),
                        );
                    }
                    if (op2 & 0b100100) == 0b100100 {
                        return Ok(
                            Self::LdrsbImmediateT2(LdrsbImmediateT2::parse(iter)?),
                        );
                    }
                    Err(ParseError::Invalid32Bit("A5_20"))
                }
            }
            impl ToOperation for A5_20 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::LdrbLiteral(el) => {
                            operation::LdrbLiteral::builder()
                                .set_add(Some(el.u))
                                .set_rt(el.rt)
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::LdrbImmediateT2(el) => {
                            operation::LdrbImmediate::builder()
                                .set_w(Some(false))
                                .set_add(Some(true))
                                .set_rt(el.rt)
                                .set_index(true)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm12.into()))
                                .complete()
                                .into()
                        }
                        Self::LdrbImmediateT3(el) => {
                            operation::LdrbImmediate::builder()
                                .set_w(Some(el.w))
                                .set_add(Some(el.u))
                                .set_index(el.p)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm8 as u32))
                                .complete()
                                .into()
                        }
                        Self::Ldrbt(el) => {
                            operation::Ldrbt::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm8 as u32))
                                .complete()
                                .into()
                        }
                        Self::LdrbRegister(el) => {
                            let shift = Some(
                                ImmShift::from((Shift::Lsl, el.imm2.into())),
                            );
                            operation::LdrbRegister::builder()
                                .set_add(Some(true))
                                .set_shift(shift)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::LdrsbLiteral(el) => {
                            operation::LdrsbLiteral::builder()
                                .set_rt(el.rt)
                                .set_add(el.u)
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::LdrsbImmediateT1(el) => {
                            operation::LdrsbImmediate::builder()
                                .set_add(true)
                                .set_index(true)
                                .set_wback(false)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm12.into()))
                                .complete()
                                .into()
                        }
                        Self::LdrsbImmediateT2(el) => {
                            operation::LdrsbImmediate::builder()
                                .set_add(el.u)
                                .set_index(el.p)
                                .set_wback(el.w)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm8 as u32))
                                .complete()
                                .into()
                        }
                        Self::Ldrsbt(el) => {
                            operation::Ldrsbt::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm8 as u32)
                                .complete()
                                .into()
                        }
                        Self::LdrsbRegister(el) => {
                            let shift = Some(
                                ImmShift::from((Shift::Lsl, el.imm2.into())),
                            );
                            operation::LdrsbRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::PldLiteral(el) => {
                            operation::PldLiteral::builder()
                                .set_add(Some(el.u))
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::PldImmediateT1(el) => {
                            operation::PldImmediate::builder()
                                .set_add(Some(true))
                                .set_rn(el.rn)
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::PldImmediateT2(el) => {
                            operation::PldImmediate::builder()
                                .set_add(Some(false))
                                .set_rn(el.rn)
                                .set_imm(el.imm8 as u32)
                                .complete()
                                .into()
                        }
                        Self::PldRegister(el) => {
                            let shift = Some(
                                ImmShift::from((Shift::Lsl, el.imm2.into())),
                            );
                            operation::PldRegister::builder()
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::PliImmediateT1(el) => {
                            operation::PliImmediate::builder()
                                .set_add(Some(true))
                                .set_rn(Some(el.rn))
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::PliImmediateT2(el) => {
                            operation::PliImmediate::builder()
                                .set_add(Some(false))
                                .set_rn(Some(el.rn))
                                .set_imm(el.imm8 as u32)
                                .complete()
                                .into()
                        }
                        Self::PliImmediateT3(el) => {
                            operation::PliImmediate::builder()
                                .set_add(Some(el.u))
                                .set_rn(Some(Register::try_from(15_u8).unwrap()))
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::PliRegister(el) => {
                            let shift = Some(
                                ImmShift::from((Shift::Lsl, el.imm2.into())),
                            );
                            operation::PliRegister::builder()
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_21 {
            use paste::paste;
            use crate::{
                arch::wrapper_types::*, asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_21 {
                StrbT2(StrbT2),
                StrbT3(StrbT3),
                StrbReg(StrbReg),
                StrhIT2(StrhIT2),
                StrhIT3(StrhIT3),
                StrhReg(StrhReg),
                StrIT3(StrIT3),
                StrIT4(StrIT4),
                StrReg(StrReg),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_21 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_21::StrbT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrbT2",
                                &__self_0,
                            )
                        }
                        A5_21::StrbT3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrbT3",
                                &__self_0,
                            )
                        }
                        A5_21::StrbReg(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrbReg",
                                &__self_0,
                            )
                        }
                        A5_21::StrhIT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrhIT2",
                                &__self_0,
                            )
                        }
                        A5_21::StrhIT3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrhIT3",
                                &__self_0,
                            )
                        }
                        A5_21::StrhReg(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrhReg",
                                &__self_0,
                            )
                        }
                        A5_21::StrIT3(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrIT3",
                                &__self_0,
                            )
                        }
                        A5_21::StrIT4(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrIT4",
                                &__self_0,
                            )
                        }
                        A5_21::StrReg(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StrReg",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_21 {
                #[allow(dead_code)]
                pub(crate) fn parse_strbt2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrbT2(StrbT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strbt3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrbT3(StrbT3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strbreg<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrbReg(StrbReg::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strhit2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrhIT2(StrhIT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strhit3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrhIT3(StrhIT3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strhreg<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrhReg(StrhReg::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strit3<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrIT3(StrIT3::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strit4<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrIT4(StrIT4::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_strreg<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StrReg(StrReg::parse(iter)?))
                }
            }
            /**Instruction StrbT2 from table A5_21

*/
            /**Contains the following fields:
*/
            /**- imm12 of type Imm12 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrbT2 {
                /**bit 0 to 11

*/
                pub(crate) imm12: Imm12,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrbT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "StrbT2",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for StrbT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrbT2")),
                    }?;
                    let imm12: Imm12 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction StrbT3 from table A5_21

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- w of type bool from bit 8 to bit 8
*/
            /**- u of type bool from bit 9 to bit 9
*/
            /**- p of type bool from bit 10 to bit 10
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrbT3 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 8

*/
                pub(crate) w: bool,
                /**bit 9 to 9

*/
                pub(crate) u: bool,
                /**bit 10 to 10

*/
                pub(crate) p: bool,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrbT3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "w", "u", "p", "rt", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.w,
                        &self.u,
                        &self.p,
                        &self.rt,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "StrbT3",
                        names,
                        values,
                    )
                }
            }
            impl Parse for StrbT3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrbT3")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<9, 9>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 10>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, w, u, p, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction StrbReg from table A5_21

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm of type u8 from bit 4 to bit 5
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrbReg {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrbReg {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "StrbReg",
                        "rm",
                        &self.rm,
                        "imm",
                        &self.imm,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for StrbReg {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrbReg")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction StrhIT2 from table A5_21

*/
            /**Contains the following fields:
*/
            /**- imm12 of type u16 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrhIT2 {
                /**bit 0 to 11

*/
                pub(crate) imm12: u16,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrhIT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "StrhIT2",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for StrhIT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrhIT2")),
                    }?;
                    let imm12: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction StrhIT3 from table A5_21

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- w of type bool from bit 8 to bit 8
*/
            /**- u of type bool from bit 9 to bit 9
*/
            /**- p of type bool from bit 10 to bit 10
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrhIT3 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 8

*/
                pub(crate) w: bool,
                /**bit 9 to 9

*/
                pub(crate) u: bool,
                /**bit 10 to 10

*/
                pub(crate) p: bool,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrhIT3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "w", "u", "p", "rt", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.w,
                        &self.u,
                        &self.p,
                        &self.rt,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "StrhIT3",
                        names,
                        values,
                    )
                }
            }
            impl Parse for StrhIT3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrhIT3")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<9, 9>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 10>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, w, u, p, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction StrhReg from table A5_21

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm of type u8 from bit 4 to bit 5
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrhReg {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrhReg {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "StrhReg",
                        "rm",
                        &self.rm,
                        "imm",
                        &self.imm,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for StrhReg {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrhReg")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction StrIT3 from table A5_21

*/
            /**Contains the following fields:
*/
            /**- imm12 of type u16 from bit 0 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrIT3 {
                /**bit 0 to 11

*/
                pub(crate) imm12: u16,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrIT3 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "StrIT3",
                        "imm12",
                        &self.imm12,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for StrIT3 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrIT3")),
                    }?;
                    let imm12: u16 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 11>() as u16)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm12, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction StrIT4 from table A5_21

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- w of type bool from bit 8 to bit 8
*/
            /**- u of type bool from bit 9 to bit 9
*/
            /**- p of type bool from bit 10 to bit 10
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrIT4 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 8

*/
                pub(crate) w: bool,
                /**bit 9 to 9

*/
                pub(crate) u: bool,
                /**bit 10 to 10

*/
                pub(crate) p: bool,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrIT4 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["imm8", "w", "u", "p", "rt", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.w,
                        &self.u,
                        &self.p,
                        &self.rt,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "StrIT4",
                        names,
                        values,
                    )
                }
            }
            impl Parse for StrIT4 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrIT4")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<9, 9>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<10, 10>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { imm8, w, u, p, rt, rn };
                    Ok(ret)
                }
            }
            /**Instruction StrReg from table A5_21

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm of type u8 from bit 4 to bit 5
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct StrReg {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) imm: u8,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StrReg {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "StrReg",
                        "rm",
                        &self.rm,
                        "imm",
                        &self.imm,
                        "rt",
                        &self.rt,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for StrReg {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StrReg")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm, rt, rn };
                    Ok(ret)
                }
            }
            impl Parse for A5_21 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op2 = word.mask::<11, 11>();
                    let op1 = word.mask::<21, 23>();
                    match (op1, op2) {
                        (0b100, _) => Ok(Self::StrbT2(StrbT2::parse(iter)?)),
                        (0b000, 1) => Ok(Self::StrbT3(StrbT3::parse(iter)?)),
                        (0b000, 0) => Ok(Self::StrbReg(StrbReg::parse(iter)?)),
                        (0b101, _) => Ok(Self::StrhIT2(StrhIT2::parse(iter)?)),
                        (0b001, 1) => Ok(Self::StrhIT3(StrhIT3::parse(iter)?)),
                        (0b001, 0) => Ok(Self::StrhReg(StrhReg::parse(iter)?)),
                        (0b110, _) => Ok(Self::StrIT3(StrIT3::parse(iter)?)),
                        (0b010, 1) => Ok(Self::StrIT4(StrIT4::parse(iter)?)),
                        (0b010, 0) => Ok(Self::StrReg(StrReg::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_21")),
                    }
                }
            }
            impl ToOperation for A5_21 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::StrbT2(el) => {
                            operation::StrbImmediate::builder()
                                .set_w(Some(false))
                                .set_index(Some(true))
                                .set_add(true)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::StrbT3(el) => {
                            operation::StrbImmediate::builder()
                                .set_w(Some(el.w))
                                .set_index(Some(el.p))
                                .set_add(el.u)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm8 as u32)
                                .complete()
                                .into()
                        }
                        Self::StrbReg(el) => {
                            let shift = Some(ImmShift::from((Shift::Lsl, el.imm)));
                            operation::StrbRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::StrhIT2(el) => {
                            operation::StrhImmediate::builder()
                                .set_w(false)
                                .set_index(true)
                                .set_add(true)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm12.into()))
                                .complete()
                                .into()
                        }
                        Self::StrhIT3(el) => {
                            operation::StrhImmediate::builder()
                                .set_w(el.w)
                                .set_index(el.p)
                                .set_add(el.u)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(Some(el.imm8 as u32))
                                .complete()
                                .into()
                        }
                        Self::StrhReg(el) => {
                            let shift = Some(ImmShift::from((Shift::Lsl, el.imm)));
                            operation::StrhRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::StrIT3(el) => {
                            operation::StrImmediate::builder()
                                .set_w(Some(false))
                                .set_index(Some(true))
                                .set_add(true)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm12.into())
                                .complete()
                                .into()
                        }
                        Self::StrIT4(el) => {
                            operation::StrImmediate::builder()
                                .set_w(Some(el.w))
                                .set_index(Some(el.p))
                                .set_add(el.u)
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_imm(el.imm8 as u32)
                                .complete()
                                .into()
                        }
                        Self::StrReg(el) => {
                            let shift = Some(ImmShift::from((Shift::Lsl, el.imm)));
                            operation::StrRegister::builder()
                                .set_rt(el.rt)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_22 {
            use paste::paste;
            use crate::{
                asm::{b32::a5_23::A5_23, LocalTryInto, Mask},
                combine, instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_22 {
                And(And),
                Tst(Tst),
                Bic(Bic),
                Orr(Orr),
                ///Externally defined instruction or set of instructions [`A5_23`]
                SubtableA5_23(A5_23),
                Orn(Orn),
                Mvn(Mvn),
                Eor(Eor),
                Teq(Teq),
                Pkh(Pkh),
                Add(Add),
                Cmn(Cmn),
                Adc(Adc),
                Sbc(Sbc),
                Sub(Sub),
                Cmp(Cmp),
                Rsb(Rsb),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_22 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_22::And(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "And",
                                &__self_0,
                            )
                        }
                        A5_22::Tst(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Tst",
                                &__self_0,
                            )
                        }
                        A5_22::Bic(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bic",
                                &__self_0,
                            )
                        }
                        A5_22::Orr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Orr",
                                &__self_0,
                            )
                        }
                        A5_22::SubtableA5_23(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubtableA5_23",
                                &__self_0,
                            )
                        }
                        A5_22::Orn(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Orn",
                                &__self_0,
                            )
                        }
                        A5_22::Mvn(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mvn",
                                &__self_0,
                            )
                        }
                        A5_22::Eor(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Eor",
                                &__self_0,
                            )
                        }
                        A5_22::Teq(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Teq",
                                &__self_0,
                            )
                        }
                        A5_22::Pkh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Pkh",
                                &__self_0,
                            )
                        }
                        A5_22::Add(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Add",
                                &__self_0,
                            )
                        }
                        A5_22::Cmn(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cmn",
                                &__self_0,
                            )
                        }
                        A5_22::Adc(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Adc",
                                &__self_0,
                            )
                        }
                        A5_22::Sbc(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sbc",
                                &__self_0,
                            )
                        }
                        A5_22::Sub(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sub",
                                &__self_0,
                            )
                        }
                        A5_22::Cmp(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Cmp",
                                &__self_0,
                            )
                        }
                        A5_22::Rsb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rsb",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_22 {
                #[allow(dead_code)]
                pub(crate) fn parse_and<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::And(And::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_tst<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Tst(Tst::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_bic<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Bic(Bic::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_orr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Orr(Orr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_orn<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Orn(Orn::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mvn<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mvn(Mvn::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_eor<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Eor(Eor::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_teq<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Teq(Teq::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_pkh<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Pkh(Pkh::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_add<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Add(Add::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cmn<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cmn(Cmn::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_adc<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Adc(Adc::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sbc<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sbc(Sbc::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sub<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sub(Sub::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cmp<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Cmp(Cmp::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rsb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rsb(Rsb::parse(iter)?))
                }
            }
            /**Instruction And from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct And {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for And {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "And",
                        names,
                        values,
                    )
                }
            }
            impl Parse for And {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("And")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Tst from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Tst {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Tst {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Tst",
                        "rm",
                        &self.rm,
                        "ty",
                        &self.ty,
                        "imm2",
                        &self.imm2,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Tst {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Tst")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, ty, imm2, imm3, rn };
                    Ok(ret)
                }
            }
            /**Instruction Bic from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Bic {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Bic",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Bic {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Bic")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Orr from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Orr {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Orr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Orr",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Orr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Orr")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Orn from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Orn {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Orn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Orn",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Orn {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Orn")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Mvn from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Mvn {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mvn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["rm", "ty", "imm2", "rd", "imm3", "s"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Mvn",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Mvn {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mvn")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, ty, imm2, rd, imm3, s };
                    Ok(ret)
                }
            }
            /**Instruction Eor from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Eor {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Eor {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Eor",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Eor {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Eor")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Teq from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Teq {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Teq {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Teq",
                        "rm",
                        &self.rm,
                        "ty",
                        &self.ty,
                        "imm2",
                        &self.imm2,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Teq {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Teq")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, ty, imm2, imm3, rn };
                    Ok(ret)
                }
            }
            /**Instruction Pkh from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- t of type bool from bit 4 to bit 4
*/
            /**- tb of type bool from bit 5 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- _s of type bool from bit 20 to bit 20
*/
            pub struct Pkh {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) t: bool,
                /**bit 5 to 5

*/
                pub(crate) tb: bool,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) _s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Pkh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "t",
                        "tb",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "_s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.t,
                        &self.tb,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self._s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Pkh",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Pkh {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Pkh")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let t: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let tb: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let _s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        t,
                        tb,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        _s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Add from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Add {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Add {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Add",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Add {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Add")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Cmn from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Cmn {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cmn {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Cmn",
                        "rm",
                        &self.rm,
                        "ty",
                        &self.ty,
                        "imm2",
                        &self.imm2,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Cmn {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cmn")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, ty, imm2, imm3, rn };
                    Ok(ret)
                }
            }
            /**Instruction Adc from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Adc {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Adc {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Adc",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Adc {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Adc")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Sbc from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Sbc {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sbc {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Sbc",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Sbc {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sbc")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Sub from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Sub {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sub {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Sub",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Sub {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sub")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            /**Instruction Cmp from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Cmp {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Cmp {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Cmp",
                        "rm",
                        &self.rm,
                        "ty",
                        &self.ty,
                        "imm2",
                        &self.imm2,
                        "imm3",
                        &self.imm3,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Cmp {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Cmp")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, ty, imm2, imm3, rn };
                    Ok(ret)
                }
            }
            /**Instruction Rsb from table A5_22

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- ty of type Shift from bit 4 to bit 5
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Rsb {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) ty: Shift,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rsb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "rm",
                        "ty",
                        "imm2",
                        "rd",
                        "imm3",
                        "rn",
                        "s",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.ty,
                        &self.imm2,
                        &self.rd,
                        &self.imm3,
                        &self.rn,
                        &&self.s,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Rsb",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Rsb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rsb")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ty: Shift = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        rm,
                        ty,
                        imm2,
                        rd,
                        imm3,
                        rn,
                        s,
                    };
                    Ok(ret)
                }
            }
            impl Parse for A5_22 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let rd: u32 = (word.mask::<8, 11>());
                    let rn: u32 = (word.mask::<16, 19>());
                    let s: bool = (word.mask::<20, 20>()).local_try_into()?;
                    let op: u32 = (word.mask::<21, 24>());
                    if op == 0 {
                        if rd == 0b1111 && !s {
                            return Err(ParseError::Unpredictable);
                        }
                        if rd != 0b1111 {
                            return Ok(Self::And(And::parse(iter)?));
                        }
                        if s {
                            return Ok(Self::Tst(Tst::parse(iter)?));
                        }
                    }
                    if op == 1 {
                        return Ok(Self::Bic(Bic::parse(iter)?));
                    }
                    if op == 2 {
                        if rn == 0b1111 {
                            return Ok(Self::SubtableA5_23(A5_23::parse(iter)?));
                        }
                        return Ok(Self::Orr(Orr::parse(iter)?));
                    }
                    if op == 3 {
                        if rn == 0b1111 {
                            return Ok(Self::Mvn(Mvn::parse(iter)?));
                        }
                        return Ok(Self::Orn(Orn::parse(iter)?));
                    }
                    if op == 4 {
                        if rd != 0b1111 {
                            return Ok(Self::Eor(Eor::parse(iter)?));
                        }
                        return match s {
                            true => Ok(Self::Teq(Teq::parse(iter)?)),
                            false => Err(ParseError::Unpredictable),
                        };
                    }
                    if op == 6 {
                        return Ok(Self::Pkh(Pkh::parse(iter)?));
                    }
                    if op == 0b1000 {
                        if rd != 0b1111 {
                            return Ok(Self::Add(Add::parse(iter)?));
                        }
                        if !s {
                            return Err(ParseError::Unpredictable);
                        }
                        return Ok(Self::Cmn(Cmn::parse(iter)?));
                    }
                    match op {
                        0b1010 => return Ok(Self::Adc(Adc::parse(iter)?)),
                        0b1011 => return Ok(Self::Sbc(Sbc::parse(iter)?)),
                        0b1110 => return Ok(Self::Rsb(Rsb::parse(iter)?)),
                        _ => {}
                    };
                    if op == 0b1101 {
                        if rd != 0b1111 {
                            return Ok(Self::Sub(Sub::parse(iter)?));
                        }
                        if !s {
                            return Err(ParseError::Unpredictable);
                        }
                        return Ok(Self::Cmp(Cmp::parse(iter)?));
                    }
                    Err(ParseError::Invalid32Bit("A5_22"))
                }
            }
            impl ToOperation for A5_22 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::And(el) => {
                            let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                            let shift = Some(
                                ImmShift::from((
                                    ty,
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    },
                                )),
                            );
                            operation::AndRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::Tst(el) => {
                            let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                            let shift = Some(
                                ImmShift::from((
                                    ty,
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    },
                                )),
                            );
                            operation::TstRegister::builder()
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::Bic(el) => {
                            let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                            let shift = Some(
                                ImmShift::from((
                                    ty,
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    },
                                )),
                            );
                            operation::BicRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::Orr(el) => {
                            let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                            let shift = Some(
                                ImmShift::from((
                                    ty,
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    },
                                )),
                            );
                            operation::OrrRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::SubtableA5_23(el) => el.encoding_specific_operations(),
                        Self::Orn(el) => {
                            operation::OrnRegister::builder()
                                .set_s(Some(el.s))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Mvn(el) => {
                            operation::MvnRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Eor(el) => {
                            operation::EorRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Teq(el) => {
                            operation::TeqRegister::builder()
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Pkh(el) => {
                            let (tb, _t, imm3, imm2) = (el.tb, el.t, el.imm3, el.imm2);
                            let ty = Shift::try_from((tb as u8) << 1).unwrap();
                            let shift = Some(
                                ImmShift::from((
                                    ty,
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    },
                                )),
                            );
                            operation::Pkh::builder()
                                .set_tb(tb)
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift(shift)
                                .complete()
                                .into()
                        }
                        Self::Add(el) => {
                            operation::AddRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Cmn(el) => {
                            operation::CmnRegister::builder()
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Adc(el) => {
                            operation::AdcRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Sbc(el) => {
                            operation::SbcRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Sub(el) => {
                            operation::SubRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Cmp(el) => {
                            operation::CmpRegister::builder()
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                        Self::Rsb(el) => {
                            operation::RsbRegister::builder()
                                .set_s(Some(el.s))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_shift({
                                    let (ty, imm3, imm2) = (el.ty, el.imm3, el.imm2);
                                    let shift = Some(
                                        ImmShift::from((
                                            ty,
                                            {
                                                let mut counter: usize = { 2 + 0 };
                                                let mut sum: u8 = (imm3 as u8) << counter;
                                                #[allow(unused_assignments)]
                                                {
                                                    counter -= 2;
                                                    sum |= ((imm2 as u8) << counter) as u8;
                                                }
                                                sum
                                            },
                                        )),
                                    );
                                    shift
                                })
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_23 {
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                combine, instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_23 {
                Mov(Mov),
                Lsl(Lsl),
                Lsr(Lsr),
                Asr(Asr),
                Rrx(Rrx),
                Ror(Ror),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_23 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_23::Mov(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mov",
                                &__self_0,
                            )
                        }
                        A5_23::Lsl(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Lsl",
                                &__self_0,
                            )
                        }
                        A5_23::Lsr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Lsr",
                                &__self_0,
                            )
                        }
                        A5_23::Asr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Asr",
                                &__self_0,
                            )
                        }
                        A5_23::Rrx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rrx",
                                &__self_0,
                            )
                        }
                        A5_23::Ror(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ror",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_23 {
                #[allow(dead_code)]
                pub(crate) fn parse_mov<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mov(Mov::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_lsl<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Lsl(Lsl::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_lsr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Lsr(Lsr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_asr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Asr(Asr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rrx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rrx(Rrx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ror<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ror(Ror::parse(iter)?))
                }
            }
            /**Instruction Mov from table A5_23

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Mov {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mov {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Mov",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Mov {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mov")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, s };
                    Ok(ret)
                }
            }
            /**Instruction Lsl from table A5_23

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Lsl {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Lsl {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Lsl",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Lsl {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Lsl")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rd, imm3, s };
                    Ok(ret)
                }
            }
            /**Instruction Lsr from table A5_23

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Lsr {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Lsr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Lsr",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Lsr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Lsr")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rd, imm3, s };
                    Ok(ret)
                }
            }
            /**Instruction Asr from table A5_23

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Asr {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Asr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Asr",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Asr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Asr")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rd, imm3, s };
                    Ok(ret)
                }
            }
            /**Instruction Rrx from table A5_23

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Rrx {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rrx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Rrx",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Rrx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rrx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, s };
                    Ok(ret)
                }
            }
            /**Instruction Ror from table A5_23

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- imm2 of type u8 from bit 6 to bit 7
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- imm3 of type u8 from bit 12 to bit 14
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Ror {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 6 to 7

*/
                pub(crate) imm2: u8,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 14

*/
                pub(crate) imm3: u8,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ror {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Ror",
                        "rm",
                        &self.rm,
                        "imm2",
                        &self.imm2,
                        "rd",
                        &self.rd,
                        "imm3",
                        &self.imm3,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Ror {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ror")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 7>() as u8)
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let imm3: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 14>() as u8)
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, imm2, rd, imm3, s };
                    Ok(ret)
                }
            }
            impl Parse for A5_23 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let ty = word.mask::<4, 5>();
                    let imm2 = word.mask::<6, 7>();
                    let imm3 = word.mask::<12, 14>();
                    match (ty, imm2, imm3) {
                        (0, 0, 0) => Ok(Self::Mov(Mov::parse(iter)?)),
                        (0, _, _) => Ok(Self::Lsl(Lsl::parse(iter)?)),
                        (1, _, _) => Ok(Self::Lsr(Lsr::parse(iter)?)),
                        (2, _, _) => Ok(Self::Asr(Asr::parse(iter)?)),
                        (3, 0, 0) => Ok(Self::Rrx(Rrx::parse(iter)?)),
                        (3, _, _) => Ok(Self::Ror(Ror::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_6")),
                    }
                }
            }
            impl ToOperation for A5_23 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Mov(el) => {
                            operation::MovRegister::builder()
                                .set_s(Some(el.s))
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Lsl(el) => {
                            let shift = ImmShift::from((
                                Shift::Lsl,
                                {
                                    let (imm3, imm2) = (el.imm3, el.imm2);
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    }
                                },
                            ));
                            operation::LslImmediate::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_imm(shift.shift_n)
                                .complete()
                                .into()
                        }
                        Self::Lsr(el) => {
                            let shift = ImmShift::from((
                                Shift::Lsr,
                                {
                                    let (imm3, imm2) = (el.imm3, el.imm2);
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    }
                                },
                            ));
                            operation::LsrImmediate::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_imm(shift.shift_n)
                                .complete()
                                .into()
                        }
                        Self::Asr(el) => {
                            let shift = ImmShift::from((
                                Shift::Asr,
                                {
                                    let (imm3, imm2) = (el.imm3, el.imm2);
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    }
                                },
                            ));
                            operation::AsrImmediate::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_imm(shift.shift_n as u32)
                                .complete()
                                .into()
                        }
                        Self::Rrx(el) => {
                            operation::Rrx::builder()
                                .set_s(Some(el.s))
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Ror(el) => {
                            let shift = ImmShift::from((
                                Shift::Ror,
                                {
                                    let (imm3, imm2) = (el.imm3, el.imm2);
                                    {
                                        let mut counter: usize = { 2 + 0 };
                                        let mut sum: u8 = (imm3 as u8) << counter;
                                        #[allow(unused_assignments)]
                                        {
                                            counter -= 2;
                                            sum |= ((imm2 as u8) << counter) as u8;
                                        }
                                        sum
                                    }
                                },
                            ));
                            operation::RorImmediate::builder()
                                .set_s(Some(el.s))
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_imm(shift.shift_n as u32)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_24 {
            use paste::paste;
            use super::{a5_25::A5_25, a5_26::A5_26, a5_27::A5_27};
            use crate::{
                arch::wrapper_types::*, asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_24 {
                Lsl(Lsl),
                Lsr(Lsr),
                Asr(Asr),
                Ror(Ror),
                Sxtah(Sxtah),
                Sxth(Sxth),
                Uxtah(Uxtah),
                Uxth(Uxth),
                Sxtab16(Sxtab16),
                Sxtb16(Sxtb16),
                Uxtab16(Uxtab16),
                Uxtb16(Uxtb16),
                Sxtab(Sxtab),
                Sxtb(Sxtb),
                Uxtab(Uxtab),
                Uxtb(Uxtb),
                ///Externally defined instruction or set of instructions [`A5_25`]
                SubtableA5_25(A5_25),
                ///Externally defined instruction or set of instructions [`A5_26`]
                SubtableA5_26(A5_26),
                ///Externally defined instruction or set of instructions [`A5_27`]
                SubtableA5_27(A5_27),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_24 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_24::Lsl(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Lsl",
                                &__self_0,
                            )
                        }
                        A5_24::Lsr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Lsr",
                                &__self_0,
                            )
                        }
                        A5_24::Asr(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Asr",
                                &__self_0,
                            )
                        }
                        A5_24::Ror(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ror",
                                &__self_0,
                            )
                        }
                        A5_24::Sxtah(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sxtah",
                                &__self_0,
                            )
                        }
                        A5_24::Sxth(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sxth",
                                &__self_0,
                            )
                        }
                        A5_24::Uxtah(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uxtah",
                                &__self_0,
                            )
                        }
                        A5_24::Uxth(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uxth",
                                &__self_0,
                            )
                        }
                        A5_24::Sxtab16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sxtab16",
                                &__self_0,
                            )
                        }
                        A5_24::Sxtb16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sxtb16",
                                &__self_0,
                            )
                        }
                        A5_24::Uxtab16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uxtab16",
                                &__self_0,
                            )
                        }
                        A5_24::Uxtb16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uxtb16",
                                &__self_0,
                            )
                        }
                        A5_24::Sxtab(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sxtab",
                                &__self_0,
                            )
                        }
                        A5_24::Sxtb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sxtb",
                                &__self_0,
                            )
                        }
                        A5_24::Uxtab(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uxtab",
                                &__self_0,
                            )
                        }
                        A5_24::Uxtb(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uxtb",
                                &__self_0,
                            )
                        }
                        A5_24::SubtableA5_25(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubtableA5_25",
                                &__self_0,
                            )
                        }
                        A5_24::SubtableA5_26(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubtableA5_26",
                                &__self_0,
                            )
                        }
                        A5_24::SubtableA5_27(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SubtableA5_27",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_24 {
                #[allow(dead_code)]
                pub(crate) fn parse_lsl<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Lsl(Lsl::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_lsr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Lsr(Lsr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_asr<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Asr(Asr::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ror<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ror(Ror::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sxtah<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sxtah(Sxtah::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sxth<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sxth(Sxth::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uxtah<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uxtah(Uxtah::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uxth<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uxth(Uxth::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sxtab16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sxtab16(Sxtab16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sxtb16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sxtb16(Sxtb16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uxtab16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uxtab16(Uxtab16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uxtb16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uxtb16(Uxtb16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sxtab<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sxtab(Sxtab::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sxtb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sxtb(Sxtb::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uxtab<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uxtab(Uxtab::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uxtb<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uxtb(Uxtb::parse(iter)?))
                }
            }
            /**Instruction Lsl from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Lsl {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Lsl {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Lsl",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &self.rn,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Lsl {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Lsl")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn, s };
                    Ok(ret)
                }
            }
            /**Instruction Lsr from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Lsr {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Lsr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Lsr",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &self.rn,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Lsr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Lsr")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn, s };
                    Ok(ret)
                }
            }
            /**Instruction Asr from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Asr {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Asr {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Asr",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &self.rn,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Asr {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Asr")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn, s };
                    Ok(ret)
                }
            }
            /**Instruction Ror from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- s of type bool from bit 20 to bit 20
*/
            pub struct Ror {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 20 to 20

*/
                pub(crate) s: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ror {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Ror",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &self.rn,
                        "s",
                        &&self.s,
                    )
                }
            }
            impl Parse for Ror {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ror")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let s: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 20>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn, s };
                    Ok(ret)
                }
            }
            /**Instruction Sxtah from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sxtah {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sxtah {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Sxtah",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sxtah {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sxtah")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Sxth from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Sxth {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sxth {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sxth",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Sxth {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sxth")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd };
                    Ok(ret)
                }
            }
            /**Instruction Uxtah from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uxtah {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uxtah {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Uxtah",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uxtah {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uxtah")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uxth from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Uxth {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uxth {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uxth",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Uxth {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uxth")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd };
                    Ok(ret)
                }
            }
            /**Instruction Sxtab16 from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sxtab16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sxtab16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Sxtab16",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sxtab16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sxtab16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Sxtb16 from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Sxtb16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sxtb16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sxtb16",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Sxtb16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sxtb16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd };
                    Ok(ret)
                }
            }
            /**Instruction Uxtab16 from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uxtab16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uxtab16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Uxtab16",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uxtab16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uxtab16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uxtb16 from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Uxtb16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uxtb16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uxtb16",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Uxtb16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uxtb16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd };
                    Ok(ret)
                }
            }
            /**Instruction Sxtab from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sxtab {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sxtab {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Sxtab",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sxtab {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sxtab")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Sxtb from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Sxtb {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sxtb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sxtb",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Sxtb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sxtb")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd };
                    Ok(ret)
                }
            }
            /**Instruction Uxtab from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uxtab {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uxtab {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Uxtab",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uxtab {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uxtab")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uxtb from table A5_24

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rotate of type Imm2 from bit 4 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Uxtb {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 5

*/
                pub(crate) rotate: Imm2,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uxtb {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uxtb",
                        "rm",
                        &self.rm,
                        "rotate",
                        &self.rotate,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Uxtb {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uxtb")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rotate: Imm2 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 5>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rotate, rd };
                    Ok(ret)
                }
            }
            impl Parse for A5_24 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = iter.next()?;
                    let op2 = word.mask::<4, 7>();
                    let rn = word.mask::<16, 19>();
                    let op1 = word.mask::<20, 23>();
                    match (op1 >> 1, op2) {
                        (0b000, 0) => return Ok(Self::Lsl(Lsl::parse(iter)?)),
                        (0b001, 0) => return Ok(Self::Lsr(Lsr::parse(iter)?)),
                        (0b010, 0) => return Ok(Self::Asr(Asr::parse(iter)?)),
                        (0b011, 0) => return Ok(Self::Ror(Ror::parse(iter)?)),
                        _ => {}
                    };
                    if op2 >> 3 == 1 {
                        match (op1, rn == 0b1111) {
                            (0b0000, false) => {
                                return Ok(Self::Sxtah(Sxtah::parse(iter)?));
                            }
                            (0b0000, true) => return Ok(Self::Sxth(Sxth::parse(iter)?)),
                            (0b0001, false) => {
                                return Ok(Self::Uxtah(Uxtah::parse(iter)?));
                            }
                            (0b0001, true) => return Ok(Self::Uxth(Uxth::parse(iter)?)),
                            (0b0010, false) => {
                                return Ok(Self::Sxtab16(Sxtab16::parse(iter)?));
                            }
                            (0b0010, true) => {
                                return Ok(Self::Sxtb16(Sxtb16::parse(iter)?));
                            }
                            (0b0011, false) => {
                                return Ok(Self::Uxtab16(Uxtab16::parse(iter)?));
                            }
                            (0b0011, true) => {
                                return Ok(Self::Uxtb16(Uxtb16::parse(iter)?));
                            }
                            (0b0100, false) => {
                                return Ok(Self::Sxtab(Sxtab::parse(iter)?));
                            }
                            (0b0100, true) => return Ok(Self::Sxtb(Sxtb::parse(iter)?)),
                            (0b0101, false) => {
                                return Ok(Self::Uxtab(Uxtab::parse(iter)?));
                            }
                            (0b0101, true) => return Ok(Self::Uxtb(Uxtb::parse(iter)?)),
                            _ => {}
                        }
                    }
                    if op1 >> 3 == 1 {
                        match op2 >> 2 {
                            0 => return Ok(Self::SubtableA5_25(A5_25::parse(iter)?)),
                            1 => return Ok(Self::SubtableA5_26(A5_26::parse(iter)?)),
                            _ => {}
                        }
                    }
                    if op1 >> 2 == 2 && op2 >> 2 == 2 {
                        return Ok(Self::SubtableA5_27(A5_27::parse(iter)?));
                    }
                    Err(ParseError::Invalid32Bit("A5_24"))
                }
            }
            impl ToOperation for A5_24 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Lsl(el) => {
                            operation::LslRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Lsr(el) => {
                            operation::LsrRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Asr(el) => {
                            operation::AsrRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Ror(el) => {
                            operation::RorRegister::builder()
                                .set_s(Some(el.s.into()))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Sxtah(el) => {
                            operation::Sxtah::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Sxth(el) => {
                            operation::Sxth::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Uxtah(el) => {
                            operation::Uxtah::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Uxth(el) => {
                            operation::Uxth::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Sxtab16(el) => {
                            operation::Sxtab16::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Sxtb16(el) => {
                            operation::Sxtb16::builder()
                                .set_rd(Some(el.rd))
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Uxtab16(el) => {
                            operation::Uxtab16::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Uxtb16(el) => {
                            operation::Uxtb16::builder()
                                .set_rd(Some(el.rd))
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Sxtab(el) => {
                            operation::Sxtab::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Sxtb(el) => {
                            operation::Sxtb::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Uxtab(el) => {
                            operation::Uxtab::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::Uxtb(el) => {
                            operation::Uxtb::builder()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .set_rotation(
                                    Some(<arch::Imm2 as Into<u32>>::into(el.rotate) << 3),
                                )
                                .complete()
                                .into()
                        }
                        Self::SubtableA5_25(el) => el.encoding_specific_operations(),
                        Self::SubtableA5_26(el) => el.encoding_specific_operations(),
                        Self::SubtableA5_27(el) => el.encoding_specific_operations(),
                    }
                }
            }
        }
        pub mod a5_25 {
            use paste::paste;
            use crate::{asm::Mask, instruction, prelude::*, ParseError, ToOperation};
            pub enum A5_25 {
                Sadd16(Sadd16),
                Sasx(Sasx),
                Ssax(Ssax),
                Ssub16(Ssub16),
                Sadd8(Sadd8),
                Ssub8(Ssub8),
                Qadd16(Qadd16),
                Qasx(Qasx),
                Qsax(Qsax),
                Qsub16(Qsub16),
                Qadd8(Qadd8),
                Qsub8(Qsub8),
                Shadd16(Shadd16),
                Shasx(Shasx),
                Shsax(Shsax),
                Shsub16(Shsub16),
                Shadd8(Shadd8),
                Shsub8(Shsub8),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_25 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_25::Sadd16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sadd16",
                                &__self_0,
                            )
                        }
                        A5_25::Sasx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sasx",
                                &__self_0,
                            )
                        }
                        A5_25::Ssax(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ssax",
                                &__self_0,
                            )
                        }
                        A5_25::Ssub16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ssub16",
                                &__self_0,
                            )
                        }
                        A5_25::Sadd8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sadd8",
                                &__self_0,
                            )
                        }
                        A5_25::Ssub8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ssub8",
                                &__self_0,
                            )
                        }
                        A5_25::Qadd16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qadd16",
                                &__self_0,
                            )
                        }
                        A5_25::Qasx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qasx",
                                &__self_0,
                            )
                        }
                        A5_25::Qsax(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qsax",
                                &__self_0,
                            )
                        }
                        A5_25::Qsub16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qsub16",
                                &__self_0,
                            )
                        }
                        A5_25::Qadd8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qadd8",
                                &__self_0,
                            )
                        }
                        A5_25::Qsub8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qsub8",
                                &__self_0,
                            )
                        }
                        A5_25::Shadd16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Shadd16",
                                &__self_0,
                            )
                        }
                        A5_25::Shasx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Shasx",
                                &__self_0,
                            )
                        }
                        A5_25::Shsax(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Shsax",
                                &__self_0,
                            )
                        }
                        A5_25::Shsub16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Shsub16",
                                &__self_0,
                            )
                        }
                        A5_25::Shadd8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Shadd8",
                                &__self_0,
                            )
                        }
                        A5_25::Shsub8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Shsub8",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_25 {
                #[allow(dead_code)]
                pub(crate) fn parse_sadd16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sadd16(Sadd16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sasx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sasx(Sasx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ssax<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ssax(Ssax::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ssub16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ssub16(Ssub16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sadd8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sadd8(Sadd8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ssub8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Ssub8(Ssub8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qadd16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qadd16(Qadd16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qasx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qasx(Qasx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qsax<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qsax(Qsax::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qsub16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qsub16(Qsub16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qadd8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qadd8(Qadd8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qsub8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qsub8(Qsub8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_shadd16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Shadd16(Shadd16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_shasx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Shasx(Shasx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_shsax<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Shsax(Shsax::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_shsub16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Shsub16(Shsub16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_shadd8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Shadd8(Shadd8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_shsub8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Shsub8(Shsub8::parse(iter)?))
                }
            }
            /**Instruction Sadd16 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sadd16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sadd16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sadd16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sadd16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sadd16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Sasx from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sasx {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sasx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sasx",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sasx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sasx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ssax from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ssax {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ssax {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ssax",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ssax {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ssax")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ssub16 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ssub16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ssub16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ssub16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ssub16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ssub16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Sadd8 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sadd8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sadd8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sadd8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sadd8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sadd8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Ssub8 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Ssub8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Ssub8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Ssub8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Ssub8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Ssub8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qadd16 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qadd16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qadd16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qadd16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qadd16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qadd16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qasx from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qasx {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qasx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qasx",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qasx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qasx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qsax from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qsax {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qsax {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qsax",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qsax {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qsax")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qsub16 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qsub16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qsub16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qsub16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qsub16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qsub16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qadd8 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qadd8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qadd8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qadd8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qadd8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qadd8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qsub8 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qsub8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qsub8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qsub8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qsub8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qsub8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Shadd16 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Shadd16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Shadd16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Shadd16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Shadd16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Shadd16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Shasx from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Shasx {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Shasx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Shasx",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Shasx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Shasx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Shsax from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Shsax {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Shsax {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Shsax",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Shsax {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Shsax")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Shsub16 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Shsub16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Shsub16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Shsub16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Shsub16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Shsub16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Shadd8 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Shadd8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Shadd8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Shadd8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Shadd8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Shadd8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Shsub8 from table A5_25

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Shsub8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Shsub8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Shsub8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Shsub8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Shsub8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            impl Parse for A5_25 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op1 = word.mask::<20, 22>();
                    let op2 = word.mask::<4, 5>();
                    match (op1, op2) {
                        (0b001, 0b00) => Ok(Self::Sadd16(Sadd16::parse(iter)?)),
                        (0b010, 0b00) => Ok(Self::Sasx(Sasx::parse(iter)?)),
                        (0b110, 0b00) => Ok(Self::Ssax(Ssax::parse(iter)?)),
                        (0b101, 0b00) => Ok(Self::Ssub16(Ssub16::parse(iter)?)),
                        (0b000, 0b00) => Ok(Self::Sadd8(Sadd8::parse(iter)?)),
                        (0b100, 0b00) => Ok(Self::Ssub8(Ssub8::parse(iter)?)),
                        (0b001, 0b01) => Ok(Self::Qadd16(Qadd16::parse(iter)?)),
                        (0b010, 0b01) => Ok(Self::Qasx(Qasx::parse(iter)?)),
                        (0b110, 0b01) => Ok(Self::Qsax(Qsax::parse(iter)?)),
                        (0b101, 0b01) => Ok(Self::Qsub16(Qsub16::parse(iter)?)),
                        (0b000, 0b01) => Ok(Self::Qadd8(Qadd8::parse(iter)?)),
                        (0b100, 0b01) => Ok(Self::Qsub8(Qsub8::parse(iter)?)),
                        (0b001, 0b10) => Ok(Self::Shadd16(Shadd16::parse(iter)?)),
                        (0b010, 0b10) => Ok(Self::Shasx(Shasx::parse(iter)?)),
                        (0b110, 0b10) => Ok(Self::Shsax(Shsax::parse(iter)?)),
                        (0b101, 0b10) => Ok(Self::Shsub16(Shsub16::parse(iter)?)),
                        (0b000, 0b10) => Ok(Self::Shadd8(Shadd8::parse(iter)?)),
                        (0b100, 0b10) => Ok(Self::Shsub8(Shsub8::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_25")),
                    }
                }
            }
            impl ToOperation for A5_25 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Sadd16(el) => {
                            operation::Sadd16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Sasx(el) => {
                            operation::SasxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Ssax(el) => {
                            operation::SsaxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Ssub16(el) => {
                            operation::Ssub16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Sadd8(el) => {
                            operation::Sadd8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Ssub8(el) => {
                            operation::Ssub8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Qadd16(el) => {
                            operation::Qadd16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Qasx(el) => {
                            operation::QasxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Qsax(el) => {
                            operation::QsaxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Qsub16(el) => {
                            operation::Qsub16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Qadd8(el) => {
                            operation::Qadd8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Qsub8(el) => {
                            operation::Qsub8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Shadd16(el) => {
                            operation::Shadd16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Shasx(el) => {
                            operation::ShasxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Shsax(el) => {
                            operation::ShsaxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Shsub16(el) => {
                            operation::Shsub16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Shadd8(el) => {
                            operation::Shadd8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Shsub8(el) => {
                            operation::Shsub8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_26 {
            use paste::paste;
            use crate::{asm::Mask, instruction, prelude::*, ParseError, ToOperation};
            pub enum A5_26 {
                Uadd16(Uadd16),
                Uasx(Uasx),
                Usax(Usax),
                Usub16(Usub16),
                Uadd8(Uadd8),
                Usub8(Usub8),
                Uqadd16(Uqadd16),
                Uqasx(Uqasx),
                Uqsax(Uqsax),
                Uqsub16(Uqsub16),
                Uqadd8(Uqadd8),
                Uqsub8(Uqsub8),
                Uhadd16(Uhadd16),
                Uhasx(Uhasx),
                Uhsax(Uhsax),
                Uhsub16(Uhsub16),
                Uhadd8(Uhadd8),
                Uhsub8(Uhsub8),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_26 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_26::Uadd16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uadd16",
                                &__self_0,
                            )
                        }
                        A5_26::Uasx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uasx",
                                &__self_0,
                            )
                        }
                        A5_26::Usax(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usax",
                                &__self_0,
                            )
                        }
                        A5_26::Usub16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usub16",
                                &__self_0,
                            )
                        }
                        A5_26::Uadd8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uadd8",
                                &__self_0,
                            )
                        }
                        A5_26::Usub8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usub8",
                                &__self_0,
                            )
                        }
                        A5_26::Uqadd16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uqadd16",
                                &__self_0,
                            )
                        }
                        A5_26::Uqasx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uqasx",
                                &__self_0,
                            )
                        }
                        A5_26::Uqsax(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uqsax",
                                &__self_0,
                            )
                        }
                        A5_26::Uqsub16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uqsub16",
                                &__self_0,
                            )
                        }
                        A5_26::Uqadd8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uqadd8",
                                &__self_0,
                            )
                        }
                        A5_26::Uqsub8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uqsub8",
                                &__self_0,
                            )
                        }
                        A5_26::Uhadd16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uhadd16",
                                &__self_0,
                            )
                        }
                        A5_26::Uhasx(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uhasx",
                                &__self_0,
                            )
                        }
                        A5_26::Uhsax(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uhsax",
                                &__self_0,
                            )
                        }
                        A5_26::Uhsub16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uhsub16",
                                &__self_0,
                            )
                        }
                        A5_26::Uhadd8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uhadd8",
                                &__self_0,
                            )
                        }
                        A5_26::Uhsub8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uhsub8",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_26 {
                #[allow(dead_code)]
                pub(crate) fn parse_uadd16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uadd16(Uadd16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uasx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uasx(Uasx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_usax<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Usax(Usax::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_usub16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Usub16(Usub16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uadd8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uadd8(Uadd8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_usub8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Usub8(Usub8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uqadd16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uqadd16(Uqadd16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uqasx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uqasx(Uqasx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uqsax<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uqsax(Uqsax::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uqsub16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uqsub16(Uqsub16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uqadd8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uqadd8(Uqadd8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uqsub8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uqsub8(Uqsub8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uhadd16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uhadd16(Uhadd16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uhasx<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uhasx(Uhasx::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uhsax<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uhsax(Uhsax::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uhsub16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uhsub16(Uhsub16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uhadd8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uhadd8(Uhadd8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_uhsub8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Uhsub8(Uhsub8::parse(iter)?))
                }
            }
            /**Instruction Uadd16 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uadd16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uadd16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uadd16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uadd16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uadd16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uasx from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uasx {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uasx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uasx",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uasx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uasx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Usax from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Usax {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Usax {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Usax",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Usax {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Usax")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Usub16 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Usub16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Usub16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Usub16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Usub16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Usub16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uadd8 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uadd8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uadd8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uadd8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uadd8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uadd8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Usub8 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Usub8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Usub8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Usub8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Usub8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Usub8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uqadd16 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uqadd16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uqadd16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uqadd16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uqadd16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uqadd16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uqasx from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uqasx {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uqasx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uqasx",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uqasx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uqasx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uqsax from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uqsax {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uqsax {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uqsax",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uqsax {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uqsax")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uqsub16 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uqsub16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uqsub16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uqsub16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uqsub16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uqsub16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uqadd8 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uqadd8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uqadd8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uqadd8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uqadd8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uqadd8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uqsub8 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uqsub8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uqsub8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uqsub8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uqsub8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uqsub8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uhadd16 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uhadd16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uhadd16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uhadd16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uhadd16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uhadd16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uhasx from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uhasx {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uhasx {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uhasx",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uhasx {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uhasx")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uhsax from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uhsax {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uhsax {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uhsax",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uhsax {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uhsax")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uhsub16 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uhsub16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uhsub16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uhsub16",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uhsub16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uhsub16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uhadd8 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uhadd8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uhadd8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uhadd8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uhadd8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uhadd8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Uhsub8 from table A5_26

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Uhsub8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Uhsub8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Uhsub8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Uhsub8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Uhsub8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            impl Parse for A5_26 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op1 = word.mask::<20, 22>();
                    let op2 = word.mask::<4, 5>();
                    match (op1, op2) {
                        (0b001, 0b00) => Ok(Self::Uadd16(Uadd16::parse(iter)?)),
                        (0b010, 0b00) => Ok(Self::Uasx(Uasx::parse(iter)?)),
                        (0b110, 0b00) => Ok(Self::Usax(Usax::parse(iter)?)),
                        (0b101, 0b00) => Ok(Self::Usub16(Usub16::parse(iter)?)),
                        (0b000, 0b00) => Ok(Self::Uadd8(Uadd8::parse(iter)?)),
                        (0b100, 0b00) => Ok(Self::Usub8(Usub8::parse(iter)?)),
                        (0b001, 0b01) => Ok(Self::Uqadd16(Uqadd16::parse(iter)?)),
                        (0b010, 0b01) => Ok(Self::Uqasx(Uqasx::parse(iter)?)),
                        (0b110, 0b01) => Ok(Self::Uqsax(Uqsax::parse(iter)?)),
                        (0b101, 0b01) => Ok(Self::Uqsub16(Uqsub16::parse(iter)?)),
                        (0b000, 0b01) => Ok(Self::Uqadd8(Uqadd8::parse(iter)?)),
                        (0b100, 0b01) => Ok(Self::Uqsub8(Uqsub8::parse(iter)?)),
                        (0b001, 0b10) => Ok(Self::Uhadd16(Uhadd16::parse(iter)?)),
                        (0b010, 0b10) => Ok(Self::Uhasx(Uhasx::parse(iter)?)),
                        (0b110, 0b10) => Ok(Self::Uhsax(Uhsax::parse(iter)?)),
                        (0b101, 0b10) => Ok(Self::Uhsub16(Uhsub16::parse(iter)?)),
                        (0b000, 0b10) => Ok(Self::Uhadd8(Uhadd8::parse(iter)?)),
                        (0b100, 0b10) => Ok(Self::Uhsub8(Uhsub8::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_25")),
                    }
                }
            }
            impl ToOperation for A5_26 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Uadd16(el) => {
                            operation::Uadd16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uasx(el) => {
                            operation::UasxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Usax(el) => {
                            operation::UsaxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Usub16(el) => {
                            operation::Usub16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uadd8(el) => {
                            operation::Uadd8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Usub8(el) => {
                            operation::Usub8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uqadd16(el) => {
                            operation::Uqadd16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uqasx(el) => {
                            operation::UqasxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uqsax(el) => {
                            operation::UqsaxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uqsub16(el) => {
                            operation::Uqsub16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uqadd8(el) => {
                            operation::Uqadd8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uqsub8(el) => {
                            operation::Uqsub8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uhadd16(el) => {
                            operation::Uhadd16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uhasx(el) => {
                            operation::UhasxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uhsax(el) => {
                            operation::UhsaxBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uhsub16(el) => {
                            operation::Uhsub16Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uhadd8(el) => {
                            operation::Uhadd8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Uhsub8(el) => {
                            operation::Uhsub8Builder::new()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_27 {
            use paste::paste;
            use crate::{asm::Mask, instruction, prelude::*, ParseError, ToOperation};
            pub enum A5_27 {
                Qadd(Qadd),
                Qdadd(Qdadd),
                Qsub(Qsub),
                Qdsub(Qdsub),
                Rev(Rev),
                Rev16(Rev16),
                Rbit(Rbit),
                Revsh(Revsh),
                Sel(Sel),
                Clz(Clz),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_27 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_27::Qadd(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qadd",
                                &__self_0,
                            )
                        }
                        A5_27::Qdadd(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qdadd",
                                &__self_0,
                            )
                        }
                        A5_27::Qsub(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qsub",
                                &__self_0,
                            )
                        }
                        A5_27::Qdsub(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Qdsub",
                                &__self_0,
                            )
                        }
                        A5_27::Rev(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rev",
                                &__self_0,
                            )
                        }
                        A5_27::Rev16(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rev16",
                                &__self_0,
                            )
                        }
                        A5_27::Rbit(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Rbit",
                                &__self_0,
                            )
                        }
                        A5_27::Revsh(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Revsh",
                                &__self_0,
                            )
                        }
                        A5_27::Sel(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sel",
                                &__self_0,
                            )
                        }
                        A5_27::Clz(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Clz",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_27 {
                #[allow(dead_code)]
                pub(crate) fn parse_qadd<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qadd(Qadd::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qdadd<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qdadd(Qdadd::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qsub<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qsub(Qsub::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_qdsub<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Qdsub(Qdsub::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rev<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rev(Rev::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rev16<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rev16(Rev16::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_rbit<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Rbit(Rbit::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_revsh<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Revsh(Revsh::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sel<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sel(Sel::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_clz<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Clz(Clz::parse(iter)?))
                }
            }
            /**Instruction Qadd from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qadd {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qadd {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qadd",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qadd {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qadd")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qdadd from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qdadd {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qdadd {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qdadd",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qdadd {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qdadd")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qsub from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qsub {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qsub {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qsub",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qsub {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qsub")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Qdsub from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Qdsub {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Qdsub {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Qdsub",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Qdsub {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Qdsub")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Rev from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Rev {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rev {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Rev",
                        "rm",
                        &self.rm,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Rev {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rev")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd };
                    Ok(ret)
                }
            }
            /**Instruction Rev16 from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Rev16 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rev16 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Rev16",
                        "rm",
                        &self.rm,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Rev16 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rev16")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd };
                    Ok(ret)
                }
            }
            /**Instruction Rbit from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Rbit {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Rbit {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Rbit",
                        "rm",
                        &self.rm,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Rbit {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Rbit")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd };
                    Ok(ret)
                }
            }
            /**Instruction Revsh from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Revsh {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Revsh {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Revsh",
                        "rm",
                        &self.rm,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Revsh {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Revsh")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd };
                    Ok(ret)
                }
            }
            /**Instruction Sel from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sel {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sel {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sel",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sel {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sel")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Clz from table A5_27

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            pub struct Clz {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Clz {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Clz",
                        "rm",
                        &self.rm,
                        "rd",
                        &&self.rd,
                    )
                }
            }
            impl Parse for Clz {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Clz")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd };
                    Ok(ret)
                }
            }
            impl Parse for A5_27 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => Ok(word),
                        None => Err(ParseError::IncompleteProgram),
                    }?;
                    let op1 = word.mask::<20, 21>();
                    let op2 = word.mask::<4, 5>();
                    if op1 == 0b11 {
                        if op2 == 0 {
                            return Ok(Self::Clz(Clz::parse(iter)?));
                        }
                        return Err(ParseError::Invalid32Bit("A5_27"));
                    }
                    if op1 == 0b10 {
                        if op2 == 0 {
                            return Ok(Self::Sel(Sel::parse(iter)?));
                        }
                        return Err(ParseError::Invalid32Bit("A5_27"));
                    }
                    if op1 == 0b01 {
                        return Ok(
                            match op2 {
                                0b00 => Self::Rev(Rev::parse(iter)?),
                                0b01 => Self::Rev16(Rev16::parse(iter)?),
                                0b10 => Self::Rbit(Rbit::parse(iter)?),
                                0b11 => Self::Revsh(Revsh::parse(iter)?),
                                _ => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "internal error: entered unreachable code: {0}",
                                            format_args!("masking malfunction"),
                                        ),
                                    );
                                }
                            },
                        );
                    }
                    Ok(
                        match op2 {
                            0b00 => Self::Qadd(Qadd::parse(iter)?),
                            0b01 => Self::Qdadd(Qdadd::parse(iter)?),
                            0b10 => Self::Qsub(Qsub::parse(iter)?),
                            0b11 => Self::Qdsub(Qdsub::parse(iter)?),
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("masking malfunctioned"),
                                    ),
                                );
                            }
                        },
                    )
                }
            }
            impl ToOperation for A5_27 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    use A5_27::*;
                    match self {
                        Qadd(el) => {
                            operation::QaddBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rm(el.rm)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                        Qdadd(el) => {
                            operation::QdaddBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rm(el.rm)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                        Qsub(el) => {
                            operation::QsubBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rm(el.rm)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                        Qdsub(el) => {
                            operation::QdsubBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rm(el.rm)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                        Sel(el) => {
                            operation::SelBuilder::new()
                                .set_rd(Some(el.rd))
                                .set_rm(el.rm)
                                .set_rn(el.rn)
                                .complete()
                                .into()
                        }
                        Rev(el) => {
                            operation::RevBuilder::new()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Rev16(el) => {
                            operation::Rev16Builder::new()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Rbit(el) => {
                            operation::RbitBuilder::new()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Revsh(el) => {
                            operation::RevshBuilder::new()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Clz(el) => {
                            operation::ClzBuilder::new()
                                .set_rd(el.rd)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_28 {
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_28 {
                Mla(Mla),
                Mul(Mul),
                Mls(Mls),
                Smla(Smla),
                Smul(Smul),
                Smlad(Smlad),
                Smuad(Smuad),
                Smlaw(Smlaw),
                Smulw(Smulw),
                Smlsd(Smlsd),
                Smusd(Smusd),
                Smmla(Smmla),
                Smmul(Smmul),
                Smmls(Smmls),
                Usada8(Usada8),
                Usad8(Usad8),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_28 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_28::Mla(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mla",
                                &__self_0,
                            )
                        }
                        A5_28::Mul(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mul",
                                &__self_0,
                            )
                        }
                        A5_28::Mls(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Mls",
                                &__self_0,
                            )
                        }
                        A5_28::Smla(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smla",
                                &__self_0,
                            )
                        }
                        A5_28::Smul(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smul",
                                &__self_0,
                            )
                        }
                        A5_28::Smlad(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smlad",
                                &__self_0,
                            )
                        }
                        A5_28::Smuad(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smuad",
                                &__self_0,
                            )
                        }
                        A5_28::Smlaw(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smlaw",
                                &__self_0,
                            )
                        }
                        A5_28::Smulw(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smulw",
                                &__self_0,
                            )
                        }
                        A5_28::Smlsd(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smlsd",
                                &__self_0,
                            )
                        }
                        A5_28::Smusd(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smusd",
                                &__self_0,
                            )
                        }
                        A5_28::Smmla(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smmla",
                                &__self_0,
                            )
                        }
                        A5_28::Smmul(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smmul",
                                &__self_0,
                            )
                        }
                        A5_28::Smmls(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smmls",
                                &__self_0,
                            )
                        }
                        A5_28::Usada8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usada8",
                                &__self_0,
                            )
                        }
                        A5_28::Usad8(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usad8",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_28 {
                #[allow(dead_code)]
                pub(crate) fn parse_mla<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mla(Mla::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mul<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mul(Mul::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mls<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Mls(Mls::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smla<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smla(Smla::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smul<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smul(Smul::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smlad<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smlad(Smlad::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smuad<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smuad(Smuad::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smlaw<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smlaw(Smlaw::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smulw<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smulw(Smulw::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smlsd<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smlsd(Smlsd::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smusd<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smusd(Smusd::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smmla<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smmla(Smmla::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smmul<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smmul(Smmul::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smmls<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smmls(Smmls::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_usada8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Usada8(Usada8::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_usad8<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Usad8(Usad8::parse(iter)?))
                }
            }
            /**Instruction Mla from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Mla {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mla {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Mla",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "ra",
                        &self.ra,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Mla {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mla")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Mul from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Mul {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mul {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Mul",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Mul {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mul")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Mls from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Mls {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Mls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Mls",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "ra",
                        &self.ra,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Mls {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Mls")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smla from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- n of type bool from bit 5 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smla {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 5 to 5

*/
                pub(crate) n: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smla {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["rm", "m", "n", "rd", "ra", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.m,
                        &self.n,
                        &self.rd,
                        &self.ra,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Smla",
                        names,
                        values,
                    )
                }
            }
            impl Parse for Smla {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smla")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, n, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smul from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- n of type bool from bit 5 to bit 5
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smul {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 5 to 5

*/
                pub(crate) n: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smul {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Smul",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "n",
                        &self.n,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smul {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smul")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, n, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smlad from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smlad {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smlad {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Smlad",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "rd",
                        &self.rd,
                        "ra",
                        &self.ra,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smlad {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smlad")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smuad from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smuad {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smuad {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Smuad",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smuad {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smuad")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smlaw from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smlaw {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smlaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Smlaw",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "rd",
                        &self.rd,
                        "ra",
                        &self.ra,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smlaw {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smlaw")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smulw from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smulw {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smulw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Smulw",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smulw {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smulw")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smlsd from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smlsd {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smlsd {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Smlsd",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "rd",
                        &self.rd,
                        "ra",
                        &self.ra,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smlsd {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smlsd")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smusd from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smusd {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smusd {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Smusd",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smusd {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smusd")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smmla from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- r of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smmla {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) r: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smmla {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Smmla",
                        "rm",
                        &self.rm,
                        "r",
                        &self.r,
                        "rd",
                        &self.rd,
                        "ra",
                        &self.ra,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smmla {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smmla")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let r: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, r, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smmul from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- r of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smmul {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) r: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smmul {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Smmul",
                        "rm",
                        &self.rm,
                        "r",
                        &self.r,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smmul {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smmul")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let r: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, r, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smmls from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- r of type bool from bit 4 to bit 4
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smmls {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) r: bool,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smmls {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Smmls",
                        "rm",
                        &self.rm,
                        "r",
                        &self.r,
                        "rd",
                        &self.rd,
                        "ra",
                        &self.ra,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smmls {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smmls")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let r: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, r, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Usada8 from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- ra of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Usada8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 12 to 15

*/
                pub(crate) ra: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Usada8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Usada8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "ra",
                        &self.ra,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Usada8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Usada8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ra: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, ra, rn };
                    Ok(ret)
                }
            }
            /**Instruction Usad8 from table A5_28

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Usad8 {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Usad8 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Usad8",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Usad8 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Usad8")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            impl Parse for A5_28 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = iter.next()?;
                    let op2 = word.mask::<4, 5>();
                    let ra = word.mask::<12, 15>();
                    let op1 = word.mask::<20, 22>();
                    match (op1, op2, ra) {
                        (0b000, 0, 0b1111) => Ok(Self::Mul(Mul::parse(iter)?)),
                        (0b000, 0, _) => Ok(Self::Mla(Mla::parse(iter)?)),
                        (0b000, 1, _) => Ok(Self::Mls(Mls::parse(iter)?)),
                        (0b001, _, 0b1111) => Ok(Self::Smul(Smul::parse(iter)?)),
                        (0b001, _, _) => Ok(Self::Smla(Smla::parse(iter)?)),
                        (0b010, 0, 0b1111) | (0b010, 1, 0b1111) => {
                            Ok(Self::Smuad(Smuad::parse(iter)?))
                        }
                        (0b010, 0, _) | (0b010, 1, _) => {
                            Ok(Self::Smlad(Smlad::parse(iter)?))
                        }
                        (0b011, 0, 0b1111) | (0b011, 1, 0b1111) => {
                            Ok(Self::Smulw(Smulw::parse(iter)?))
                        }
                        (0b011, 0, _) | (0b011, 1, _) => {
                            Ok(Self::Smlaw(Smlaw::parse(iter)?))
                        }
                        (0b100, 0, 0b1111) | (0b100, 1, 0b1111) => {
                            Ok(Self::Smusd(Smusd::parse(iter)?))
                        }
                        (0b100, 0, _) | (0b100, 1, _) => {
                            Ok(Self::Smlsd(Smlsd::parse(iter)?))
                        }
                        (0b101, 0, 0b1111) | (0b101, 1, 0b1111) => {
                            Ok(Self::Smmul(Smmul::parse(iter)?))
                        }
                        (0b101, 0, _) | (0b101, 1, _) => {
                            Ok(Self::Smmla(Smmla::parse(iter)?))
                        }
                        (0b110, 0, _) | (0b110, 1, _) => {
                            Ok(Self::Smmls(Smmls::parse(iter)?))
                        }
                        (0b111, 0, 0b1111) => Ok(Self::Usad8(Usad8::parse(iter)?)),
                        (0b111, 0, _) => Ok(Self::Usada8(Usada8::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_28")),
                    }
                }
            }
            impl ToOperation for A5_28 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Mla(el) => {
                            operation::Mla::builder()
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Mul(el) => {
                            operation::Mul::builder()
                                .set_s(Some(false.into()))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Mls(el) => {
                            operation::Mls::builder()
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Smla(el) => {
                            operation::Smla::builder()
                                .set_n_high(el.n)
                                .set_m_high(el.m)
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Smul(el) => {
                            operation::Smul::builder()
                                .set_n_high(el.n)
                                .set_m_high(el.m)
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Smlad(el) => {
                            operation::Smlad::builder()
                                .set_x(Some(el.m))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Smuad(el) => {
                            operation::Smuad::builder()
                                .set_m_swap(Some(el.m))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Smlaw(el) => {
                            operation::Smlaw::builder()
                                .set_m_high(el.m)
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Smulw(el) => {
                            operation::Smulw::builder()
                                .set_m_high(el.m)
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Smlsd(el) => {
                            operation::Smlsd::builder()
                                .set_m_swap(Some(el.m))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Smusd(el) => {
                            operation::Smusd::builder()
                                .set_m_swap(Some(el.m))
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Smmla(el) => {
                            operation::Smmla::builder()
                                .set_round(Some(el.r))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Smmul(el) => {
                            operation::Smmul::builder()
                                .set_round(Some(el.r))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Smmls(el) => {
                            operation::Smmls::builder()
                                .set_round(Some(el.r))
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Usada8(el) => {
                            operation::Usada8::builder()
                                .set_rd(el.rd)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .set_ra(el.ra)
                                .complete()
                                .into()
                        }
                        Self::Usad8(el) => {
                            operation::Usad8::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_29 {
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_29 {
                Smull(Smull),
                Sdiv(Sdiv),
                Umull(Umull),
                Udiv(Udiv),
                Smlal(Smlal),
                SmlalXY(SmlalXY),
                Smlald(Smlald),
                Smlsld(Smlsld),
                Umlal(Umlal),
                Umaal(Umaal),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_29 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_29::Smull(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smull",
                                &__self_0,
                            )
                        }
                        A5_29::Sdiv(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sdiv",
                                &__self_0,
                            )
                        }
                        A5_29::Umull(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Umull",
                                &__self_0,
                            )
                        }
                        A5_29::Udiv(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Udiv",
                                &__self_0,
                            )
                        }
                        A5_29::Smlal(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smlal",
                                &__self_0,
                            )
                        }
                        A5_29::SmlalXY(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SmlalXY",
                                &__self_0,
                            )
                        }
                        A5_29::Smlald(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smlald",
                                &__self_0,
                            )
                        }
                        A5_29::Smlsld(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Smlsld",
                                &__self_0,
                            )
                        }
                        A5_29::Umlal(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Umlal",
                                &__self_0,
                            )
                        }
                        A5_29::Umaal(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Umaal",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_29 {
                #[allow(dead_code)]
                pub(crate) fn parse_smull<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smull(Smull::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_sdiv<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Sdiv(Sdiv::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_umull<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Umull(Umull::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_udiv<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Udiv(Udiv::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smlal<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smlal(Smlal::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smlalxy<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::SmlalXY(SmlalXY::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smlald<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smlald(Smlald::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_smlsld<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Smlsld(Smlsld::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_umlal<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Umlal(Umlal::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_umaal<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::Umaal(Umaal::parse(iter)?))
                }
            }
            /**Instruction Smull from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rdhi of type Register from bit 8 to bit 11
*/
            /**- rdlo of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smull {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rdhi: Register,
                /**bit 12 to 15

*/
                pub(crate) rdlo: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smull {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Smull",
                        "rm",
                        &self.rm,
                        "rdhi",
                        &self.rdhi,
                        "rdlo",
                        &self.rdlo,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smull {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smull")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdhi: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdlo: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdhi, rdlo, rn };
                    Ok(ret)
                }
            }
            /**Instruction Sdiv from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Sdiv {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Sdiv {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Sdiv",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Sdiv {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Sdiv")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Umull from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rdhi of type Register from bit 8 to bit 11
*/
            /**- rdlo of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Umull {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rdhi: Register,
                /**bit 12 to 15

*/
                pub(crate) rdlo: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Umull {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Umull",
                        "rm",
                        &self.rm,
                        "rdhi",
                        &self.rdhi,
                        "rdlo",
                        &self.rdlo,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Umull {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Umull")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdhi: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdlo: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdhi, rdlo, rn };
                    Ok(ret)
                }
            }
            /**Instruction Udiv from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rd of type Register from bit 8 to bit 11
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Udiv {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rd: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Udiv {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Udiv",
                        "rm",
                        &self.rm,
                        "rd",
                        &self.rd,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Udiv {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Udiv")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rd: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rd, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smlal from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rdhi of type Register from bit 8 to bit 11
*/
            /**- rdlo of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smlal {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rdhi: Register,
                /**bit 12 to 15

*/
                pub(crate) rdlo: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smlal {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Smlal",
                        "rm",
                        &self.rm,
                        "rdhi",
                        &self.rdhi,
                        "rdlo",
                        &self.rdlo,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smlal {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smlal")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdhi: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdlo: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdhi, rdlo, rn };
                    Ok(ret)
                }
            }
            /**Instruction SmlalXY from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- n of type bool from bit 5 to bit 5
*/
            /**- rdhi of type Register from bit 8 to bit 11
*/
            /**- rdlo of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct SmlalXY {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 5 to 5

*/
                pub(crate) n: bool,
                /**bit 8 to 11

*/
                pub(crate) rdhi: Register,
                /**bit 12 to 15

*/
                pub(crate) rdlo: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SmlalXY {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["rm", "m", "n", "rdhi", "rdlo", "rn"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.rm,
                        &self.m,
                        &self.n,
                        &self.rdhi,
                        &self.rdlo,
                        &&self.rn,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "SmlalXY",
                        names,
                        values,
                    )
                }
            }
            impl Parse for SmlalXY {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("SmlalXY")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdhi: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdlo: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, n, rdhi, rdlo, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smlald from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- rdhi of type Register from bit 8 to bit 11
*/
            /**- rdlo of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smlald {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 8 to 11

*/
                pub(crate) rdhi: Register,
                /**bit 12 to 15

*/
                pub(crate) rdlo: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smlald {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Smlald",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "rdhi",
                        &self.rdhi,
                        "rdlo",
                        &self.rdlo,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smlald {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smlald")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdhi: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdlo: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, rdhi, rdlo, rn };
                    Ok(ret)
                }
            }
            /**Instruction Smlsld from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- m of type bool from bit 4 to bit 4
*/
            /**- rdhi of type Register from bit 8 to bit 11
*/
            /**- rdlo of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Smlsld {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 4 to 4

*/
                pub(crate) m: bool,
                /**bit 8 to 11

*/
                pub(crate) rdhi: Register,
                /**bit 12 to 15

*/
                pub(crate) rdlo: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Smlsld {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Smlsld",
                        "rm",
                        &self.rm,
                        "m",
                        &self.m,
                        "rdhi",
                        &self.rdhi,
                        "rdlo",
                        &self.rdlo,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Smlsld {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Smlsld")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let m: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 4>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdhi: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdlo: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, m, rdhi, rdlo, rn };
                    Ok(ret)
                }
            }
            /**Instruction Umlal from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rdhi of type Register from bit 8 to bit 11
*/
            /**- rdlo of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Umlal {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rdhi: Register,
                /**bit 12 to 15

*/
                pub(crate) rdlo: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Umlal {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Umlal",
                        "rm",
                        &self.rm,
                        "rdhi",
                        &self.rdhi,
                        "rdlo",
                        &self.rdlo,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Umlal {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Umlal")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdhi: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdlo: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdhi, rdlo, rn };
                    Ok(ret)
                }
            }
            /**Instruction Umaal from table A5_29

*/
            /**Contains the following fields:
*/
            /**- rm of type Register from bit 0 to bit 3
*/
            /**- rdhi of type Register from bit 8 to bit 11
*/
            /**- rdlo of type Register from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            pub struct Umaal {
                /**bit 0 to 3

*/
                pub(crate) rm: Register,
                /**bit 8 to 11

*/
                pub(crate) rdhi: Register,
                /**bit 12 to 15

*/
                pub(crate) rdlo: Register,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Umaal {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Umaal",
                        "rm",
                        &self.rm,
                        "rdhi",
                        &self.rdhi,
                        "rdlo",
                        &self.rdlo,
                        "rn",
                        &&self.rn,
                    )
                }
            }
            impl Parse for Umaal {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("Umaal")),
                    }?;
                    let rm: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdhi: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rdlo: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { rm, rdhi, rdlo, rn };
                    Ok(ret)
                }
            }
            impl Parse for A5_29 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = iter.next()?;
                    let op2 = word.mask::<4, 7>();
                    let op1 = word.mask::<20, 22>();
                    if op1 == 0b100 {
                        if op2 == 0 {
                            return Ok(Self::Smlal(Smlal::parse(iter)?));
                        }
                        if op2 >> 2 == 0b10 {
                            return Ok(Self::SmlalXY(SmlalXY::parse(iter)?));
                        }
                        if op2 >> 1 == 0b110 {
                            return Ok(Self::Smlald(Smlald::parse(iter)?));
                        }
                        return Err(ParseError::Invalid32Bit("A5_29"));
                    }
                    if op1 == 0b101 {
                        if op2 >> 1 == 0b110 {
                            return Ok(Self::Smlsld(Smlsld::parse(iter)?));
                        }
                        return Err(ParseError::Invalid32Bit("A5_29"));
                    }
                    match (op1, op2) {
                        (0b000, 0b0000) => Ok(Self::Smull(Smull::parse(iter)?)),
                        (0b001, 0b1111) => Ok(Self::Sdiv(Sdiv::parse(iter)?)),
                        (0b010, 0b0000) => Ok(Self::Umull(Umull::parse(iter)?)),
                        (0b011, 0b1111) => Ok(Self::Udiv(Udiv::parse(iter)?)),
                        (0b110, 0b0000) => Ok(Self::Umlal(Umlal::parse(iter)?)),
                        (0b110, 0b0110) => Ok(Self::Umaal(Umaal::parse(iter)?)),
                        _ => Err(ParseError::Invalid32Bit("A5_29")),
                    }
                }
            }
            impl ToOperation for A5_29 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::Smull(el) => {
                            operation::Smull::builder()
                                .set_rdlo(el.rdlo)
                                .set_rdhi(el.rdhi)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Sdiv(el) => {
                            operation::Sdiv::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Umull(el) => {
                            operation::Umull::builder()
                                .set_rdlo(el.rdlo)
                                .set_rdhi(el.rdhi)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Udiv(el) => {
                            operation::Udiv::builder()
                                .set_rd(Some(el.rd))
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Smlal(el) => {
                            operation::Smlal::builder()
                                .set_rdlo(el.rdlo)
                                .set_rdhi(el.rdhi)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::SmlalXY(el) => {
                            operation::SmlalSelective::builder()
                                .set_n_high(el.n)
                                .set_m_high(el.m)
                                .set_rdlo(el.rdlo)
                                .set_rdhi(el.rdhi)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Umlal(el) => {
                            operation::Umlal::builder()
                                .set_rdlo(el.rdlo)
                                .set_rdhi(el.rdhi)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Smlald(el) => {
                            operation::Smlald::builder()
                                .set_x(Some(el.m))
                                .set_rdlo(el.rdlo)
                                .set_rdhi(el.rdhi)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Smlsld(el) => {
                            operation::Smlsld::builder()
                                .set_m_swap(Some(el.m))
                                .set_rdlo(el.rdlo)
                                .set_rdhi(el.rdhi)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                        Self::Umaal(el) => {
                            operation::Umaal::builder()
                                .set_rdlo(el.rdlo)
                                .set_rdhi(el.rdhi)
                                .set_rn(el.rn)
                                .set_rm(el.rm)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod a5_30 {
            #![allow(dead_code)]
            use arch::CoProcessor;
            use operation::{Cdp, LdcImmediate, LdcLiteral, Mcr, Mcrr, Mrc, Mrrc, Stc};
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A5_30 {
                StcT1(StcT1),
                StcT2(StcT2),
                LdcImmediateT1(LdcImmediateT1),
                LdcImmediateT2(LdcImmediateT2),
                LdcLiteralT1(LdcLiteralT1),
                LdcLiteralT2(LdcLiteralT2),
                McrrT1(McrrT1),
                McrrT2(McrrT2),
                MrrcT1(MrrcT1),
                MrrcT2(MrrcT2),
                CdpT1(CdpT1),
                CdpT2(CdpT2),
                McrT1(McrT1),
                McrT2(McrT2),
                MrcT1(MrcT1),
                MrcT2(MrcT2),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A5_30 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A5_30::StcT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StcT1",
                                &__self_0,
                            )
                        }
                        A5_30::StcT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "StcT2",
                                &__self_0,
                            )
                        }
                        A5_30::LdcImmediateT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdcImmediateT1",
                                &__self_0,
                            )
                        }
                        A5_30::LdcImmediateT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdcImmediateT2",
                                &__self_0,
                            )
                        }
                        A5_30::LdcLiteralT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdcLiteralT1",
                                &__self_0,
                            )
                        }
                        A5_30::LdcLiteralT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LdcLiteralT2",
                                &__self_0,
                            )
                        }
                        A5_30::McrrT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "McrrT1",
                                &__self_0,
                            )
                        }
                        A5_30::McrrT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "McrrT2",
                                &__self_0,
                            )
                        }
                        A5_30::MrrcT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "MrrcT1",
                                &__self_0,
                            )
                        }
                        A5_30::MrrcT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "MrrcT2",
                                &__self_0,
                            )
                        }
                        A5_30::CdpT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "CdpT1",
                                &__self_0,
                            )
                        }
                        A5_30::CdpT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "CdpT2",
                                &__self_0,
                            )
                        }
                        A5_30::McrT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "McrT1",
                                &__self_0,
                            )
                        }
                        A5_30::McrT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "McrT2",
                                &__self_0,
                            )
                        }
                        A5_30::MrcT1(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "MrcT1",
                                &__self_0,
                            )
                        }
                        A5_30::MrcT2(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "MrcT2",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A5_30 {
                #[allow(dead_code)]
                pub(crate) fn parse_stct1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StcT1(StcT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_stct2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::StcT2(StcT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldcimmediatet1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdcImmediateT1(LdcImmediateT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldcimmediatet2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdcImmediateT2(LdcImmediateT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldcliteralt1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdcLiteralT1(LdcLiteralT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_ldcliteralt2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::LdcLiteralT2(LdcLiteralT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mcrrt1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::McrrT1(McrrT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mcrrt2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::McrrT2(McrrT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mrrct1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::MrrcT1(MrrcT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mrrct2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::MrrcT2(MrrcT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cdpt1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::CdpT1(CdpT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_cdpt2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::CdpT2(CdpT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mcrt1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::McrT1(McrT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mcrt2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::McrT2(McrT2::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mrct1<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::MrcT1(MrcT1::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_mrct2<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::MrcT2(MrcT2::parse(iter)?))
                }
            }
            /**Instruction StcT1 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- crd of type u8 from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            /**- n of type bool from bit 22 to bit 22
*/
            /**- u of type bool from bit 23 to bit 23
*/
            /**- p of type bool from bit 24 to bit 24
*/
            pub struct StcT1 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) crd: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
                /**bit 22 to 22

*/
                pub(crate) n: bool,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
                /**bit 24 to 24

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StcT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "imm8",
                        "coproc",
                        "crd",
                        "rn",
                        "w",
                        "n",
                        "u",
                        "p",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.coproc,
                        &self.crd,
                        &self.rn,
                        &self.w,
                        &self.n,
                        &self.u,
                        &&self.p,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "StcT1",
                        names,
                        values,
                    )
                }
            }
            impl Parse for StcT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StcT1")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<24, 24>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        imm8,
                        coproc,
                        crd,
                        rn,
                        w,
                        n,
                        u,
                        p,
                    };
                    Ok(ret)
                }
            }
            /**Instruction StcT2 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- crd of type u8 from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            /**- n of type bool from bit 22 to bit 22
*/
            /**- u of type bool from bit 23 to bit 23
*/
            /**- p of type bool from bit 24 to bit 24
*/
            pub struct StcT2 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) crd: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
                /**bit 22 to 22

*/
                pub(crate) n: bool,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
                /**bit 24 to 24

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StcT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "imm8",
                        "coproc",
                        "crd",
                        "rn",
                        "w",
                        "n",
                        "u",
                        "p",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.coproc,
                        &self.crd,
                        &self.rn,
                        &self.w,
                        &self.n,
                        &self.u,
                        &&self.p,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "StcT2",
                        names,
                        values,
                    )
                }
            }
            impl Parse for StcT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("StcT2")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<24, 24>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        imm8,
                        coproc,
                        crd,
                        rn,
                        w,
                        n,
                        u,
                        p,
                    };
                    Ok(ret)
                }
            }
            /**Instruction LdcImmediateT1 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- crd of type u8 from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            /**- d of type bool from bit 22 to bit 22
*/
            /**- u of type bool from bit 23 to bit 23
*/
            /**- p of type bool from bit 24 to bit 24
*/
            pub struct LdcImmediateT1 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) crd: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
                /**bit 22 to 22

*/
                pub(crate) d: bool,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
                /**bit 24 to 24

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdcImmediateT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "imm8",
                        "coproc",
                        "crd",
                        "rn",
                        "w",
                        "d",
                        "u",
                        "p",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.coproc,
                        &self.crd,
                        &self.rn,
                        &self.w,
                        &self.d,
                        &self.u,
                        &&self.p,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdcImmediateT1",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdcImmediateT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdcImmediateT1")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<24, 24>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        imm8,
                        coproc,
                        crd,
                        rn,
                        w,
                        d,
                        u,
                        p,
                    };
                    Ok(ret)
                }
            }
            /**Instruction LdcImmediateT2 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- crd of type u8 from bit 12 to bit 15
*/
            /**- rn of type Register from bit 16 to bit 19
*/
            /**- w of type bool from bit 21 to bit 21
*/
            /**- d of type bool from bit 22 to bit 22
*/
            /**- u of type bool from bit 23 to bit 23
*/
            /**- p of type bool from bit 24 to bit 24
*/
            pub struct LdcImmediateT2 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) crd: u8,
                /**bit 16 to 19

*/
                pub(crate) rn: Register,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
                /**bit 22 to 22

*/
                pub(crate) d: bool,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
                /**bit 24 to 24

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdcImmediateT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "imm8",
                        "coproc",
                        "crd",
                        "rn",
                        "w",
                        "d",
                        "u",
                        "p",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.coproc,
                        &self.crd,
                        &self.rn,
                        &self.w,
                        &self.d,
                        &self.u,
                        &&self.p,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdcImmediateT2",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdcImmediateT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdcImmediateT2")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let rn: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<24, 24>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        imm8,
                        coproc,
                        crd,
                        rn,
                        w,
                        d,
                        u,
                        p,
                    };
                    Ok(ret)
                }
            }
            /**Instruction LdcLiteralT1 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- crd of type u8 from bit 12 to bit 15
*/
            /**- w of type bool from bit 21 to bit 21
*/
            /**- d of type bool from bit 22 to bit 22
*/
            /**- u of type bool from bit 23 to bit 23
*/
            /**- p of type bool from bit 24 to bit 24
*/
            pub struct LdcLiteralT1 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) crd: u8,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
                /**bit 22 to 22

*/
                pub(crate) d: bool,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
                /**bit 24 to 24

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdcLiteralT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "imm8",
                        "coproc",
                        "crd",
                        "w",
                        "d",
                        "u",
                        "p",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.coproc,
                        &self.crd,
                        &self.w,
                        &self.d,
                        &self.u,
                        &&self.p,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdcLiteralT1",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdcLiteralT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdcLiteralT1")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<24, 24>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        imm8,
                        coproc,
                        crd,
                        w,
                        d,
                        u,
                        p,
                    };
                    Ok(ret)
                }
            }
            /**Instruction LdcLiteralT2 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- imm8 of type u8 from bit 0 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- crd of type u8 from bit 12 to bit 15
*/
            /**- w of type bool from bit 21 to bit 21
*/
            /**- d of type bool from bit 22 to bit 22
*/
            /**- u of type bool from bit 23 to bit 23
*/
            /**- p of type bool from bit 24 to bit 24
*/
            pub struct LdcLiteralT2 {
                /**bit 0 to 7

*/
                pub(crate) imm8: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) crd: u8,
                /**bit 21 to 21

*/
                pub(crate) w: bool,
                /**bit 22 to 22

*/
                pub(crate) d: bool,
                /**bit 23 to 23

*/
                pub(crate) u: bool,
                /**bit 24 to 24

*/
                pub(crate) p: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LdcLiteralT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "imm8",
                        "coproc",
                        "crd",
                        "w",
                        "d",
                        "u",
                        "p",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.imm8,
                        &self.coproc,
                        &self.crd,
                        &self.w,
                        &self.d,
                        &self.u,
                        &&self.p,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "LdcLiteralT2",
                        names,
                        values,
                    )
                }
            }
            impl Parse for LdcLiteralT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("LdcLiteralT2")),
                    }?;
                    let imm8: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let w: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 21>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<23, 23>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let p: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<24, 24>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self {
                        imm8,
                        coproc,
                        crd,
                        w,
                        d,
                        u,
                        p,
                    };
                    Ok(ret)
                }
            }
            /**Instruction McrrT1 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 3
*/
            /**- opc1 of type u8 from bit 4 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rt2 of type Register from bit 16 to bit 19
*/
            pub struct McrrT1 {
                /**bit 0 to 3

*/
                pub(crate) crm: u8,
                /**bit 4 to 7

*/
                pub(crate) opc1: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rt2: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for McrrT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "McrrT1",
                        "crm",
                        &self.crm,
                        "opc1",
                        &self.opc1,
                        "coproc",
                        &self.coproc,
                        "rt",
                        &self.rt,
                        "rt2",
                        &&self.rt2,
                    )
                }
            }
            impl Parse for McrrT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("McrrT1")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt2: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { crm, opc1, coproc, rt, rt2 };
                    Ok(ret)
                }
            }
            /**Instruction McrrT2 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 3
*/
            /**- opc1 of type u8 from bit 4 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rt2 of type Register from bit 16 to bit 19
*/
            pub struct McrrT2 {
                /**bit 0 to 3

*/
                pub(crate) crm: u8,
                /**bit 4 to 7

*/
                pub(crate) opc1: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rt2: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for McrrT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "McrrT2",
                        "crm",
                        &self.crm,
                        "opc1",
                        &self.opc1,
                        "coproc",
                        &self.coproc,
                        "rt",
                        &self.rt,
                        "rt2",
                        &&self.rt2,
                    )
                }
            }
            impl Parse for McrrT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("McrrT2")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt2: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { crm, opc1, coproc, rt, rt2 };
                    Ok(ret)
                }
            }
            /**Instruction MrrcT1 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 3
*/
            /**- opc1 of type u8 from bit 4 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rt2 of type Register from bit 16 to bit 19
*/
            pub struct MrrcT1 {
                /**bit 0 to 3

*/
                pub(crate) crm: u8,
                /**bit 4 to 7

*/
                pub(crate) opc1: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rt2: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MrrcT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "MrrcT1",
                        "crm",
                        &self.crm,
                        "opc1",
                        &self.opc1,
                        "coproc",
                        &self.coproc,
                        "rt",
                        &self.rt,
                        "rt2",
                        &&self.rt2,
                    )
                }
            }
            impl Parse for MrrcT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("MrrcT1")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt2: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { crm, opc1, coproc, rt, rt2 };
                    Ok(ret)
                }
            }
            /**Instruction MrrcT2 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 3
*/
            /**- opc1 of type u8 from bit 4 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- rt2 of type Register from bit 16 to bit 19
*/
            pub struct MrrcT2 {
                /**bit 0 to 3

*/
                pub(crate) crm: u8,
                /**bit 4 to 7

*/
                pub(crate) opc1: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) rt2: Register,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MrrcT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "MrrcT2",
                        "crm",
                        &self.crm,
                        "opc1",
                        &self.opc1,
                        "coproc",
                        &self.coproc,
                        "rt",
                        &self.rt,
                        "rt2",
                        &&self.rt2,
                    )
                }
            }
            impl Parse for MrrcT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("MrrcT2")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<4, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt2: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let ret = Self { crm, opc1, coproc, rt, rt2 };
                    Ok(ret)
                }
            }
            /**Instruction CdpT1 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 4
*/
            /**- opc2 of type u8 from bit 5 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- crd of type u8 from bit 12 to bit 15
*/
            /**- crn of type u8 from bit 16 to bit 19
*/
            /**- opc1 of type u8 from bit 20 to bit 23
*/
            pub struct CdpT1 {
                /**bit 0 to 4

*/
                pub(crate) crm: u8,
                /**bit 5 to 7

*/
                pub(crate) opc2: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) crd: u8,
                /**bit 16 to 19

*/
                pub(crate) crn: u8,
                /**bit 20 to 23

*/
                pub(crate) opc1: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for CdpT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "crm",
                        "opc2",
                        "coproc",
                        "crd",
                        "crn",
                        "opc1",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.crm,
                        &self.opc2,
                        &self.coproc,
                        &self.crd,
                        &self.crn,
                        &&self.opc1,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "CdpT1",
                        names,
                        values,
                    )
                }
            }
            impl Parse for CdpT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("CdpT1")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let crn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 23>() as u8)
                    };
                    let ret = Self {
                        crm,
                        opc2,
                        coproc,
                        crd,
                        crn,
                        opc1,
                    };
                    Ok(ret)
                }
            }
            /**Instruction CdpT2 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 4
*/
            /**- opc2 of type u8 from bit 5 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- crd of type u8 from bit 12 to bit 15
*/
            /**- crn of type u8 from bit 16 to bit 19
*/
            /**- opc1 of type u8 from bit 20 to bit 23
*/
            pub struct CdpT2 {
                /**bit 0 to 4

*/
                pub(crate) crm: u8,
                /**bit 5 to 7

*/
                pub(crate) opc2: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) crd: u8,
                /**bit 16 to 19

*/
                pub(crate) crn: u8,
                /**bit 20 to 23

*/
                pub(crate) opc1: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for CdpT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "crm",
                        "opc2",
                        "coproc",
                        "crd",
                        "crn",
                        "opc1",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.crm,
                        &self.opc2,
                        &self.coproc,
                        &self.crd,
                        &self.crn,
                        &&self.opc1,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "CdpT2",
                        names,
                        values,
                    )
                }
            }
            impl Parse for CdpT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("CdpT2")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 4>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let crn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 23>() as u8)
                    };
                    let ret = Self {
                        crm,
                        opc2,
                        coproc,
                        crd,
                        crn,
                        opc1,
                    };
                    Ok(ret)
                }
            }
            /**Instruction McrT1 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 3
*/
            /**- opc2 of type u8 from bit 5 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- crn of type u8 from bit 16 to bit 19
*/
            /**- opc1 of type u8 from bit 21 to bit 23
*/
            pub struct McrT1 {
                /**bit 0 to 3

*/
                pub(crate) crm: u8,
                /**bit 5 to 7

*/
                pub(crate) opc2: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) crn: u8,
                /**bit 21 to 23

*/
                pub(crate) opc1: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for McrT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "crm",
                        "opc2",
                        "coproc",
                        "rt",
                        "crn",
                        "opc1",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.crm,
                        &self.opc2,
                        &self.coproc,
                        &self.rt,
                        &self.crn,
                        &&self.opc1,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "McrT1",
                        names,
                        values,
                    )
                }
            }
            impl Parse for McrT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("McrT1")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 23>() as u8)
                    };
                    let ret = Self {
                        crm,
                        opc2,
                        coproc,
                        rt,
                        crn,
                        opc1,
                    };
                    Ok(ret)
                }
            }
            /**Instruction McrT2 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 3
*/
            /**- opc2 of type u8 from bit 5 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- crn of type u8 from bit 16 to bit 19
*/
            /**- opc1 of type u8 from bit 21 to bit 23
*/
            pub struct McrT2 {
                /**bit 0 to 3

*/
                pub(crate) crm: u8,
                /**bit 5 to 7

*/
                pub(crate) opc2: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) crn: u8,
                /**bit 21 to 23

*/
                pub(crate) opc1: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for McrT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "crm",
                        "opc2",
                        "coproc",
                        "rt",
                        "crn",
                        "opc1",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.crm,
                        &self.opc2,
                        &self.coproc,
                        &self.rt,
                        &self.crn,
                        &&self.opc1,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "McrT2",
                        names,
                        values,
                    )
                }
            }
            impl Parse for McrT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("McrT2")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 23>() as u8)
                    };
                    let ret = Self {
                        crm,
                        opc2,
                        coproc,
                        rt,
                        crn,
                        opc1,
                    };
                    Ok(ret)
                }
            }
            /**Instruction MrcT1 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 3
*/
            /**- opc2 of type u8 from bit 5 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- crn of type u8 from bit 16 to bit 19
*/
            /**- opc1 of type u8 from bit 21 to bit 23
*/
            pub struct MrcT1 {
                /**bit 0 to 3

*/
                pub(crate) crm: u8,
                /**bit 5 to 7

*/
                pub(crate) opc2: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) crn: u8,
                /**bit 21 to 23

*/
                pub(crate) opc1: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MrcT1 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "crm",
                        "opc2",
                        "coproc",
                        "rt",
                        "crn",
                        "opc1",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.crm,
                        &self.opc2,
                        &self.coproc,
                        &self.rt,
                        &self.crn,
                        &&self.opc1,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "MrcT1",
                        names,
                        values,
                    )
                }
            }
            impl Parse for MrcT1 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("MrcT1")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 23>() as u8)
                    };
                    let ret = Self {
                        crm,
                        opc2,
                        coproc,
                        rt,
                        crn,
                        opc1,
                    };
                    Ok(ret)
                }
            }
            /**Instruction MrcT2 from table A5_30

*/
            /**Contains the following fields:
*/
            /**- crm of type u8 from bit 0 to bit 3
*/
            /**- opc2 of type u8 from bit 5 to bit 7
*/
            /**- coproc of type CoProcessor from bit 8 to bit 11
*/
            /**- rt of type Register from bit 12 to bit 15
*/
            /**- crn of type u8 from bit 16 to bit 19
*/
            /**- opc1 of type u8 from bit 21 to bit 23
*/
            pub struct MrcT2 {
                /**bit 0 to 3

*/
                pub(crate) crm: u8,
                /**bit 5 to 7

*/
                pub(crate) opc2: u8,
                /**bit 8 to 11

*/
                pub(crate) coproc: CoProcessor,
                /**bit 12 to 15

*/
                pub(crate) rt: Register,
                /**bit 16 to 19

*/
                pub(crate) crn: u8,
                /**bit 21 to 23

*/
                pub(crate) opc1: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MrcT2 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "crm",
                        "opc2",
                        "coproc",
                        "rt",
                        "crn",
                        "opc1",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.crm,
                        &self.opc2,
                        &self.coproc,
                        &self.rt,
                        &self.crn,
                        &&self.opc1,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "MrcT2",
                        names,
                        values,
                    )
                }
            }
            impl Parse for MrcT2 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("MrcT2")),
                    }?;
                    let crm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 7>() as u8)
                    };
                    let coproc: CoProcessor = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 11>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let rt: Register = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let crn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let opc1: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<21, 23>() as u8)
                    };
                    let ret = Self {
                        crm,
                        opc2,
                        coproc,
                        rt,
                        crn,
                        opc1,
                    };
                    Ok(ret)
                }
            }
            impl Parse for A5_30 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(word) => word,
                        None => return Err(ParseError::IncompleteProgram),
                    };
                    let op = word.mask::<4, 4>();
                    if !(op <= 1) {
                        ::core::panicking::panic("assertion failed: op <= 1")
                    }
                    let enc = word.mask::<{ 16 + 12 }, { 16 + 12 }>();
                    if !(enc <= 1) {
                        ::core::panicking::panic("assertion failed: enc <= 1")
                    }
                    let op1 = word.mask::<{ 16 + 4 }, { 16 + 9 }>();
                    if !(op1 < (1 << (9 - 4 + 1)) - 1) {
                        ::core::panicking::panic(
                            "assertion failed: op1 < (1 << (9 - 4 + 1)) - 1",
                        )
                    }
                    let rn = word.mask::<16, 19>();
                    if !(rn < (1 << (19 - 16 + 1))) {
                        ::core::panicking::panic(
                            "assertion failed: rn < (1 << (19 - 16 + 1))",
                        )
                    }
                    if op1 == 0b000100 {
                        match enc + 1 {
                            1 => return Ok(Self::McrrT1(McrrT1::parse(iter)?)),
                            2 => return Ok(Self::McrrT2(McrrT2::parse(iter)?)),
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("This is unreachable due to previous asserts"),
                                    ),
                                );
                            }
                        }
                    }
                    if op1 == 0b000101 {
                        match enc + 1 {
                            1 => return Ok(Self::MrrcT1(MrrcT1::parse(iter)?)),
                            2 => return Ok(Self::MrrcT2(MrrcT2::parse(iter)?)),
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("This is unreachable due to previous asserts"),
                                    ),
                                );
                            }
                        }
                    }
                    match (enc + 1, op1 & 0b110001, op) {
                        (1, 0b100000, 1) => return Ok(Self::McrT1(McrT1::parse(iter)?)),
                        (2, 0b100000, 1) => return Ok(Self::McrT2(McrT2::parse(iter)?)),
                        (1, 0b100001, 1) => return Ok(Self::MrcT1(MrcT1::parse(iter)?)),
                        (2, 0b100001, 1) => return Ok(Self::MrcT2(MrcT2::parse(iter)?)),
                        _ => {}
                    }
                    match (enc + 1, op1 & 0b110000, op) {
                        (1, 0b100000, 0) => return Ok(Self::CdpT1(CdpT1::parse(iter)?)),
                        (2, 0b100000, 0) => return Ok(Self::CdpT2(CdpT2::parse(iter)?)),
                        _ => {}
                    }
                    match (enc + 1, op1 & 0b100001, rn) {
                        (1, 0b000000, _) => return Ok(Self::StcT1(StcT1::parse(iter)?)),
                        (2, 0b000000, _) => return Ok(Self::StcT2(StcT2::parse(iter)?)),
                        (1, 0b000001, 0b1111) => {
                            return Ok(Self::LdcLiteralT1(LdcLiteralT1::parse(iter)?));
                        }
                        (2, 0b000001, 0b1111) => {
                            return Ok(Self::LdcLiteralT2(LdcLiteralT2::parse(iter)?));
                        }
                        (1, 0b000001, _) => {
                            return Ok(Self::LdcImmediateT1(LdcImmediateT1::parse(iter)?));
                        }
                        (2, 0b000001, _) => {
                            return Ok(Self::LdcImmediateT2(LdcImmediateT2::parse(iter)?));
                        }
                        _ => {}
                    }
                    Err(ParseError::Invalid32Bit("a5_30"))
                }
            }
            impl ToOperation for A5_30 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    match self {
                        Self::StcT1(stc) => {
                            Stc::builder()
                                .set_coproc(stc.coproc)
                                .set_crd(stc.crd)
                                .set_rn(stc.rn)
                                .set_imm(Some((stc.imm8 as u32) << 2))
                                .set_add(stc.u)
                                .set_w(stc.w)
                                .set_index(stc.p)
                                .complete()
                                .into()
                        }
                        Self::StcT2(stc) => {
                            Stc::builder()
                                .set_coproc(stc.coproc)
                                .set_crd(stc.crd)
                                .set_rn(stc.rn)
                                .set_imm(Some((stc.imm8 as u32) << 2))
                                .set_add(stc.u)
                                .set_w(stc.w)
                                .set_index(stc.p)
                                .complete()
                                .into()
                        }
                        Self::LdcLiteralT1(ldc) => {
                            LdcLiteral::builder()
                                .set_coproc(ldc.coproc)
                                .set_crd(ldc.crd)
                                .set_imm((ldc.imm8 as u32) << 2)
                                .set_add(ldc.u)
                                .set_index(ldc.p)
                                .complete()
                                .into()
                        }
                        Self::LdcLiteralT2(ldc) => {
                            LdcLiteral::builder()
                                .set_coproc(ldc.coproc)
                                .set_crd(ldc.crd)
                                .set_imm((ldc.imm8 as u32) << 2)
                                .set_add(ldc.u)
                                .set_index(ldc.p)
                                .complete()
                                .into()
                        }
                        Self::LdcImmediateT1(ldc) => {
                            LdcImmediate::builder()
                                .set_coproc(ldc.coproc)
                                .set_crd(ldc.crd)
                                .set_imm(Some((ldc.imm8 as u32) << 2))
                                .set_add(ldc.u)
                                .set_index(ldc.p)
                                .set_rn(ldc.rn)
                                .set_w(ldc.w)
                                .complete()
                                .into()
                        }
                        Self::LdcImmediateT2(ldc) => {
                            LdcImmediate::builder()
                                .set_coproc(ldc.coproc)
                                .set_crd(ldc.crd)
                                .set_imm(Some((ldc.imm8 as u32) << 2))
                                .set_add(ldc.u)
                                .set_index(ldc.p)
                                .set_rn(ldc.rn)
                                .set_w(ldc.w)
                                .complete()
                                .into()
                        }
                        Self::MrrcT1(el) => {
                            Mrrc::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_rt(el.rt)
                                .set_rt2(el.rt2)
                                .set_crm(el.crm)
                                .complete()
                                .into()
                        }
                        Self::MrrcT2(el) => {
                            Mrrc::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_rt(el.rt)
                                .set_rt2(el.rt2)
                                .set_crm(el.crm)
                                .complete()
                                .into()
                        }
                        Self::CdpT1(el) => {
                            Cdp::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_crm(el.crm)
                                .set_crd(el.crd)
                                .set_crn(el.crn)
                                .set_opc2(el.opc2)
                                .complete()
                                .into()
                        }
                        Self::CdpT2(el) => {
                            Cdp::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_crm(el.crm)
                                .set_crd(el.crd)
                                .set_crn(el.crn)
                                .set_opc2(el.opc2)
                                .complete()
                                .into()
                        }
                        Self::McrT1(el) => {
                            Mcr::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_crm(el.crm)
                                .set_opc2(Some(el.opc2))
                                .set_rt(el.rt)
                                .set_crn(el.crn)
                                .complete()
                                .into()
                        }
                        Self::McrT2(el) => {
                            Mcr::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_crm(el.crm)
                                .set_opc2(Some(el.opc2))
                                .set_rt(el.rt)
                                .set_crn(el.crn)
                                .complete()
                                .into()
                        }
                        Self::MrcT1(el) => {
                            Mrc::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_crm(el.crm)
                                .set_opc2(Some(el.opc2))
                                .set_rt(el.rt)
                                .set_crn(el.crn)
                                .complete()
                                .into()
                        }
                        Self::MrcT2(el) => {
                            Mrc::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_crm(el.crm)
                                .set_opc2(Some(el.opc2))
                                .set_rt(el.rt)
                                .set_crn(el.crn)
                                .complete()
                                .into()
                        }
                        Self::McrrT1(el) => {
                            Mcrr::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_rt(el.rt)
                                .set_rt2(el.rt2)
                                .set_crm(el.crm)
                                .complete()
                                .into()
                        }
                        Self::McrrT2(el) => {
                            Mcrr::builder()
                                .set_coproc(el.coproc)
                                .set_opc1(el.opc1)
                                .set_rt(el.rt)
                                .set_rt2(el.rt2)
                                .set_crm(el.crm)
                                .complete()
                                .into()
                        }
                    }
                }
            }
        }
        pub mod float {
            #![allow(dead_code)]
            use arch::register::IEEE754RoundingMode;
            use macros::{compare, extract_fields};
            use paste::paste;
            use crate::{
                asm::{LocalTryInto, Mask},
                instruction, prelude::*, ParseError, ToOperation,
            };
            pub enum A6_5 {
                VSELF32(VSELF32),
                VSELF64(VSELF64),
                VMLXF32(VMLXF32),
                VMLXF64(VMLXF64),
                VNMULF32(VNMULF32),
                VNMULF64(VNMULF64),
                VMULF32(VMULF32),
                VMULF64(VMULF64),
                VADDF32(VADDF32),
                VADDF64(VADDF64),
                VSUBF32(VSUBF32),
                VSUBF64(VSUBF64),
                VDIVF32(VDIVF32),
                VDIVF64(VDIVF64),
                VXNMF32(VXNMF32),
                VXNMF64(VXNMF64),
                VMOVIMMF32(VMOVIMMF32),
                VMOVIMMF64(VMOVIMMF64),
                VMOVREGF32(VMOVREGF32),
                VMOVREGF64(VMOVREGF64),
                VABSF32(VABSF32),
                VABSF64(VABSF64),
                VNEGF32(VNEGF32),
                VNEGF64(VNEGF64),
                VSQRTF32(VSQRTF32),
                VSQRTF64(VSQRTF64),
                VCVTXF32(VCVTXF32),
                VCVTXF64(VCVTXF64),
                VCMPREGF32(VCMPREGF32),
                VCMPREGF64(VCMPREGF64),
                VCMPZEROF32(VCMPZEROF32),
                VCMPZEROF64(VCMPZEROF64),
                VRINTF32(VRINTF32),
                VRINTF64(VRINTF64),
                VCVTF32F64(VCVTF32F64),
                VCVTF64F32(VCVTF64F32),
                VCVTINTXINTXFLOAT(VCVTINTXINTXFLOAT),
                VRINTROUNDF32(VRINTROUNDF32),
                /// TODO: This is incorrect according to the spec, see if this works or not.
                VRINTROUNDF64(VRINTROUNDF64),
                VCVTROUNDF32(VCVTROUNDF32),
                VCVTROUNDF64(VCVTROUNDF64),
                VCVTF32INT(VCVTF32INT),
                VCVTF64INT(VCVTF64INT),
                VCVTF32INTROUND(VCVTF32INTROUND),
                VCVTF64INTROUND(VCVTF64INTROUND),
                VCVTF32FIXEDPOINT(VCVTF32FIXEDPOINT),
                VCVTF64FIXEDPOINT(VCVTF64FIXEDPOINT),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for A6_5 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        A6_5::VSELF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VSELF32",
                                &__self_0,
                            )
                        }
                        A6_5::VSELF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VSELF64",
                                &__self_0,
                            )
                        }
                        A6_5::VMLXF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VMLXF32",
                                &__self_0,
                            )
                        }
                        A6_5::VMLXF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VMLXF64",
                                &__self_0,
                            )
                        }
                        A6_5::VNMULF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VNMULF32",
                                &__self_0,
                            )
                        }
                        A6_5::VNMULF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VNMULF64",
                                &__self_0,
                            )
                        }
                        A6_5::VMULF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VMULF32",
                                &__self_0,
                            )
                        }
                        A6_5::VMULF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VMULF64",
                                &__self_0,
                            )
                        }
                        A6_5::VADDF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VADDF32",
                                &__self_0,
                            )
                        }
                        A6_5::VADDF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VADDF64",
                                &__self_0,
                            )
                        }
                        A6_5::VSUBF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VSUBF32",
                                &__self_0,
                            )
                        }
                        A6_5::VSUBF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VSUBF64",
                                &__self_0,
                            )
                        }
                        A6_5::VDIVF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VDIVF32",
                                &__self_0,
                            )
                        }
                        A6_5::VDIVF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VDIVF64",
                                &__self_0,
                            )
                        }
                        A6_5::VXNMF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VXNMF32",
                                &__self_0,
                            )
                        }
                        A6_5::VXNMF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VXNMF64",
                                &__self_0,
                            )
                        }
                        A6_5::VMOVIMMF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VMOVIMMF32",
                                &__self_0,
                            )
                        }
                        A6_5::VMOVIMMF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VMOVIMMF64",
                                &__self_0,
                            )
                        }
                        A6_5::VMOVREGF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VMOVREGF32",
                                &__self_0,
                            )
                        }
                        A6_5::VMOVREGF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VMOVREGF64",
                                &__self_0,
                            )
                        }
                        A6_5::VABSF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VABSF32",
                                &__self_0,
                            )
                        }
                        A6_5::VABSF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VABSF64",
                                &__self_0,
                            )
                        }
                        A6_5::VNEGF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VNEGF32",
                                &__self_0,
                            )
                        }
                        A6_5::VNEGF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VNEGF64",
                                &__self_0,
                            )
                        }
                        A6_5::VSQRTF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VSQRTF32",
                                &__self_0,
                            )
                        }
                        A6_5::VSQRTF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VSQRTF64",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTXF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTXF32",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTXF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTXF64",
                                &__self_0,
                            )
                        }
                        A6_5::VCMPREGF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCMPREGF32",
                                &__self_0,
                            )
                        }
                        A6_5::VCMPREGF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCMPREGF64",
                                &__self_0,
                            )
                        }
                        A6_5::VCMPZEROF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCMPZEROF32",
                                &__self_0,
                            )
                        }
                        A6_5::VCMPZEROF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCMPZEROF64",
                                &__self_0,
                            )
                        }
                        A6_5::VRINTF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VRINTF32",
                                &__self_0,
                            )
                        }
                        A6_5::VRINTF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VRINTF64",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTF32F64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTF32F64",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTF64F32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTF64F32",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTINTXINTXFLOAT(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTINTXINTXFLOAT",
                                &__self_0,
                            )
                        }
                        A6_5::VRINTROUNDF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VRINTROUNDF32",
                                &__self_0,
                            )
                        }
                        A6_5::VRINTROUNDF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VRINTROUNDF64",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTROUNDF32(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTROUNDF32",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTROUNDF64(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTROUNDF64",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTF32INT(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTF32INT",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTF64INT(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTF64INT",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTF32INTROUND(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTF32INTROUND",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTF64INTROUND(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTF64INTROUND",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTF32FIXEDPOINT(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTF32FIXEDPOINT",
                                &__self_0,
                            )
                        }
                        A6_5::VCVTF64FIXEDPOINT(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "VCVTF64FIXEDPOINT",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            impl A6_5 {
                #[allow(dead_code)]
                pub(crate) fn parse_vself32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VSELF32(VSELF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vself64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VSELF64(VSELF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vmlxf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VMLXF32(VMLXF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vmlxf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VMLXF64(VMLXF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vnmulf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VNMULF32(VNMULF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vnmulf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VNMULF64(VNMULF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vmulf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VMULF32(VMULF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vmulf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VMULF64(VMULF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vaddf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VADDF32(VADDF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vaddf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VADDF64(VADDF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vsubf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VSUBF32(VSUBF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vsubf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VSUBF64(VSUBF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vdivf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VDIVF32(VDIVF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vdivf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VDIVF64(VDIVF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vxnmf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VXNMF32(VXNMF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vxnmf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VXNMF64(VXNMF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vmovimmf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VMOVIMMF32(VMOVIMMF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vmovimmf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VMOVIMMF64(VMOVIMMF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vmovregf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VMOVREGF32(VMOVREGF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vmovregf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VMOVREGF64(VMOVREGF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vabsf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VABSF32(VABSF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vabsf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VABSF64(VABSF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vnegf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VNEGF32(VNEGF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vnegf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VNEGF64(VNEGF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vsqrtf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VSQRTF32(VSQRTF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vsqrtf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VSQRTF64(VSQRTF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtxf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTXF32(VCVTXF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtxf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTXF64(VCVTXF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcmpregf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCMPREGF32(VCMPREGF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcmpregf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCMPREGF64(VCMPREGF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcmpzerof32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCMPZEROF32(VCMPZEROF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcmpzerof64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCMPZEROF64(VCMPZEROF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vrintf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VRINTF32(VRINTF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vrintf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VRINTF64(VRINTF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtf32f64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTF32F64(VCVTF32F64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtf64f32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTF64F32(VCVTF64F32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtintxintxfloat<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTINTXINTXFLOAT(VCVTINTXINTXFLOAT::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vrintroundf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VRINTROUNDF32(VRINTROUNDF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vrintroundf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VRINTROUNDF64(VRINTROUNDF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtroundf32<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTROUNDF32(VCVTROUNDF32::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtroundf64<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTROUNDF64(VCVTROUNDF64::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtf32int<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTF32INT(VCVTF32INT::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtf64int<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTF64INT(VCVTF64INT::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtf32intround<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTF32INTROUND(VCVTF32INTROUND::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtf64intround<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTF64INTROUND(VCVTF64INTROUND::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtf32fixedpoint<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTF32FIXEDPOINT(VCVTF32FIXEDPOINT::parse(iter)?))
                }
                #[allow(dead_code)]
                pub(crate) fn parse_vcvtf64fixedpoint<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self, crate::ParseError> {
                    Ok(Self::VCVTF64FIXEDPOINT(VCVTF64FIXEDPOINT::parse(iter)?))
                }
            }
            /**Instruction VSELF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- sn of type u8 from bit 16 to bit 19
*/
            /**- cc of type u8 from bit 20 to bit 21
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VSELF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) sn: u8,
                /**bit 20 to 21

*/
                pub(crate) cc: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VSELF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "sm",
                        "m",
                        "n",
                        "sz",
                        "sd",
                        "sn",
                        "cc",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.sd,
                        &self.sn,
                        &self.cc,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VSELF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VSELF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VSELF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let sn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let cc: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 21>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        sm,
                        m,
                        n,
                        sz,
                        sd,
                        sn,
                        cc,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VSELF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- dn of type u8 from bit 16 to bit 19
*/
            /**- cc of type u8 from bit 20 to bit 21
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VSELF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) dn: u8,
                /**bit 20 to 21

*/
                pub(crate) cc: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VSELF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "dm",
                        "m",
                        "n",
                        "sz",
                        "dd",
                        "dn",
                        "cc",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.dd,
                        &self.dn,
                        &self.cc,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VSELF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VSELF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VSELF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let cc: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<20, 21>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        dm,
                        m,
                        n,
                        sz,
                        dd,
                        dn,
                        cc,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VMLXF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 6 to bit 6
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- sn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VMLXF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 6 to 6

*/
                pub(crate) op: bool,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) sn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VMLXF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "sm",
                        "m",
                        "op",
                        "n",
                        "sz",
                        "sd",
                        "sn",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.op,
                        &self.n,
                        &self.sz,
                        &self.sd,
                        &self.sn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VMLXF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VMLXF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VMLXF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 6>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let sn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        sm,
                        m,
                        op,
                        n,
                        sz,
                        sd,
                        sn,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VMLXF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 6 to bit 6
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- dn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VMLXF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 6 to 6

*/
                pub(crate) op: bool,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) dn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VMLXF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "dm",
                        "m",
                        "op",
                        "n",
                        "sz",
                        "dd",
                        "dn",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.op,
                        &self.n,
                        &self.sz,
                        &self.dd,
                        &self.dn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VMLXF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VMLXF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VMLXF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 6>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        dm,
                        m,
                        op,
                        n,
                        sz,
                        dd,
                        dn,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VNMULF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- sn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VNMULF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) sn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VNMULF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "n", "sz", "sd", "sn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.sd,
                        &self.sn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VNMULF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VNMULF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VNMULF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let sn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, n, sz, sd, sn, d };
                    Ok(ret)
                }
            }
            /**Instruction VNMULF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- dn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VNMULF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) dn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VNMULF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "n", "sz", "dd", "dn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.dd,
                        &self.dn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VNMULF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VNMULF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VNMULF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, n, sz, dd, dn, d };
                    Ok(ret)
                }
            }
            /**Instruction VMULF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- sn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VMULF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) sn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VMULF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "n", "sz", "sd", "sn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.sd,
                        &self.sn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VMULF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VMULF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VMULF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let sn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, n, sz, sd, sn, d };
                    Ok(ret)
                }
            }
            /**Instruction VMULF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- dn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VMULF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) dn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VMULF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "n", "sz", "dd", "dn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.dd,
                        &self.dn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VMULF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VMULF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VMULF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, n, sz, dd, dn, d };
                    Ok(ret)
                }
            }
            /**Instruction VADDF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- sn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VADDF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) sn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VADDF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "n", "sz", "sd", "sn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.sd,
                        &self.sn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VADDF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VADDF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VADDF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let sn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, n, sz, sd, sn, d };
                    Ok(ret)
                }
            }
            /**Instruction VADDF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- dn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VADDF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) dn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VADDF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "n", "sz", "dd", "dn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.dd,
                        &self.dn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VADDF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VADDF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VADDF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, n, sz, dd, dn, d };
                    Ok(ret)
                }
            }
            /**Instruction VSUBF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- sn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VSUBF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) sn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VSUBF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "n", "sz", "sd", "sn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.sd,
                        &self.sn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VSUBF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VSUBF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VSUBF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let sn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, n, sz, sd, sn, d };
                    Ok(ret)
                }
            }
            /**Instruction VSUBF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- dn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VSUBF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) dn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VSUBF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "n", "sz", "dd", "dn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.dd,
                        &self.dn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VSUBF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VSUBF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VSUBF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, n, sz, dd, dn, d };
                    Ok(ret)
                }
            }
            /**Instruction VDIVF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- sn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VDIVF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) sn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VDIVF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "n", "sz", "sd", "sn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.sd,
                        &self.sn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VDIVF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VDIVF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VDIVF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let sn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, n, sz, sd, sn, d };
                    Ok(ret)
                }
            }
            /**Instruction VDIVF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- dn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VDIVF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) dn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VDIVF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "n", "sz", "dd", "dn", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.n,
                        &self.sz,
                        &self.dd,
                        &self.dn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VDIVF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VDIVF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VDIVF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, n, sz, dd, dn, d };
                    Ok(ret)
                }
            }
            /**Instruction VXNMF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 6 to bit 6
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- sn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VXNMF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 6 to 6

*/
                pub(crate) op: bool,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) sn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VXNMF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "sm",
                        "m",
                        "op",
                        "n",
                        "sz",
                        "sd",
                        "sn",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.op,
                        &self.n,
                        &self.sz,
                        &self.sd,
                        &self.sn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VXNMF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VXNMF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VXNMF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 6>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let sn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        sm,
                        m,
                        op,
                        n,
                        sz,
                        sd,
                        sn,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VXNMF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 6 to bit 6
*/
            /**- n of type u8 from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- dn of type u8 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VXNMF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 6 to 6

*/
                pub(crate) op: bool,
                /**bit 7 to 7

*/
                pub(crate) n: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) dn: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VXNMF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "dm",
                        "m",
                        "op",
                        "n",
                        "sz",
                        "dd",
                        "dn",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.op,
                        &self.n,
                        &self.sz,
                        &self.dd,
                        &self.dn,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VXNMF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VXNMF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VXNMF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<6, 6>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let n: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let dn: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        dm,
                        m,
                        op,
                        n,
                        sz,
                        dd,
                        dn,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VMOVIMMF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- imm4l of type u32 from bit 0 to bit 3
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- imm4h of type u32 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VMOVIMMF32 {
                /**bit 0 to 3

*/
                pub(crate) imm4l: u32,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 19

*/
                pub(crate) imm4h: u32,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VMOVIMMF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VMOVIMMF32",
                        "imm4l",
                        &self.imm4l,
                        "sz",
                        &self.sz,
                        "sd",
                        &self.sd,
                        "imm4h",
                        &self.imm4h,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VMOVIMMF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VMOVIMMF32")),
                    }?;
                    let imm4l: u32 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u32)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let imm4h: u32 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u32)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { imm4l, sz, sd, imm4h, d };
                    Ok(ret)
                }
            }
            /**Instruction VMOVIMMF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- imm4l of type u32 from bit 0 to bit 3
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- imm4h of type u32 from bit 16 to bit 19
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VMOVIMMF64 {
                /**bit 0 to 3

*/
                pub(crate) imm4l: u32,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 19

*/
                pub(crate) imm4h: u32,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VMOVIMMF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VMOVIMMF64",
                        "imm4l",
                        &self.imm4l,
                        "sz",
                        &self.sz,
                        "dd",
                        &self.dd,
                        "imm4h",
                        &self.imm4h,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VMOVIMMF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VMOVIMMF64")),
                    }?;
                    let imm4l: u32 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u32)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let imm4h: u32 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 19>() as u32)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { imm4l, sz, dd, imm4h, d };
                    Ok(ret)
                }
            }
            /**Instruction VMOVREGF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VMOVREGF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VMOVREGF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VMOVREGF32",
                        "sm",
                        &self.sm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "sd",
                        &self.sd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VMOVREGF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VMOVREGF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, sz, sd, d };
                    Ok(ret)
                }
            }
            /**Instruction VMOVREGF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VMOVREGF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VMOVREGF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VMOVREGF64",
                        "dm",
                        &self.dm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "dd",
                        &self.dd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VMOVREGF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VMOVREGF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, sz, dd, d };
                    Ok(ret)
                }
            }
            /**Instruction VABSF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VABSF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VABSF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VABSF32",
                        "sm",
                        &self.sm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "sd",
                        &self.sd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VABSF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VABSF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, sz, sd, d };
                    Ok(ret)
                }
            }
            /**Instruction VABSF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VABSF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VABSF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VABSF64",
                        "dm",
                        &self.dm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "dd",
                        &self.dd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VABSF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VABSF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, sz, dd, d };
                    Ok(ret)
                }
            }
            /**Instruction VNEGF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VNEGF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VNEGF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VNEGF32",
                        "sm",
                        &self.sm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "sd",
                        &self.sd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VNEGF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VNEGF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, sz, sd, d };
                    Ok(ret)
                }
            }
            /**Instruction VNEGF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VNEGF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VNEGF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VNEGF64",
                        "dm",
                        &self.dm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "dd",
                        &self.dd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VNEGF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VNEGF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, sz, dd, d };
                    Ok(ret)
                }
            }
            /**Instruction VSQRTF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VSQRTF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VSQRTF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VSQRTF32",
                        "sm",
                        &self.sm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "sd",
                        &self.sd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VSQRTF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VSQRTF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, sz, sd, d };
                    Ok(ret)
                }
            }
            /**Instruction VSQRTF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VSQRTF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VSQRTF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VSQRTF64",
                        "dm",
                        &self.dm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "dd",
                        &self.dd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VSQRTF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VSQRTF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, sz, dd, d };
                    Ok(ret)
                }
            }
            /**Instruction VCVTXF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- t of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- op of type bool from bit 16 to bit 16
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTXF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) t: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 16

*/
                pub(crate) op: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTXF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "t", "sz", "sd", "op", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.t,
                        &self.sz,
                        &self.sd,
                        &self.op,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTXF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTXF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTXF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let t: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 16>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, t, sz, sd, op, d };
                    Ok(ret)
                }
            }
            /**Instruction VCVTXF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- t of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- op of type bool from bit 16 to bit 16
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTXF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) t: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 16

*/
                pub(crate) op: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTXF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "t", "sz", "dd", "op", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.t,
                        &self.sz,
                        &self.dd,
                        &self.op,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTXF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTXF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTXF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let t: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 16>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, t, sz, dd, op, d };
                    Ok(ret)
                }
            }
            /**Instruction VCMPREGF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- e of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- op of type bool from bit 16 to bit 16
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCMPREGF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) e: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 16

*/
                pub(crate) op: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCMPREGF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "e", "sz", "sd", "op", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.e,
                        &self.sz,
                        &self.sd,
                        &self.op,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCMPREGF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCMPREGF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCMPREGF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let e: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 16>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, e, sz, sd, op, d };
                    Ok(ret)
                }
            }
            /**Instruction VCMPREGF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- e of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- op of type bool from bit 16 to bit 16
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCMPREGF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) e: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 16

*/
                pub(crate) op: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCMPREGF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "e", "sz", "dd", "op", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.e,
                        &self.sz,
                        &self.dd,
                        &self.op,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCMPREGF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCMPREGF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCMPREGF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let e: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 16>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, e, sz, dd, op, d };
                    Ok(ret)
                }
            }
            /**Instruction VCMPZEROF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- e of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- op of type bool from bit 16 to bit 16
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCMPZEROF32 {
                /**bit 7 to 7

*/
                pub(crate) e: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 16

*/
                pub(crate) op: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCMPZEROF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VCMPZEROF32",
                        "e",
                        &self.e,
                        "sz",
                        &self.sz,
                        "sd",
                        &self.sd,
                        "op",
                        &self.op,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VCMPZEROF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCMPZEROF32")),
                    }?;
                    let e: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 16>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { e, sz, sd, op, d };
                    Ok(ret)
                }
            }
            /**Instruction VCMPZEROF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- e of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- op of type bool from bit 16 to bit 16
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCMPZEROF64 {
                /**bit 7 to 7

*/
                pub(crate) e: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 16

*/
                pub(crate) op: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCMPZEROF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VCMPZEROF64",
                        "e",
                        &self.e,
                        "sz",
                        &self.sz,
                        "dd",
                        &self.dd,
                        "op",
                        &self.op,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VCMPZEROF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCMPZEROF64")),
                    }?;
                    let e: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 16>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { e, sz, dd, op, d };
                    Ok(ret)
                }
            }
            /**Instruction VRINTF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VRINTF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VRINTF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "op", "sz", "sd", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.sd,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VRINTF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VRINTF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VRINTF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, op, sz, sd, d };
                    Ok(ret)
                }
            }
            /**Instruction VRINTF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VRINTF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VRINTF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "op", "sz", "dd", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.dd,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VRINTF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VRINTF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VRINTF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, op, sz, dd, d };
                    Ok(ret)
                }
            }
            /**Instruction VCVTF32F64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTF32F64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTF32F64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VCVTF32F64",
                        "dm",
                        &self.dm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "sd",
                        &self.sd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VCVTF32F64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTF32F64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, sz, sd, d };
                    Ok(ret)
                }
            }
            /**Instruction VCVTF64F32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTF64F32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTF64F32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "VCVTF64F32",
                        "sm",
                        &self.sm,
                        "m",
                        &self.m,
                        "sz",
                        &self.sz,
                        "dd",
                        &self.dd,
                        "d",
                        &&self.d,
                    )
                }
            }
            impl Parse for VCVTF64F32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTF64F32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, sz, dd, d };
                    Ok(ret)
                }
            }
            /**Instruction VCVTINTXINTXFLOAT from table A6_5

*/
            /**Contains the following fields:
*/
            /**- vm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- vd of type u8 from bit 12 to bit 15
*/
            /**- opc2 of type bool from bit 16 to bit 18
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTINTXINTXFLOAT {
                /**bit 0 to 3

*/
                pub(crate) vm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) vd: u8,
                /**bit 16 to 18

*/
                pub(crate) opc2: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTINTXINTXFLOAT {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["vm", "m", "op", "sz", "vd", "opc2", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.vm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.vd,
                        &self.opc2,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTINTXINTXFLOAT",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTINTXINTXFLOAT {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTINTXINTXFLOAT")),
                    }?;
                    let vm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let vd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let opc2: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 18>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { vm, m, op, sz, vd, opc2, d };
                    Ok(ret)
                }
            }
            /**Instruction VRINTROUNDF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- rm of type IEEE754RoundingMode from bit 16 to bit 17
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VRINTROUNDF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 17

*/
                pub(crate) rm: IEEE754RoundingMode,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VRINTROUNDF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "op", "sz", "sd", "rm", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.sd,
                        &self.rm,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VRINTROUNDF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VRINTROUNDF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VRINTROUNDF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let rm: IEEE754RoundingMode = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 17>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, op, sz, sd, rm, d };
                    Ok(ret)
                }
            }
            /**Instruction VRINTROUNDF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- rm of type IEEE754RoundingMode from bit 16 to bit 17
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            /// TODO: This is incorrect according to the spec, see if this works or not.
            pub struct VRINTROUNDF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 17

*/
                /// TODO: This is incorrect according to the spec, see if this works or not.
                pub(crate) rm: IEEE754RoundingMode,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VRINTROUNDF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "op", "sz", "dd", "rm", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.dd,
                        &self.rm,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VRINTROUNDF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VRINTROUNDF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VRINTROUNDF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let rm: IEEE754RoundingMode = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 17>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, op, sz, dd, rm, d };
                    Ok(ret)
                }
            }
            /**Instruction VCVTROUNDF32 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- opc2 of type u8 from bit 16 to bit 18
*/
            /**- rm of type IEEE754RoundingMode from bit 16 to bit 17
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTROUNDF32 {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 18

*/
                pub(crate) opc2: u8,
                /**bit 16 to 17

*/
                /// TODO: This is incorrect according to the spec, see if this works or not.
                pub(crate) rm: IEEE754RoundingMode,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTROUNDF32 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "sm",
                        "m",
                        "op",
                        "sz",
                        "dd",
                        "opc2",
                        "rm",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.dd,
                        &self.opc2,
                        &self.rm,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTROUNDF32",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTROUNDF32 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTROUNDF32")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 18>() as u8)
                    };
                    let rm: IEEE754RoundingMode = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 17>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        sm,
                        m,
                        op,
                        sz,
                        dd,
                        opc2,
                        rm,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VCVTROUNDF64 from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- opc2 of type u8 from bit 16 to bit 18
*/
            /**- rm of type IEEE754RoundingMode from bit 16 to bit 17
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTROUNDF64 {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 18

*/
                pub(crate) opc2: u8,
                /**bit 16 to 17

*/
                /// TODO: This is incorrect according to the spec, see if this works or not.
                pub(crate) rm: IEEE754RoundingMode,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTROUNDF64 {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "dm",
                        "m",
                        "op",
                        "sz",
                        "sd",
                        "opc2",
                        "rm",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.sd,
                        &self.opc2,
                        &self.rm,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTROUNDF64",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTROUNDF64 {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTROUNDF64")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 18>() as u8)
                    };
                    let rm: IEEE754RoundingMode = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 17>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        dm,
                        m,
                        op,
                        sz,
                        sd,
                        opc2,
                        rm,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VCVTF32INT from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- opc2 of type u8 from bit 16 to bit 18
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTF32INT {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 18

*/
                pub(crate) opc2: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTF32INT {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["sm", "m", "op", "sz", "sd", "opc2", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.sd,
                        &self.opc2,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTF32INT",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTF32INT {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTF32INT")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 18>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { sm, m, op, sz, sd, opc2, d };
                    Ok(ret)
                }
            }
            /**Instruction VCVTF64INT from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- opc2 of type u8 from bit 16 to bit 18
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTF64INT {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 18

*/
                pub(crate) opc2: u8,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTF64INT {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &["dm", "m", "op", "sz", "dd", "opc2", "d"];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.dd,
                        &self.opc2,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTF64INT",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTF64INT {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTF64INT")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 18>() as u8)
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self { dm, m, op, sz, dd, opc2, d };
                    Ok(ret)
                }
            }
            /**Instruction VCVTF32INTROUND from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- opc2 of type u8 from bit 16 to bit 18
*/
            /**- rm of type IEEE754RoundingMode from bit 16 to bit 17
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTF32INTROUND {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 18

*/
                pub(crate) opc2: u8,
                /**bit 16 to 17

*/
                /// TODO: This is incorrect according to the spec, see if this works or not.
                pub(crate) rm: IEEE754RoundingMode,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTF32INTROUND {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "sm",
                        "m",
                        "op",
                        "sz",
                        "sd",
                        "opc2",
                        "rm",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.sd,
                        &self.opc2,
                        &self.rm,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTF32INTROUND",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTF32INTROUND {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTF32INTROUND")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 18>() as u8)
                    };
                    let rm: IEEE754RoundingMode = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 17>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        sm,
                        m,
                        op,
                        sz,
                        sd,
                        opc2,
                        rm,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VCVTF64INTROUND from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- op of type bool from bit 7 to bit 7
*/
            /**- sz of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- opc2 of type u8 from bit 16 to bit 18
*/
            /**- rm of type IEEE754RoundingMode from bit 16 to bit 17
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTF64INTROUND {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) op: bool,
                /**bit 8 to 8

*/
                pub(crate) sz: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 18

*/
                pub(crate) opc2: u8,
                /**bit 16 to 17

*/
                /// TODO: This is incorrect according to the spec, see if this works or not.
                pub(crate) rm: IEEE754RoundingMode,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTF64INTROUND {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "dm",
                        "m",
                        "op",
                        "sz",
                        "dd",
                        "opc2",
                        "rm",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.m,
                        &self.op,
                        &self.sz,
                        &self.dd,
                        &self.opc2,
                        &self.rm,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTF64INTROUND",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTF64INTROUND {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTF64INTROUND")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sz: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let opc2: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 18>() as u8)
                    };
                    let rm: IEEE754RoundingMode = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 17>() as u8)
                            .try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        dm,
                        m,
                        op,
                        sz,
                        dd,
                        opc2,
                        rm,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VCVTF32FIXEDPOINT from table A6_5

*/
            /**Contains the following fields:
*/
            /**- sm of type u8 from bit 0 to bit 3
*/
            /**- i of type u8 from bit 1 to bit 1
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sx of type bool from bit 7 to bit 7
*/
            /**- sf of type bool from bit 8 to bit 8
*/
            /**- sd of type u8 from bit 12 to bit 15
*/
            /**- u of type bool from bit 16 to bit 16
*/
            /**- op of type bool from bit 18 to bit 18
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTF32FIXEDPOINT {
                /**bit 0 to 3

*/
                pub(crate) sm: u8,
                /**bit 1 to 1

*/
                pub(crate) i: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) sx: bool,
                /**bit 8 to 8

*/
                pub(crate) sf: bool,
                /**bit 12 to 15

*/
                pub(crate) sd: u8,
                /**bit 16 to 16

*/
                pub(crate) u: bool,
                /**bit 18 to 18

*/
                pub(crate) op: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTF32FIXEDPOINT {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "sm",
                        "i",
                        "m",
                        "sx",
                        "sf",
                        "sd",
                        "u",
                        "op",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.sm,
                        &self.i,
                        &self.m,
                        &self.sx,
                        &self.sf,
                        &self.sd,
                        &self.u,
                        &self.op,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTF32FIXEDPOINT",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTF32FIXEDPOINT {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTF32FIXEDPOINT")),
                    }?;
                    let sm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let i: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<1, 1>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sx: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sf: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 16>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<18, 18>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        sm,
                        i,
                        m,
                        sx,
                        sf,
                        sd,
                        u,
                        op,
                        d,
                    };
                    Ok(ret)
                }
            }
            /**Instruction VCVTF64FIXEDPOINT from table A6_5

*/
            /**Contains the following fields:
*/
            /**- dm of type u8 from bit 0 to bit 3
*/
            /**- i of type u8 from bit 1 to bit 1
*/
            /**- m of type u8 from bit 5 to bit 5
*/
            /**- sx of type bool from bit 7 to bit 7
*/
            /**- sf of type bool from bit 8 to bit 8
*/
            /**- dd of type u8 from bit 12 to bit 15
*/
            /**- u of type bool from bit 16 to bit 16
*/
            /**- op of type bool from bit 18 to bit 18
*/
            /**- d of type u8 from bit 22 to bit 22
*/
            pub struct VCVTF64FIXEDPOINT {
                /**bit 0 to 3

*/
                pub(crate) dm: u8,
                /**bit 1 to 1

*/
                pub(crate) i: u8,
                /**bit 5 to 5

*/
                pub(crate) m: u8,
                /**bit 7 to 7

*/
                pub(crate) sx: bool,
                /**bit 8 to 8

*/
                pub(crate) sf: bool,
                /**bit 12 to 15

*/
                pub(crate) dd: u8,
                /**bit 16 to 16

*/
                pub(crate) u: bool,
                /**bit 18 to 18

*/
                pub(crate) op: bool,
                /**bit 22 to 22

*/
                pub(crate) d: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for VCVTF64FIXEDPOINT {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "dm",
                        "i",
                        "m",
                        "sx",
                        "sf",
                        "dd",
                        "u",
                        "op",
                        "d",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dm,
                        &self.i,
                        &self.m,
                        &self.sx,
                        &self.sf,
                        &self.dd,
                        &self.u,
                        &self.op,
                        &&self.d,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "VCVTF64FIXEDPOINT",
                        names,
                        values,
                    )
                }
            }
            impl Parse for VCVTF64FIXEDPOINT {
                type Target = Self;
                #[allow(unused_variables)]
                fn parse<T: crate::Stream>(
                    iter: &mut T,
                ) -> Result<Self::Target, crate::ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = match iter.peek::<1>() {
                        Some(buff) => Ok(buff),
                        None => Err(ParseError::Invalid16Bit("VCVTF64FIXEDPOINT")),
                    }?;
                    let dm: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<0, 3>() as u8)
                    };
                    let i: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<1, 1>() as u8)
                    };
                    let m: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<5, 5>() as u8)
                    };
                    let sx: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<7, 7>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let sf: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<8, 8>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let dd: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<12, 15>() as u8)
                    };
                    let u: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<16, 16>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let op: bool = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<18, 18>() as u8)
                            .local_try_into()
                            .map_err(|e| map(e))?
                    };
                    let d: u8 = {
                        #[allow(dead_code)]
                        fn map<T: Into<ParseError>>(el: T) -> ParseError {
                            el.into()
                        }
                        ((word as u32).mask::<22, 22>() as u8)
                    };
                    let ret = Self {
                        dm,
                        i,
                        m,
                        sx,
                        sf,
                        dd,
                        u,
                        op,
                        d,
                    };
                    Ok(ret)
                }
            }
            impl Parse for A6_5 {
                type Target = Self;
                fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
                where
                    Self: Sized,
                {
                    let word: u32 = iter
                        .peek::<1>()
                        .ok_or(ParseError::IncompleteProgram)?;
                    let (t, opc1, opc2, sz, opc3, _opc4) = {
                        struct Parsed {
                            pub ident_1: u32,
                            pub ident_2: u32,
                            pub ident_4: u32,
                            pub ident_6: u32,
                            pub ident_3: u32,
                            pub ident_5: u32,
                        }
                        impl Parsed {
                            const fn mask<const START: usize, const END: usize>(
                                val: u32,
                            ) -> u32 {
                                let intermediate = val >> START;
                                let mask = ((1 << (END - START + 1) as u32) as u32) - 1u32;
                                let ret = intermediate & mask;
                                if !(ret <= mask) {
                                    ::core::panicking::panic("assertion failed: ret <= mask")
                                }
                                ret
                            }
                            const fn parse(
                                mut self,
                                value: u32,
                            ) -> (u32, u32, u32, u32, u32, u32) {
                                self.ident_1 = Self::mask::<28usize, 28usize>(value);
                                self.ident_2 = Self::mask::<20usize, 23usize>(value);
                                self.ident_4 = Self::mask::<8usize, 8usize>(value);
                                self.ident_6 = Self::mask::<0usize, 3usize>(value);
                                self.ident_3 = Self::mask::<16usize, 19usize>(value);
                                self.ident_5 = Self::mask::<6usize, 7usize>(value);
                                (
                                    self.ident_1,
                                    self.ident_2,
                                    self.ident_4,
                                    self.ident_6,
                                    self.ident_3,
                                    self.ident_5,
                                )
                            }
                            const fn zero() -> Self {
                                Self {
                                    ident_1: 0,
                                    ident_2: 0,
                                    ident_4: 0,
                                    ident_6: 0,
                                    ident_3: 0,
                                    ident_5: 0,
                                }
                            }
                        }
                        Parsed::zero().parse(word)
                    };
                    if opc1 >> 3 == 0 && t == 1 {
                        if sz == 0 {
                            return Ok(Self::VSELF32(VSELF32::parse(iter)?));
                        }
                        return Ok(Self::VSELF64(VSELF64::parse(iter)?));
                    }
                    if opc1 & 11u32 == 0u32 && t == 0 && sz == 0 {
                        return Ok(Self::VMLXF32(VMLXF32::parse(iter)?));
                    }
                    if opc1 & 11u32 == 0u32 && t == 0 && sz == 1 {
                        return Ok(Self::VMLXF32(VMLXF32::parse(iter)?));
                    }
                    if opc1 & 11u32 == 1u32 && t == 0 && sz == 0 {
                        return Self::parse_vnmulf32(iter);
                    }
                    if opc1 & 11u32 == 1u32 && t == 0 && sz == 1 {
                        return Self::parse_vnmulf64(iter);
                    }
                    if opc1 & 11u32 == 2u32 && t == 0 && opc3 & 1u32 == 1u32 && sz == 0 {
                        return Self::parse_vnmulf32(iter);
                    }
                    if opc1 & 11u32 == 2u32 && t == 0 && opc3 & 1u32 == 1u32 && sz == 1 {
                        return Self::parse_vnmulf32(iter);
                    }
                    if opc1 & 11u32 == 2u32 && t == 0 && opc3 & 1u32 == 0u32 && sz == 0 {
                        return Self::parse_vmulf32(iter);
                    }
                    if opc1 & 11u32 == 2u32 && t == 0 && opc3 & 1u32 == 0u32 && sz == 1 {
                        return Self::parse_vmulf32(iter);
                    }
                    if opc1 & 11u32 == 3u32 && t == 0 && opc3 & 1u32 == 0u32 && sz == 0 {
                        return Self::parse_vaddf32(iter);
                    }
                    if opc1 & 11u32 == 3u32 && t == 0 && opc3 & 1u32 == 0u32 && sz == 1 {
                        return Self::parse_vaddf64(iter);
                    }
                    if opc1 & 11u32 == 3u32 && t == 0 && opc3 & 1u32 == 1u32 && sz == 0 {
                        return Self::parse_vsubf32(iter);
                    }
                    if opc1 & 11u32 == 3u32 && t == 0 && opc3 & 1u32 == 1u32 && sz == 1 {
                        return Self::parse_vsubf64(iter);
                    }
                    if opc1 & 11u32 == 8u32 && t == 0 && opc3 & 1u32 == 0u32 && sz == 0 {
                        return Self::parse_vdivf32(iter);
                    }
                    if opc1 & 11u32 == 8u32 && t == 0 && opc3 & 1u32 == 0u32 && sz == 1 {
                        return Self::parse_vdivf64(iter);
                    }
                    if opc1 & 11u32 == 8u32 && t == 1 && opc3 & 1u32 == 0u32 && sz == 0 {
                        return Self::parse_vxnmf32(iter);
                    }
                    if opc1 & 11u32 == 8u32 && t == 1 && opc3 & 1u32 == 0u32 && sz == 1 {
                        return Self::parse_vxnmf64(iter);
                    }
                    if !(opc1 & 11u32 == 11u32) {
                        return Err(
                            ParseError::Invalid32Bit(
                                "Not a valid floatingpoint instruction, opc1",
                            ),
                        );
                    }
                    if t == 1 {
                        if opc2 & 12u32 == 8u32 && opc3 == 01 && sz == 0 {
                            return Self::parse_vrintroundf32(iter);
                        }
                        if opc2 & 12u32 == 8u32 && opc3 == 01 && sz == 1 {
                            return Self::parse_vrintroundf64(iter);
                        }
                        if opc2 & 12u32 == 12u32 && opc3 & 1u32 == 1u32 && sz == 0 {
                            return Self::parse_vcvtxf32(iter);
                        }
                        if opc2 & 12u32 == 12u32 && opc3 & 1u32 == 1u32 && sz == 1 {
                            return Self::parse_vcvtxf64(iter);
                        }
                        return Err(
                            ParseError::Invalid32Bit(
                                "Invalid floating point operation, t1 == 1",
                            ),
                        );
                    }
                    if opc3 & 1u32 == 0u32 && sz == 0 {
                        return Self::parse_vmovimmf32(iter);
                    }
                    if opc3 & 1u32 == 0u32 && sz == 1 {
                        return Self::parse_vmovimmf64(iter);
                    }
                    if opc2 & 15u32 == 0u32 && opc3 & 3u32 == 1u32 && sz == 0 {
                        return Self::parse_vmovregf32(iter);
                    }
                    if opc2 & 15u32 == 0u32 && opc3 & 3u32 == 1u32 && sz == 1 {
                        return Self::parse_vmovregf64(iter);
                    }
                    if opc2 & 15u32 == 0u32 && opc3 & 3u32 == 3u32 && sz == 0 {
                        return Self::parse_vabsf32(iter);
                    }
                    if opc2 & 15u32 == 0u32 && opc3 & 3u32 == 3u32 && sz == 1 {
                        return Self::parse_vabsf64(iter);
                    }
                    if opc2 & 15u32 == 1u32 && opc3 & 3u32 == 1u32 && sz == 0 {
                        return Self::parse_vnegf32(iter);
                    }
                    if opc2 & 15u32 == 1u32 && opc3 & 3u32 == 1u32 && sz == 1 {
                        return Self::parse_vnegf64(iter);
                    }
                    if opc2 & 15u32 == 1u32 && opc3 & 3u32 == 3u32 && sz == 0 {
                        return Self::parse_vsqrtf32(iter);
                    }
                    if opc2 & 15u32 == 1u32 && opc3 & 3u32 == 3u32 && sz == 1 {
                        return Self::parse_vsqrtf64(iter);
                    }
                    if opc2 & 14u32 == 2u32 && opc3 & 1u32 == 1u32 && sz == 0 {
                        return Self::parse_vcvtxf32(iter);
                    }
                    if opc2 & 14u32 == 2u32 && opc3 & 1u32 == 1u32 && sz == 1 {
                        return Self::parse_vcvtxf64(iter);
                    }
                    if opc2 & 15u32 == 4u32 && opc3 & 1u32 == 1u32 && sz == 0 {
                        return Self::parse_vcmpregf32(iter);
                    }
                    if opc2 & 15u32 == 4u32 && opc3 & 1u32 == 1u32 && sz == 1 {
                        return Self::parse_vcmpregf64(iter);
                    }
                    if opc2 & 15u32 == 5u32 && opc3 & 1u32 == 1u32 && sz == 0 {
                        return Self::parse_vcmpzerof32(iter);
                    }
                    if opc2 & 15u32 == 5u32 && opc3 & 1u32 == 1u32 && sz == 1 {
                        return Self::parse_vcmpzerof64(iter);
                    }
                    if opc2 & 14u32 == 6u32 && opc3 & 1u32 == 1u32 && sz == 0 {
                        return Self::parse_vrintf32(iter);
                    }
                    if opc2 & 14u32 == 6u32 && opc3 & 1u32 == 1u32 && sz == 1 {
                        return Self::parse_vrintf64(iter);
                    }
                    if opc2 & 15u32 == 7u32 && opc3 & 3u32 == 3u32 && sz == 0 {
                        return Self::parse_vcvtf64f32(iter);
                    }
                    if opc2 & 15u32 == 7u32 && opc3 & 3u32 == 3u32 && sz == 1 {
                        return Self::parse_vcvtf32f64(iter);
                    }
                    if (opc2 & 15u32 == 8u32 || opc2 & 14u32 == 12u32)
                        && opc3 & 1u32 == 1u32
                    {
                        return Self::parse_vcvtintxintxfloat(iter);
                    }
                    if opc2 & 10u32 == 10u32 && opc3 & 1u32 == 1u32 && sz == 0 {
                        return Self::parse_vcvtf32fixedpoint(iter);
                    }
                    if opc2 & 10u32 == 10u32 && opc3 & 1u32 == 1u32 && sz == 1 {
                        return Self::parse_vcvtf64fixedpoint(iter);
                    }
                    return Err(
                        ParseError::Invalid32Bit(
                            "Invalid data processing floating point instruction.",
                        ),
                    );
                }
            }
            impl ToOperation for A6_5 {
                fn encoding_specific_operations(self) -> crate::operation::Operation {
                    ::core::panicking::panic("not yet implemented")
                }
            }
        }
        use crate::{
            asm::{b32::a5_30::A5_30, Mask},
            Parse, ParseError, ToOperation,
        };
        /// A 32-bit wide instruction
        pub enum B32 {}
        impl Parse for B32 {
            type Target = (usize, crate::operation::Operation);
            fn parse<T: crate::Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
            where
                Self: Sized,
            {
                let ret = match Self::parse_internal(iter) {
                    Ok(e) => e,
                    Err(e) => {
                        return Err(e);
                    }
                };
                let _: u32 = match iter.consume::<1>() {
                    Some(val) => val[0],
                    None => return Err(ParseError::IncompleteProgram),
                };
                Ok((32, ret))
            }
        }
        /// A 32-bit wide instruction
        impl B32 {
            fn parse_internal<T: crate::Stream>(
                iter: &mut T,
            ) -> Result<crate::operation::Operation, crate::ParseError> {
                let word: u32 = match iter.peek::<1>() {
                    Some(value) => value,
                    None => return Err(ParseError::IncompleteProgram),
                };
                let op1 = word.mask::<{ 16 + 11 }, { 16 + 12 }>();
                let op2 = word.mask::<{ 16 + 4 }, { 16 + 10 }>();
                let op = word.mask::<15, 15>();
                if op1 > 3 {
                    return Err(ParseError::InternalError("Masking is broken op1 > 3"));
                }
                if op > 1 {
                    return Err(ParseError::InternalError("Masking is broken op > 1"));
                }
                if op1 == 1 {
                    if ((op2 >> 2) & 0b11001) == 0b00000 {
                        return Ok(
                            a5_16::A5_16::parse(iter)?.encoding_specific_operations(),
                        );
                    }
                    if ((op2 >> 2) & 0b11001) == 0b00001 {
                        return Ok(
                            a5_17::A5_17::parse(iter)?.encoding_specific_operations(),
                        );
                    }
                    if (op2 >> 5) == 1 {
                        return Ok(
                            a5_22::A5_22::parse(iter)?.encoding_specific_operations(),
                        );
                    }
                    if (op2 >> 6) == 1 {
                        return Ok(
                            a5_30::A5_30::parse(iter)?.encoding_specific_operations(),
                        );
                    }
                    return Err(ParseError::Invalid32Bit("Invalid op2"));
                }
                if op1 == 2 {
                    if op == 0 {
                        if (op2 & 0b0100000) == 0 {
                            return Ok(
                                a5_10::A5_10::parse(iter)?.encoding_specific_operations(),
                            );
                        }
                        return Ok(
                            a5_12::A5_12::parse(iter)?.encoding_specific_operations(),
                        );
                    }
                    return Ok(a5_13::A5_13::parse(iter)?.encoding_specific_operations());
                }
                if (op2 & 0b1110001) == 0b0000000 {
                    return Ok(a5_21::A5_21::parse(iter)?.encoding_specific_operations());
                }
                match op2 & 0b1100111 {
                    0b0000001 => {
                        return Ok(
                            a5_20::A5_20::parse(iter)?.encoding_specific_operations(),
                        );
                    }
                    0b0000011 => {
                        return Ok(
                            a5_19::A5_19::parse(iter)?.encoding_specific_operations(),
                        );
                    }
                    0b0000101 => {
                        return Ok(
                            a5_18::A5_18::parse(iter)?.encoding_specific_operations(),
                        );
                    }
                    0b0000111 => return Err(ParseError::Undefined),
                    _ => {}
                }
                if op2 >> 4 == 2 {
                    return Ok(a5_24::A5_24::parse(iter)?.encoding_specific_operations());
                }
                if op2 >> 3 == 0b0110 {
                    return Ok(a5_28::A5_28::parse(iter)?.encoding_specific_operations());
                }
                if op2 >> 3 == 0b0111 {
                    return Ok(a5_29::A5_29::parse(iter)?.encoding_specific_operations());
                }
                if op2 >> 6 == 1 {
                    return Ok(A5_30::parse(iter)?.encoding_specific_operations());
                }
                Err(ParseError::Invalid32Bit(""))
            }
        }
    }
    pub(crate) trait LocalTryInto<T> {
        fn local_try_into(self) -> Result<T, ParseError>;
    }
    pub(crate) trait Mask {
        fn mask<const START: usize, const END: usize>(&self) -> Self;
    }
    impl LocalTryInto<bool> for u8 {
        fn local_try_into(self) -> Result<bool, ParseError> {
            if self > 1 {
                return Err(
                    ParseError::InvalidField(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Invalid masking of bool {0}", self),
                            );
                            res
                        }),
                    ),
                );
            }
            Ok(self != 0)
        }
    }
    impl LocalTryInto<bool> for u32 {
        fn local_try_into(self) -> Result<bool, ParseError> {
            if self > 1 {
                return Err(
                    ParseError::InvalidField(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Invalid masking of bool {0}", self),
                            );
                            res
                        }),
                    ),
                );
            }
            Ok(self != 0)
        }
    }
    impl Mask for u16 {
        fn mask<const START: usize, const END: usize>(&self) -> u16 {
            let intermediate = self >> START;
            let mask = ((1 << (END - START + 1) as u16) as u16) - 1u16;
            let ret = intermediate & mask;
            if !(ret <= mask) {
                ::core::panicking::panic("assertion failed: ret <= mask")
            }
            ret
        }
    }
    impl Mask for u32 {
        fn mask<const START: usize, const END: usize>(&self) -> u32 {
            let intermediate = self >> START;
            let mask = ((1 << (END - START + 1) as u32) as u32) - 1u32;
            let ret = intermediate & mask;
            if !(ret <= mask) {
                ::core::panicking::panic("assertion failed: ret <= mask")
            }
            ret
        }
    }
}
pub mod buffer {
    //! Defines a peekable buffer.
    //!
    //! This modules main export is the [`PeekableBuffer`]
    //! which allows the implementors of [`Parse`](crate::Parse)
    //! to get the next element in the buffer without consuming it.
    //! It also reorders the bytes to conform to the byte order of the
    //! Armv7 encoding, this allows for a 1:1 parsing in the implementors
    //! of [`Parse`](crate::Parse).
    //!
    //!
    //! ## Usage
    //!
    //! ```
    //! use disarmv7::prelude::*;
    //! // The iterator reverses the order of the halfwords
    //! let input_data = [1,0,3,2,5,4,7,6];
    //!
    //! // Needs to be mutable as the value is consumed from the iterator
    //! // and moved in to a intermediate buffer.
    //! let mut buffer: PeekableBuffer<u8,_> = input_data.into_iter().into();
    //!
    //! let value: u16 = buffer.peek::<1>().unwrap();
    //! println!("Value : {value}");
    //! assert!(value == 1);
    //!
    //! // The byte order is corrected when peeking bytes
    //! let value: u8 = buffer.peek::<1>().unwrap();
    //! println!("Value : {value}");
    //! assert!(value == 0);
    //!
    //! // The byte order is corrected when peeking bytes
    //! let value: u8 = buffer.peek::<2>().unwrap();
    //! println!("Value : {value}");
    //! assert!(value == 1);
    //!
    //! let value: u32 = buffer.peek::<1>().unwrap();
    //! let target:u32 = ((0<<8|1) << 16) | (2<<8|3);
    //! println!("Value : {value}");
    //! println!("Target : {target}");
    //! assert!(value == target);
    //! ```
    use std::{fmt::Debug, usize};
    use crate::{Consume, Peek, Stream};
    /// A buffer that allows non intrusive peeking in linear time.
    ///
    /// This type allows the user to [`peek`](PeekableBuffer::peek) the `N` next
    /// elements in the buffer, without mutating it. Moreover if the buffer is not
    /// large enough and the user tries to [`consume`](PeekableBuffer::consume) `N`
    /// elements from it and the buffer does not have `N` elements, no elements are
    /// consumed and an error is returned.
    pub struct PeekableBuffer<I: Sized, T: Iterator<Item = I>> {
        iter: T,
        peeked_elements: Vec<u8>,
    }
    #[automatically_derived]
    impl<
        I: ::core::fmt::Debug + Sized,
        T: ::core::fmt::Debug + Iterator<Item = I>,
    > ::core::fmt::Debug for PeekableBuffer<I, T> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "PeekableBuffer",
                "iter",
                &self.iter,
                "peeked_elements",
                &&self.peeked_elements,
            )
        }
    }
    impl<T: Sized + Iterator<Item = u8>> PeekableBuffer<u8, T> {
        #[inline(always)]
        fn peek_count(&mut self) -> bool {
            let mut ret = [0_u8; 2];
            let mut counter = 0;
            ret.iter_mut()
                .for_each(|t| {
                    if let Some(el) = self.iter.next() {
                        *t = el;
                        counter += 1;
                    }
                });
            let intermediate = &u16::from_le_bytes(ret).to_ne_bytes()[0..counter];
            self.peeked_elements.extend(intermediate.iter().rev());
            counter == 2
        }
    }
    impl<T: Sized + Iterator<Item = u8>> Peek<u32> for PeekableBuffer<u8, T>
    where
        Self: Peek<u16>,
    {
        fn peek<const N: usize>(&mut self) -> Option<u32> {
            let first: u16 = self.peek::<1>()?;
            let second: u16 = self.peek::<2>()?;
            let ret = ((first as u32) << 16) | (second as u32);
            Some(ret)
        }
    }
    impl<T: Sized + Iterator<Item = u8>> Peek<u16> for PeekableBuffer<u8, T> {
        fn peek<const N: usize>(&mut self) -> Option<u16> {
            let mut peeked = self.peeked_elements.len();
            while peeked < N * 2 {
                if !self.peek_count() {
                    return None;
                }
                peeked = self.peeked_elements.len();
            }
            let offset = (N - 1) * 2;
            let els = &self.peeked_elements;
            let data = [els[offset + 1], els[offset]];
            Some(u16::from_ne_bytes(data))
        }
    }
    impl<T: Sized + Iterator<Item = u8>> Peek<u8> for PeekableBuffer<u8, T> {
        fn peek<const N: usize>(&mut self) -> Option<u8> {
            let mut peeked = self.peeked_elements.len();
            while peeked < N {
                if !self.peek_count() {
                    return None;
                }
                peeked = self.peeked_elements.len();
            }
            Some(self.peeked_elements[N - 1])
        }
    }
    impl<T: Iterator<Item = u8> + Debug> Consume<u32> for PeekableBuffer<u8, T> {
        fn consume<const N: usize>(&mut self) -> Option<[u32; N]> {
            <Self as Peek<u32>>::peek::<N>(self)?;
            if N == 1 {
                let [first, second]: [u16; 2] = self.consume::<2>()?;
                return Some([((first as u32) << 16) | (second as u32); N]);
            }
            let mut ret = [0; N];
            for el in ret.iter_mut() {
                *el = self.consume::<1>()?[0];
            }
            Some(ret)
        }
    }
    impl<T: Iterator<Item = u8> + Debug> Consume<u16> for PeekableBuffer<u8, T> {
        fn consume<const N: usize>(&mut self) -> Option<[u16; N]> {
            <Self as Peek<u16>>::peek::<N>(self)?;
            if N == 1 {
                let [first, second]: [u8; 2] = self.consume::<2>()?;
                return Some([u16::from_ne_bytes([second, first]); N]);
            }
            let mut ret = [0; N];
            for el in ret.iter_mut() {
                *el = self.consume::<1>()?[0];
            }
            Some(ret)
        }
    }
    impl<T: Iterator<Item = u8> + Debug> Consume<u8> for PeekableBuffer<u8, T> {
        fn consume<const N: usize>(&mut self) -> Option<[u8; N]> {
            <Self as Peek<u8>>::peek::<N>(self)?;
            if N == 1 {
                return match self.peeked_elements.first() {
                    Some(_val) => Some([self.peeked_elements.remove(0); N]),
                    None => {
                        let _: u8 = self.peek::<1>()?;
                        self.consume()
                    }
                };
            }
            let mut ret = [0; N];
            for el in ret.iter_mut() {
                *el = self.consume::<1>()?[0];
            }
            Some(ret)
        }
    }
    impl<T: Iterator<Item = u8> + Debug> Stream for PeekableBuffer<u8, T> {}
    impl<I: Sized, T: Iterator<Item = I>> From<T> for PeekableBuffer<I, T> {
        fn from(iter: T) -> Self {
            Self {
                iter,
                peeked_elements: Vec::new(),
            }
        }
    }
}
mod helpers {
    //! Defines some internal helpers
    //!
    //! Main macros is the [`instruction`] macro.
    //! This provides the ability to create a new instruction
    //! in a short and readable way.
    use crate::{arch::ArchError, ParseError};
    impl From<ArchError> for ParseError {
        fn from(value: ArchError) -> Self {
            Self::ArchError(value)
        }
    }
}
pub mod operation {
    //! Creates the [`Operation`] enum.
    #![allow(missing_docs)]
    use builder_derive::{Builder, Consumer};
    use crate::arch::{
        condition::{Condition, ITCondition},
        coproc::CoProcessor,
        register::{
            F32Register, F64Register, IEEE754RoundingMode, Register, RegisterList,
        },
        shift::ImmShift, wrapper_types::*, SetFlags,
    };
    pub struct AdcImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct AdcImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > AdcImmediateBuilder<false, rdSET, rnSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> AdcImmediateBuilder<true, rdSET, rnSET, immSET> {
            self.s = Some(s);
            AdcImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > AdcImmediateBuilder<sSET, false, rnSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> AdcImmediateBuilder<sSET, true, rnSET, immSET> {
            self.rd = Some(rd);
            AdcImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > AdcImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> AdcImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rn = Some(rn);
            AdcImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > AdcImmediateBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> AdcImmediateBuilder<sSET, rdSET, rnSET, true> {
            self.imm = Some(imm);
            AdcImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl AdcImmediateBuilder<false, false, false, false> {
        pub fn new() -> AdcImmediateBuilder<false, false, false, false> {
            AdcImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl AdcImmediate {
        pub fn builder() -> AdcImmediateBuilder<false, false, false, false> {
            AdcImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl AdcImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> AdcImmediate {
            AdcImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct AdcImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > AdcImmediateConsumer<false, rdCONSUMED, rnCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            AdcImmediateConsumer<true, rdCONSUMED, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AdcImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > AdcImmediateConsumer<sCONSUMED, false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            AdcImmediateConsumer<sCONSUMED, true, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AdcImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > AdcImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, AdcImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                AdcImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > AdcImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, AdcImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                AdcImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl AdcImmediate {
        pub fn consumer(self) -> AdcImmediateConsumer<false, false, false, false> {
            AdcImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl AdcImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AdcImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AdcImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AdcImmediate {
        #[inline]
        fn clone(&self) -> AdcImmediate {
            AdcImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AdcImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AdcImmediate {
        #[inline]
        fn eq(&self, other: &AdcImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.imm == other.imm
        }
    }
    impl From<AdcImmediate> for Operation {
        fn from(val: AdcImmediate) -> Operation {
            Operation::AdcImmediate(val)
        }
    }
    pub struct AdcRegister {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct AdcRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AdcRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> AdcRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            AdcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AdcRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> AdcRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            AdcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AdcRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> AdcRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            AdcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > AdcRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> AdcRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            AdcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > AdcRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> AdcRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            AdcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl AdcRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> AdcRegisterBuilder<false, false, false, false, false> {
            AdcRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl AdcRegister {
        pub fn builder() -> AdcRegisterBuilder<false, false, false, false, false> {
            AdcRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl AdcRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> AdcRegister {
            AdcRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct AdcRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AdcRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            AdcRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AdcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AdcRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            AdcRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AdcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AdcRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            AdcRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                AdcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AdcRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            AdcRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                AdcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > AdcRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            AdcRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                AdcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl AdcRegister {
        pub fn consumer(self) -> AdcRegisterConsumer<false, false, false, false, false> {
            AdcRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl AdcRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AdcRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "AdcRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AdcRegister {
        #[inline]
        fn clone(&self) -> AdcRegister {
            AdcRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AdcRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AdcRegister {
        #[inline]
        fn eq(&self, other: &AdcRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<AdcRegister> for Operation {
        fn from(val: AdcRegister) -> Operation {
            Operation::AdcRegister(val)
        }
    }
    pub struct AddImmediate {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct AddImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > AddImmediateBuilder<false, rdSET, rnSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> AddImmediateBuilder<true, rdSET, rnSET, immSET> {
            self.s = Some(s);
            AddImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > AddImmediateBuilder<sSET, false, rnSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> AddImmediateBuilder<sSET, true, rnSET, immSET> {
            self.rd = Some(rd);
            AddImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > AddImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> AddImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rn = Some(rn);
            AddImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > AddImmediateBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> AddImmediateBuilder<sSET, rdSET, rnSET, true> {
            self.imm = Some(imm);
            AddImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl AddImmediateBuilder<false, false, false, false> {
        pub fn new() -> AddImmediateBuilder<false, false, false, false> {
            AddImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl AddImmediate {
        pub fn builder() -> AddImmediateBuilder<false, false, false, false> {
            AddImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl AddImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> AddImmediate {
            AddImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct AddImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > AddImmediateConsumer<false, rdCONSUMED, rnCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            AddImmediateConsumer<true, rdCONSUMED, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AddImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > AddImmediateConsumer<sCONSUMED, false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            AddImmediateConsumer<sCONSUMED, true, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AddImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > AddImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, AddImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                AddImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > AddImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, AddImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                AddImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl AddImmediate {
        pub fn consumer(self) -> AddImmediateConsumer<false, false, false, false> {
            AddImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl AddImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AddImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AddImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AddImmediate {
        #[inline]
        fn clone(&self) -> AddImmediate {
            AddImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AddImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AddImmediate {
        #[inline]
        fn eq(&self, other: &AddImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.imm == other.imm
        }
    }
    impl From<AddImmediate> for Operation {
        fn from(val: AddImmediate) -> Operation {
            Operation::AddImmediate(val)
        }
    }
    pub struct AddRegister {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct AddRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AddRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> AddRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            AddRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AddRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> AddRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            AddRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AddRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> AddRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            AddRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > AddRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> AddRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            AddRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > AddRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> AddRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            AddRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl AddRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> AddRegisterBuilder<false, false, false, false, false> {
            AddRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl AddRegister {
        pub fn builder() -> AddRegisterBuilder<false, false, false, false, false> {
            AddRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl AddRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> AddRegister {
            AddRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct AddRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AddRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            AddRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AddRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AddRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            AddRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AddRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AddRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            AddRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                AddRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AddRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            AddRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                AddRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > AddRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            AddRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                AddRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl AddRegister {
        pub fn consumer(self) -> AddRegisterConsumer<false, false, false, false, false> {
            AddRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl AddRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AddRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "AddRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AddRegister {
        #[inline]
        fn clone(&self) -> AddRegister {
            AddRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AddRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AddRegister {
        #[inline]
        fn eq(&self, other: &AddRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<AddRegister> for Operation {
        fn from(val: AddRegister) -> Operation {
            Operation::AddRegister(val)
        }
    }
    pub struct AddSPImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub imm: u32,
    }
    pub struct AddSPImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const immSET: bool,
    > AddSPImmediateBuilder<false, rdSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> AddSPImmediateBuilder<true, rdSET, immSET> {
            self.s = Some(s);
            AddSPImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const immSET: bool,
    > AddSPImmediateBuilder<sSET, false, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> AddSPImmediateBuilder<sSET, true, immSET> {
            self.rd = Some(rd);
            AddSPImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
            }
        }
    }
    impl<const sSET: bool, const rdSET: bool> AddSPImmediateBuilder<sSET, rdSET, false> {
        pub fn set_imm(mut self, imm: u32) -> AddSPImmediateBuilder<sSET, rdSET, true> {
            self.imm = Some(imm);
            AddSPImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
            }
        }
    }
    impl AddSPImmediateBuilder<false, false, false> {
        pub fn new() -> AddSPImmediateBuilder<false, false, false> {
            AddSPImmediateBuilder {
                s: None,
                rd: None,
                imm: None,
            }
        }
    }
    impl AddSPImmediate {
        pub fn builder() -> AddSPImmediateBuilder<false, false, false> {
            AddSPImmediateBuilder {
                s: None,
                rd: None,
                imm: None,
            }
        }
    }
    impl AddSPImmediateBuilder<true, true, true> {
        pub fn complete(self) -> AddSPImmediate {
            AddSPImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct AddSPImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > AddSPImmediateConsumer<false, rdCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (Option<bool>, AddSPImmediateConsumer<true, rdCONSUMED, immCONSUMED>) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AddSPImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const immCONSUMED: bool,
    > AddSPImmediateConsumer<sCONSUMED, false, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, AddSPImmediateConsumer<sCONSUMED, true, immCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AddSPImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
    > AddSPImmediateConsumer<sCONSUMED, rdCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, AddSPImmediateConsumer<sCONSUMED, rdCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                AddSPImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                },
            )
        }
    }
    impl AddSPImmediate {
        pub fn consumer(self) -> AddSPImmediateConsumer<false, false, false> {
            AddSPImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                imm: Some(self.imm),
            }
        }
    }
    impl AddSPImmediateConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AddSPImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "AddSPImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AddSPImmediate {
        #[inline]
        fn clone(&self) -> AddSPImmediate {
            AddSPImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AddSPImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AddSPImmediate {
        #[inline]
        fn eq(&self, other: &AddSPImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.imm == other.imm
        }
    }
    impl From<AddSPImmediate> for Operation {
        fn from(val: AddSPImmediate) -> Operation {
            Operation::AddSPImmediate(val)
        }
    }
    pub struct AddSPRegister {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct AddSPRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AddSPRegisterBuilder<false, rdSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> AddSPRegisterBuilder<true, rdSET, rmSET, shiftSET> {
            self.s = Some(s);
            AddSPRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AddSPRegisterBuilder<sSET, false, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> AddSPRegisterBuilder<sSET, true, rmSET, shiftSET> {
            self.rd = Some(rd);
            AddSPRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const shiftSET: bool,
    > AddSPRegisterBuilder<sSET, rdSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> AddSPRegisterBuilder<sSET, rdSET, true, shiftSET> {
            self.rm = Some(rm);
            AddSPRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > AddSPRegisterBuilder<sSET, rdSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> AddSPRegisterBuilder<sSET, rdSET, rmSET, true> {
            self.shift = Some(shift);
            AddSPRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl AddSPRegisterBuilder<false, false, false, false> {
        pub fn new() -> AddSPRegisterBuilder<false, false, false, false> {
            AddSPRegisterBuilder {
                s: None,
                rd: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl AddSPRegister {
        pub fn builder() -> AddSPRegisterBuilder<false, false, false, false> {
            AddSPRegisterBuilder {
                s: None,
                rd: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl AddSPRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> AddSPRegister {
            AddSPRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct AddSPRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AddSPRegisterConsumer<false, rdCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            AddSPRegisterConsumer<true, rdCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AddSPRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AddSPRegisterConsumer<sCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            AddSPRegisterConsumer<sCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AddSPRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AddSPRegisterConsumer<sCONSUMED, rdCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            AddSPRegisterConsumer<sCONSUMED, rdCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                AddSPRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > AddSPRegisterConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            AddSPRegisterConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                AddSPRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl AddSPRegister {
        pub fn consumer(self) -> AddSPRegisterConsumer<false, false, false, false> {
            AddSPRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl AddSPRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AddSPRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AddSPRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AddSPRegister {
        #[inline]
        fn clone(&self) -> AddSPRegister {
            AddSPRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AddSPRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AddSPRegister {
        #[inline]
        fn eq(&self, other: &AddSPRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<AddSPRegister> for Operation {
        fn from(val: AddSPRegister) -> Operation {
            Operation::AddSPRegister(val)
        }
    }
    pub struct Adr {
        pub rd: Register,
        pub add: bool,
        pub imm: u32,
    }
    pub struct AdrBuilder<const rdSET: bool, const addSET: bool, const immSET: bool> {
        rd: Option<Register>,
        add: Option<bool>,
        imm: Option<u32>,
    }
    impl<const addSET: bool, const immSET: bool> AdrBuilder<false, addSET, immSET> {
        pub fn set_rd(mut self, rd: Register) -> AdrBuilder<true, addSET, immSET> {
            self.rd = Some(rd);
            AdrBuilder {
                rd: self.rd,
                add: self.add,
                imm: self.imm,
            }
        }
    }
    impl<const rdSET: bool, const immSET: bool> AdrBuilder<rdSET, false, immSET> {
        pub fn set_add(mut self, add: bool) -> AdrBuilder<rdSET, true, immSET> {
            self.add = Some(add);
            AdrBuilder {
                rd: self.rd,
                add: self.add,
                imm: self.imm,
            }
        }
    }
    impl<const rdSET: bool, const addSET: bool> AdrBuilder<rdSET, addSET, false> {
        pub fn set_imm(mut self, imm: u32) -> AdrBuilder<rdSET, addSET, true> {
            self.imm = Some(imm);
            AdrBuilder {
                rd: self.rd,
                add: self.add,
                imm: self.imm,
            }
        }
    }
    impl AdrBuilder<false, false, false> {
        pub fn new() -> AdrBuilder<false, false, false> {
            AdrBuilder {
                rd: None,
                add: None,
                imm: None,
            }
        }
    }
    impl Adr {
        pub fn builder() -> AdrBuilder<false, false, false> {
            AdrBuilder {
                rd: None,
                add: None,
                imm: None,
            }
        }
    }
    impl AdrBuilder<true, true, true> {
        pub fn complete(self) -> Adr {
            Adr {
                rd: self.rd.unwrap(),
                add: self.add.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct AdrConsumer<const rdSET: bool, const addSET: bool, const immSET: bool> {
        rd: Option<Register>,
        add: Option<bool>,
        imm: Option<u32>,
    }
    impl<
        const addCONSUMED: bool,
        const immCONSUMED: bool,
    > AdrConsumer<false, addCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, AdrConsumer<true, addCONSUMED, immCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AdrConsumer {
                    rd: self.rd,
                    add: self.add,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > AdrConsumer<rdCONSUMED, false, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (bool, AdrConsumer<rdCONSUMED, true, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                AdrConsumer {
                    rd: self.rd,
                    add: self.add,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const addCONSUMED: bool,
    > AdrConsumer<rdCONSUMED, addCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, AdrConsumer<rdCONSUMED, addCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                AdrConsumer {
                    rd: self.rd,
                    add: self.add,
                    imm: self.imm,
                },
            )
        }
    }
    impl Adr {
        pub fn consumer(self) -> AdrConsumer<false, false, false> {
            AdrConsumer {
                rd: Some(self.rd),
                add: Some(self.add),
                imm: Some(self.imm),
            }
        }
    }
    impl AdrConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Adr {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Adr",
                "rd",
                &self.rd,
                "add",
                &self.add,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Adr {
        #[inline]
        fn clone(&self) -> Adr {
            Adr {
                rd: ::core::clone::Clone::clone(&self.rd),
                add: ::core::clone::Clone::clone(&self.add),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Adr {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Adr {
        #[inline]
        fn eq(&self, other: &Adr) -> bool {
            self.rd == other.rd && self.add == other.add && self.imm == other.imm
        }
    }
    impl From<Adr> for Operation {
        fn from(val: Adr) -> Operation {
            Operation::Adr(val)
        }
    }
    pub struct AndImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub imm: u32,
        pub carry: Option<bool>,
    }
    pub struct AndImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
        carry: Option<Option<bool>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > AndImmediateBuilder<false, rdSET, rnSET, immSET, carrySET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> AndImmediateBuilder<true, rdSET, rnSET, immSET, carrySET> {
            self.s = Some(s);
            AndImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > AndImmediateBuilder<sSET, false, rnSET, immSET, carrySET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> AndImmediateBuilder<sSET, true, rnSET, immSET, carrySET> {
            self.rd = Some(rd);
            AndImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > AndImmediateBuilder<sSET, rdSET, false, immSET, carrySET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> AndImmediateBuilder<sSET, rdSET, true, immSET, carrySET> {
            self.rn = Some(rn);
            AndImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
    > AndImmediateBuilder<sSET, rdSET, rnSET, false, carrySET> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> AndImmediateBuilder<sSET, rdSET, rnSET, true, carrySET> {
            self.imm = Some(imm);
            AndImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > AndImmediateBuilder<sSET, rdSET, rnSET, immSET, false> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> AndImmediateBuilder<sSET, rdSET, rnSET, immSET, true> {
            self.carry = Some(carry);
            AndImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl AndImmediateBuilder<false, false, false, false, false> {
        pub fn new() -> AndImmediateBuilder<false, false, false, false, false> {
            AndImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
                carry: None,
            }
        }
    }
    impl AndImmediate {
        pub fn builder() -> AndImmediateBuilder<false, false, false, false, false> {
            AndImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
                carry: None,
            }
        }
    }
    impl AndImmediateBuilder<true, true, true, true, true> {
        pub fn complete(self) -> AndImmediate {
            AndImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
                carry: self.carry.unwrap(),
            }
        }
    }
    pub struct AndImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
        carry: Option<Option<bool>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > AndImmediateConsumer<false, rdCONSUMED, rnCONSUMED, immCONSUMED, carryCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            AndImmediateConsumer<
                true,
                rdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                carryCONSUMED,
            >,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AndImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > AndImmediateConsumer<sCONSUMED, false, rnCONSUMED, immCONSUMED, carryCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            AndImmediateConsumer<sCONSUMED, true, rnCONSUMED, immCONSUMED, carryCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AndImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > AndImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED, carryCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            AndImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED, carryCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                AndImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
    > AndImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, carryCONSUMED> {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            AndImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, carryCONSUMED>,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                AndImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > AndImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, immCONSUMED, false> {
        pub fn consume_carry(
            mut self,
        ) -> (
            Option<bool>,
            AndImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, immCONSUMED, true>,
        ) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                AndImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl AndImmediate {
        pub fn consumer(
            self,
        ) -> AndImmediateConsumer<false, false, false, false, false> {
            AndImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                imm: Some(self.imm),
                carry: Some(self.carry),
            }
        }
    }
    impl AndImmediateConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AndImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "AndImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "imm",
                &self.imm,
                "carry",
                &&self.carry,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AndImmediate {
        #[inline]
        fn clone(&self) -> AndImmediate {
            AndImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
                carry: ::core::clone::Clone::clone(&self.carry),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AndImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AndImmediate {
        #[inline]
        fn eq(&self, other: &AndImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.imm == other.imm && self.carry == other.carry
        }
    }
    impl From<AndImmediate> for Operation {
        fn from(val: AndImmediate) -> Operation {
            Operation::AndImmediate(val)
        }
    }
    pub struct AndRegister {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct AndRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AndRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> AndRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            AndRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AndRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> AndRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            AndRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > AndRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> AndRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            AndRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > AndRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> AndRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            AndRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > AndRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> AndRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            AndRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl AndRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> AndRegisterBuilder<false, false, false, false, false> {
            AndRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl AndRegister {
        pub fn builder() -> AndRegisterBuilder<false, false, false, false, false> {
            AndRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl AndRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> AndRegister {
            AndRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct AndRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AndRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            AndRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AndRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AndRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            AndRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AndRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AndRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            AndRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                AndRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > AndRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            AndRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                AndRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > AndRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            AndRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                AndRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl AndRegister {
        pub fn consumer(self) -> AndRegisterConsumer<false, false, false, false, false> {
            AndRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl AndRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AndRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "AndRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AndRegister {
        #[inline]
        fn clone(&self) -> AndRegister {
            AndRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AndRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AndRegister {
        #[inline]
        fn eq(&self, other: &AndRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<AndRegister> for Operation {
        fn from(val: AndRegister) -> Operation {
            Operation::AndRegister(val)
        }
    }
    pub struct AsrImmediate {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub rm: Register,
        pub imm: u32,
    }
    pub struct AsrImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rm: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > AsrImmediateBuilder<false, rdSET, rmSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> AsrImmediateBuilder<true, rdSET, rmSET, immSET> {
            self.s = Some(s);
            AsrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > AsrImmediateBuilder<sSET, false, rmSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> AsrImmediateBuilder<sSET, true, rmSET, immSET> {
            self.rd = Some(rd);
            AsrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > AsrImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> AsrImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rm = Some(rm);
            AsrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > AsrImmediateBuilder<sSET, rdSET, rmSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> AsrImmediateBuilder<sSET, rdSET, rmSET, true> {
            self.imm = Some(imm);
            AsrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl AsrImmediateBuilder<false, false, false, false> {
        pub fn new() -> AsrImmediateBuilder<false, false, false, false> {
            AsrImmediateBuilder {
                s: None,
                rd: None,
                rm: None,
                imm: None,
            }
        }
    }
    impl AsrImmediate {
        pub fn builder() -> AsrImmediateBuilder<false, false, false, false> {
            AsrImmediateBuilder {
                s: None,
                rd: None,
                rm: None,
                imm: None,
            }
        }
    }
    impl AsrImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> AsrImmediate {
            AsrImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct AsrImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rm: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const immCONSUMED: bool,
    > AsrImmediateConsumer<false, rdCONSUMED, rmCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            AsrImmediateConsumer<true, rdCONSUMED, rmCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AsrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
        const immCONSUMED: bool,
    > AsrImmediateConsumer<sCONSUMED, false, rmCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, AsrImmediateConsumer<sCONSUMED, true, rmCONSUMED, immCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AsrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > AsrImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, AsrImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                AsrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > AsrImmediateConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, AsrImmediateConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                AsrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl AsrImmediate {
        pub fn consumer(self) -> AsrImmediateConsumer<false, false, false, false> {
            AsrImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
                imm: Some(self.imm),
            }
        }
    }
    impl AsrImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AsrImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AsrImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AsrImmediate {
        #[inline]
        fn clone(&self) -> AsrImmediate {
            AsrImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AsrImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AsrImmediate {
        #[inline]
        fn eq(&self, other: &AsrImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
                && self.imm == other.imm
        }
    }
    impl From<AsrImmediate> for Operation {
        fn from(val: AsrImmediate) -> Operation {
            Operation::AsrImmediate(val)
        }
    }
    pub struct AsrRegister {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct AsrRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > AsrRegisterBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> AsrRegisterBuilder<true, rdSET, rnSET, rmSET> {
            self.s = Some(s);
            AsrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > AsrRegisterBuilder<sSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> AsrRegisterBuilder<sSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            AsrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > AsrRegisterBuilder<sSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> AsrRegisterBuilder<sSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            AsrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > AsrRegisterBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> AsrRegisterBuilder<sSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            AsrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl AsrRegisterBuilder<false, false, false, false> {
        pub fn new() -> AsrRegisterBuilder<false, false, false, false> {
            AsrRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl AsrRegister {
        pub fn builder() -> AsrRegisterBuilder<false, false, false, false> {
            AsrRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl AsrRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> AsrRegister {
            AsrRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct AsrRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > AsrRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            AsrRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                AsrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > AsrRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, AsrRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                AsrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > AsrRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, AsrRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                AsrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > AsrRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, AsrRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                AsrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl AsrRegister {
        pub fn consumer(self) -> AsrRegisterConsumer<false, false, false, false> {
            AsrRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl AsrRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AsrRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AsrRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AsrRegister {
        #[inline]
        fn clone(&self) -> AsrRegister {
            AsrRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AsrRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AsrRegister {
        #[inline]
        fn eq(&self, other: &AsrRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<AsrRegister> for Operation {
        fn from(val: AsrRegister) -> Operation {
            Operation::AsrRegister(val)
        }
    }
    pub struct B {
        pub condition: Condition,
        pub imm: u32,
    }
    pub struct BBuilder<const conditionSET: bool, const immSET: bool> {
        condition: Option<Condition>,
        imm: Option<u32>,
    }
    impl<const immSET: bool> BBuilder<false, immSET> {
        pub fn set_condition(mut self, condition: Condition) -> BBuilder<true, immSET> {
            self.condition = Some(condition);
            BBuilder {
                condition: self.condition,
                imm: self.imm,
            }
        }
    }
    impl<const conditionSET: bool> BBuilder<conditionSET, false> {
        pub fn set_imm(mut self, imm: u32) -> BBuilder<conditionSET, true> {
            self.imm = Some(imm);
            BBuilder {
                condition: self.condition,
                imm: self.imm,
            }
        }
    }
    impl BBuilder<false, false> {
        pub fn new() -> BBuilder<false, false> {
            BBuilder {
                condition: None,
                imm: None,
            }
        }
    }
    impl B {
        pub fn builder() -> BBuilder<false, false> {
            BBuilder {
                condition: None,
                imm: None,
            }
        }
    }
    impl BBuilder<true, true> {
        pub fn complete(self) -> B {
            B {
                condition: self.condition.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct BConsumer<const conditionSET: bool, const immSET: bool> {
        condition: Option<Condition>,
        imm: Option<u32>,
    }
    impl<const immCONSUMED: bool> BConsumer<false, immCONSUMED> {
        pub fn consume_condition(mut self) -> (Condition, BConsumer<true, immCONSUMED>) {
            let ret = self.condition.unwrap();
            self.condition = None;
            (
                ret,
                BConsumer {
                    condition: self.condition,
                    imm: self.imm,
                },
            )
        }
    }
    impl<const conditionCONSUMED: bool> BConsumer<conditionCONSUMED, false> {
        pub fn consume_imm(mut self) -> (u32, BConsumer<conditionCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                BConsumer {
                    condition: self.condition,
                    imm: self.imm,
                },
            )
        }
    }
    impl B {
        pub fn consumer(self) -> BConsumer<false, false> {
            BConsumer {
                condition: Some(self.condition),
                imm: Some(self.imm),
            }
        }
    }
    impl BConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for B {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "B",
                "condition",
                &self.condition,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for B {
        #[inline]
        fn clone(&self) -> B {
            B {
                condition: ::core::clone::Clone::clone(&self.condition),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for B {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for B {
        #[inline]
        fn eq(&self, other: &B) -> bool {
            self.condition == other.condition && self.imm == other.imm
        }
    }
    impl From<B> for Operation {
        fn from(val: B) -> Operation {
            Operation::B(val)
        }
    }
    pub struct Bfc {
        pub rd: Register,
        pub lsb: u32,
        pub msb: u32,
    }
    pub struct BfcBuilder<const rdSET: bool, const lsbSET: bool, const msbSET: bool> {
        rd: Option<Register>,
        lsb: Option<u32>,
        msb: Option<u32>,
    }
    impl<const lsbSET: bool, const msbSET: bool> BfcBuilder<false, lsbSET, msbSET> {
        pub fn set_rd(mut self, rd: Register) -> BfcBuilder<true, lsbSET, msbSET> {
            self.rd = Some(rd);
            BfcBuilder {
                rd: self.rd,
                lsb: self.lsb,
                msb: self.msb,
            }
        }
    }
    impl<const rdSET: bool, const msbSET: bool> BfcBuilder<rdSET, false, msbSET> {
        pub fn set_lsb(mut self, lsb: u32) -> BfcBuilder<rdSET, true, msbSET> {
            self.lsb = Some(lsb);
            BfcBuilder {
                rd: self.rd,
                lsb: self.lsb,
                msb: self.msb,
            }
        }
    }
    impl<const rdSET: bool, const lsbSET: bool> BfcBuilder<rdSET, lsbSET, false> {
        pub fn set_msb(mut self, msb: u32) -> BfcBuilder<rdSET, lsbSET, true> {
            self.msb = Some(msb);
            BfcBuilder {
                rd: self.rd,
                lsb: self.lsb,
                msb: self.msb,
            }
        }
    }
    impl BfcBuilder<false, false, false> {
        pub fn new() -> BfcBuilder<false, false, false> {
            BfcBuilder {
                rd: None,
                lsb: None,
                msb: None,
            }
        }
    }
    impl Bfc {
        pub fn builder() -> BfcBuilder<false, false, false> {
            BfcBuilder {
                rd: None,
                lsb: None,
                msb: None,
            }
        }
    }
    impl BfcBuilder<true, true, true> {
        pub fn complete(self) -> Bfc {
            Bfc {
                rd: self.rd.unwrap(),
                lsb: self.lsb.unwrap(),
                msb: self.msb.unwrap(),
            }
        }
    }
    pub struct BfcConsumer<const rdSET: bool, const lsbSET: bool, const msbSET: bool> {
        rd: Option<Register>,
        lsb: Option<u32>,
        msb: Option<u32>,
    }
    impl<
        const lsbCONSUMED: bool,
        const msbCONSUMED: bool,
    > BfcConsumer<false, lsbCONSUMED, msbCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, BfcConsumer<true, lsbCONSUMED, msbCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                BfcConsumer {
                    rd: self.rd,
                    lsb: self.lsb,
                    msb: self.msb,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const msbCONSUMED: bool,
    > BfcConsumer<rdCONSUMED, false, msbCONSUMED> {
        pub fn consume_lsb(
            mut self,
        ) -> (u32, BfcConsumer<rdCONSUMED, true, msbCONSUMED>) {
            let ret = self.lsb.unwrap();
            self.lsb = None;
            (
                ret,
                BfcConsumer {
                    rd: self.rd,
                    lsb: self.lsb,
                    msb: self.msb,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const lsbCONSUMED: bool,
    > BfcConsumer<rdCONSUMED, lsbCONSUMED, false> {
        pub fn consume_msb(
            mut self,
        ) -> (u32, BfcConsumer<rdCONSUMED, lsbCONSUMED, true>) {
            let ret = self.msb.unwrap();
            self.msb = None;
            (
                ret,
                BfcConsumer {
                    rd: self.rd,
                    lsb: self.lsb,
                    msb: self.msb,
                },
            )
        }
    }
    impl Bfc {
        pub fn consumer(self) -> BfcConsumer<false, false, false> {
            BfcConsumer {
                rd: Some(self.rd),
                lsb: Some(self.lsb),
                msb: Some(self.msb),
            }
        }
    }
    impl BfcConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bfc {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Bfc",
                "rd",
                &self.rd,
                "lsb",
                &self.lsb,
                "msb",
                &&self.msb,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bfc {
        #[inline]
        fn clone(&self) -> Bfc {
            Bfc {
                rd: ::core::clone::Clone::clone(&self.rd),
                lsb: ::core::clone::Clone::clone(&self.lsb),
                msb: ::core::clone::Clone::clone(&self.msb),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bfc {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bfc {
        #[inline]
        fn eq(&self, other: &Bfc) -> bool {
            self.rd == other.rd && self.lsb == other.lsb && self.msb == other.msb
        }
    }
    impl From<Bfc> for Operation {
        fn from(val: Bfc) -> Operation {
            Operation::Bfc(val)
        }
    }
    pub struct Bfi {
        pub rd: Register,
        pub rn: Register,
        pub lsb: u32,
        pub msb: u32,
    }
    pub struct BfiBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
        const msbSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        lsb: Option<u32>,
        msb: Option<u32>,
    }
    impl<
        const rnSET: bool,
        const lsbSET: bool,
        const msbSET: bool,
    > BfiBuilder<false, rnSET, lsbSET, msbSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> BfiBuilder<true, rnSET, lsbSET, msbSET> {
            self.rd = Some(rd);
            BfiBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                msb: self.msb,
            }
        }
    }
    impl<
        const rdSET: bool,
        const lsbSET: bool,
        const msbSET: bool,
    > BfiBuilder<rdSET, false, lsbSET, msbSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> BfiBuilder<rdSET, true, lsbSET, msbSET> {
            self.rn = Some(rn);
            BfiBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                msb: self.msb,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const msbSET: bool,
    > BfiBuilder<rdSET, rnSET, false, msbSET> {
        pub fn set_lsb(mut self, lsb: u32) -> BfiBuilder<rdSET, rnSET, true, msbSET> {
            self.lsb = Some(lsb);
            BfiBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                msb: self.msb,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
    > BfiBuilder<rdSET, rnSET, lsbSET, false> {
        pub fn set_msb(mut self, msb: u32) -> BfiBuilder<rdSET, rnSET, lsbSET, true> {
            self.msb = Some(msb);
            BfiBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                msb: self.msb,
            }
        }
    }
    impl BfiBuilder<false, false, false, false> {
        pub fn new() -> BfiBuilder<false, false, false, false> {
            BfiBuilder {
                rd: None,
                rn: None,
                lsb: None,
                msb: None,
            }
        }
    }
    impl Bfi {
        pub fn builder() -> BfiBuilder<false, false, false, false> {
            BfiBuilder {
                rd: None,
                rn: None,
                lsb: None,
                msb: None,
            }
        }
    }
    impl BfiBuilder<true, true, true, true> {
        pub fn complete(self) -> Bfi {
            Bfi {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                lsb: self.lsb.unwrap(),
                msb: self.msb.unwrap(),
            }
        }
    }
    pub struct BfiConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
        const msbSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        lsb: Option<u32>,
        msb: Option<u32>,
    }
    impl<
        const rnCONSUMED: bool,
        const lsbCONSUMED: bool,
        const msbCONSUMED: bool,
    > BfiConsumer<false, rnCONSUMED, lsbCONSUMED, msbCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, BfiConsumer<true, rnCONSUMED, lsbCONSUMED, msbCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                BfiConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    msb: self.msb,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const lsbCONSUMED: bool,
        const msbCONSUMED: bool,
    > BfiConsumer<rdCONSUMED, false, lsbCONSUMED, msbCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, BfiConsumer<rdCONSUMED, true, lsbCONSUMED, msbCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                BfiConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    msb: self.msb,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const msbCONSUMED: bool,
    > BfiConsumer<rdCONSUMED, rnCONSUMED, false, msbCONSUMED> {
        pub fn consume_lsb(
            mut self,
        ) -> (u32, BfiConsumer<rdCONSUMED, rnCONSUMED, true, msbCONSUMED>) {
            let ret = self.lsb.unwrap();
            self.lsb = None;
            (
                ret,
                BfiConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    msb: self.msb,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const lsbCONSUMED: bool,
    > BfiConsumer<rdCONSUMED, rnCONSUMED, lsbCONSUMED, false> {
        pub fn consume_msb(
            mut self,
        ) -> (u32, BfiConsumer<rdCONSUMED, rnCONSUMED, lsbCONSUMED, true>) {
            let ret = self.msb.unwrap();
            self.msb = None;
            (
                ret,
                BfiConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    msb: self.msb,
                },
            )
        }
    }
    impl Bfi {
        pub fn consumer(self) -> BfiConsumer<false, false, false, false> {
            BfiConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                lsb: Some(self.lsb),
                msb: Some(self.msb),
            }
        }
    }
    impl BfiConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bfi {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Bfi",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "lsb",
                &self.lsb,
                "msb",
                &&self.msb,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bfi {
        #[inline]
        fn clone(&self) -> Bfi {
            Bfi {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                lsb: ::core::clone::Clone::clone(&self.lsb),
                msb: ::core::clone::Clone::clone(&self.msb),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bfi {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bfi {
        #[inline]
        fn eq(&self, other: &Bfi) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.lsb == other.lsb
                && self.msb == other.msb
        }
    }
    impl From<Bfi> for Operation {
        fn from(val: Bfi) -> Operation {
            Operation::Bfi(val)
        }
    }
    pub struct BicImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub imm: u32,
        pub carry: Option<bool>,
    }
    pub struct BicImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
        carry: Option<Option<bool>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > BicImmediateBuilder<false, rdSET, rnSET, immSET, carrySET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> BicImmediateBuilder<true, rdSET, rnSET, immSET, carrySET> {
            self.s = Some(s);
            BicImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > BicImmediateBuilder<sSET, false, rnSET, immSET, carrySET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> BicImmediateBuilder<sSET, true, rnSET, immSET, carrySET> {
            self.rd = Some(rd);
            BicImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > BicImmediateBuilder<sSET, rdSET, false, immSET, carrySET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> BicImmediateBuilder<sSET, rdSET, true, immSET, carrySET> {
            self.rn = Some(rn);
            BicImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
    > BicImmediateBuilder<sSET, rdSET, rnSET, false, carrySET> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> BicImmediateBuilder<sSET, rdSET, rnSET, true, carrySET> {
            self.imm = Some(imm);
            BicImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > BicImmediateBuilder<sSET, rdSET, rnSET, immSET, false> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> BicImmediateBuilder<sSET, rdSET, rnSET, immSET, true> {
            self.carry = Some(carry);
            BicImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl BicImmediateBuilder<false, false, false, false, false> {
        pub fn new() -> BicImmediateBuilder<false, false, false, false, false> {
            BicImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
                carry: None,
            }
        }
    }
    impl BicImmediate {
        pub fn builder() -> BicImmediateBuilder<false, false, false, false, false> {
            BicImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
                carry: None,
            }
        }
    }
    impl BicImmediateBuilder<true, true, true, true, true> {
        pub fn complete(self) -> BicImmediate {
            BicImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
                carry: self.carry.unwrap(),
            }
        }
    }
    pub struct BicImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
        carry: Option<Option<bool>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > BicImmediateConsumer<false, rdCONSUMED, rnCONSUMED, immCONSUMED, carryCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            BicImmediateConsumer<
                true,
                rdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                carryCONSUMED,
            >,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                BicImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > BicImmediateConsumer<sCONSUMED, false, rnCONSUMED, immCONSUMED, carryCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            BicImmediateConsumer<sCONSUMED, true, rnCONSUMED, immCONSUMED, carryCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                BicImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > BicImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED, carryCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            BicImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED, carryCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                BicImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
    > BicImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, carryCONSUMED> {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            BicImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, carryCONSUMED>,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                BicImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > BicImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, immCONSUMED, false> {
        pub fn consume_carry(
            mut self,
        ) -> (
            Option<bool>,
            BicImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, immCONSUMED, true>,
        ) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                BicImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl BicImmediate {
        pub fn consumer(
            self,
        ) -> BicImmediateConsumer<false, false, false, false, false> {
            BicImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                imm: Some(self.imm),
                carry: Some(self.carry),
            }
        }
    }
    impl BicImmediateConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BicImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "BicImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "imm",
                &self.imm,
                "carry",
                &&self.carry,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BicImmediate {
        #[inline]
        fn clone(&self) -> BicImmediate {
            BicImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
                carry: ::core::clone::Clone::clone(&self.carry),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BicImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BicImmediate {
        #[inline]
        fn eq(&self, other: &BicImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.imm == other.imm && self.carry == other.carry
        }
    }
    impl From<BicImmediate> for Operation {
        fn from(val: BicImmediate) -> Operation {
            Operation::BicImmediate(val)
        }
    }
    pub struct BicRegister {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct BicRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > BicRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> BicRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            BicRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > BicRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> BicRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            BicRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > BicRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> BicRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            BicRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > BicRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> BicRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            BicRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > BicRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> BicRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            BicRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl BicRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> BicRegisterBuilder<false, false, false, false, false> {
            BicRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl BicRegister {
        pub fn builder() -> BicRegisterBuilder<false, false, false, false, false> {
            BicRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl BicRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> BicRegister {
            BicRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct BicRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > BicRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            BicRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                BicRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > BicRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            BicRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                BicRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > BicRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            BicRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                BicRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > BicRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            BicRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                BicRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > BicRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            BicRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                BicRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl BicRegister {
        pub fn consumer(self) -> BicRegisterConsumer<false, false, false, false, false> {
            BicRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl BicRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BicRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "BicRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BicRegister {
        #[inline]
        fn clone(&self) -> BicRegister {
            BicRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BicRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BicRegister {
        #[inline]
        fn eq(&self, other: &BicRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<BicRegister> for Operation {
        fn from(val: BicRegister) -> Operation {
            Operation::BicRegister(val)
        }
    }
    pub struct Bkpt {
        pub imm: u32,
    }
    pub struct BkptBuilder<const immSET: bool> {
        imm: Option<u32>,
    }
    impl BkptBuilder<false> {
        pub fn set_imm(mut self, imm: u32) -> BkptBuilder<true> {
            self.imm = Some(imm);
            BkptBuilder { imm: self.imm }
        }
    }
    impl BkptBuilder<false> {
        pub fn new() -> BkptBuilder<false> {
            BkptBuilder { imm: None }
        }
    }
    impl Bkpt {
        pub fn builder() -> BkptBuilder<false> {
            BkptBuilder { imm: None }
        }
    }
    impl BkptBuilder<true> {
        pub fn complete(self) -> Bkpt {
            Bkpt { imm: self.imm.unwrap() }
        }
    }
    pub struct BkptConsumer<const immSET: bool> {
        imm: Option<u32>,
    }
    impl BkptConsumer<false> {
        pub fn consume_imm(mut self) -> (u32, BkptConsumer<true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (ret, BkptConsumer { imm: self.imm })
        }
    }
    impl Bkpt {
        pub fn consumer(self) -> BkptConsumer<false> {
            BkptConsumer {
                imm: Some(self.imm),
            }
        }
    }
    impl BkptConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bkpt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Bkpt",
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bkpt {
        #[inline]
        fn clone(&self) -> Bkpt {
            Bkpt {
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bkpt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bkpt {
        #[inline]
        fn eq(&self, other: &Bkpt) -> bool {
            self.imm == other.imm
        }
    }
    impl From<Bkpt> for Operation {
        fn from(val: Bkpt) -> Operation {
            Operation::Bkpt(val)
        }
    }
    pub struct Bl {
        pub imm: u32,
    }
    pub struct BlBuilder<const immSET: bool> {
        imm: Option<u32>,
    }
    impl BlBuilder<false> {
        pub fn set_imm(mut self, imm: u32) -> BlBuilder<true> {
            self.imm = Some(imm);
            BlBuilder { imm: self.imm }
        }
    }
    impl BlBuilder<false> {
        pub fn new() -> BlBuilder<false> {
            BlBuilder { imm: None }
        }
    }
    impl Bl {
        pub fn builder() -> BlBuilder<false> {
            BlBuilder { imm: None }
        }
    }
    impl BlBuilder<true> {
        pub fn complete(self) -> Bl {
            Bl { imm: self.imm.unwrap() }
        }
    }
    pub struct BlConsumer<const immSET: bool> {
        imm: Option<u32>,
    }
    impl BlConsumer<false> {
        pub fn consume_imm(mut self) -> (u32, BlConsumer<true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (ret, BlConsumer { imm: self.imm })
        }
    }
    impl Bl {
        pub fn consumer(self) -> BlConsumer<false> {
            BlConsumer { imm: Some(self.imm) }
        }
    }
    impl BlConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bl {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Bl",
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bl {
        #[inline]
        fn clone(&self) -> Bl {
            Bl {
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bl {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bl {
        #[inline]
        fn eq(&self, other: &Bl) -> bool {
            self.imm == other.imm
        }
    }
    impl From<Bl> for Operation {
        fn from(val: Bl) -> Operation {
            Operation::Bl(val)
        }
    }
    pub struct Blx {
        pub rm: Register,
    }
    pub struct BlxBuilder<const rmSET: bool> {
        rm: Option<Register>,
    }
    impl BlxBuilder<false> {
        pub fn set_rm(mut self, rm: Register) -> BlxBuilder<true> {
            self.rm = Some(rm);
            BlxBuilder { rm: self.rm }
        }
    }
    impl BlxBuilder<false> {
        pub fn new() -> BlxBuilder<false> {
            BlxBuilder { rm: None }
        }
    }
    impl Blx {
        pub fn builder() -> BlxBuilder<false> {
            BlxBuilder { rm: None }
        }
    }
    impl BlxBuilder<true> {
        pub fn complete(self) -> Blx {
            Blx { rm: self.rm.unwrap() }
        }
    }
    pub struct BlxConsumer<const rmSET: bool> {
        rm: Option<Register>,
    }
    impl BlxConsumer<false> {
        pub fn consume_rm(mut self) -> (Register, BlxConsumer<true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (ret, BlxConsumer { rm: self.rm })
        }
    }
    impl Blx {
        pub fn consumer(self) -> BlxConsumer<false> {
            BlxConsumer { rm: Some(self.rm) }
        }
    }
    impl BlxConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Blx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f, "Blx", "rm", &&self.rm)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Blx {
        #[inline]
        fn clone(&self) -> Blx {
            Blx {
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Blx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Blx {
        #[inline]
        fn eq(&self, other: &Blx) -> bool {
            self.rm == other.rm
        }
    }
    impl From<Blx> for Operation {
        fn from(val: Blx) -> Operation {
            Operation::Blx(val)
        }
    }
    pub struct Bx {
        pub rm: Register,
    }
    pub struct BxBuilder<const rmSET: bool> {
        rm: Option<Register>,
    }
    impl BxBuilder<false> {
        pub fn set_rm(mut self, rm: Register) -> BxBuilder<true> {
            self.rm = Some(rm);
            BxBuilder { rm: self.rm }
        }
    }
    impl BxBuilder<false> {
        pub fn new() -> BxBuilder<false> {
            BxBuilder { rm: None }
        }
    }
    impl Bx {
        pub fn builder() -> BxBuilder<false> {
            BxBuilder { rm: None }
        }
    }
    impl BxBuilder<true> {
        pub fn complete(self) -> Bx {
            Bx { rm: self.rm.unwrap() }
        }
    }
    pub struct BxConsumer<const rmSET: bool> {
        rm: Option<Register>,
    }
    impl BxConsumer<false> {
        pub fn consume_rm(mut self) -> (Register, BxConsumer<true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (ret, BxConsumer { rm: self.rm })
        }
    }
    impl Bx {
        pub fn consumer(self) -> BxConsumer<false> {
            BxConsumer { rm: Some(self.rm) }
        }
    }
    impl BxConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f, "Bx", "rm", &&self.rm)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bx {
        #[inline]
        fn clone(&self) -> Bx {
            Bx {
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bx {
        #[inline]
        fn eq(&self, other: &Bx) -> bool {
            self.rm == other.rm
        }
    }
    impl From<Bx> for Operation {
        fn from(val: Bx) -> Operation {
            Operation::Bx(val)
        }
    }
    pub struct Cbz {
        pub non: Option<bool>,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct CbzBuilder<const nonSET: bool, const rnSET: bool, const immSET: bool> {
        non: Option<Option<bool>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<const rnSET: bool, const immSET: bool> CbzBuilder<false, rnSET, immSET> {
        pub fn set_non(mut self, non: Option<bool>) -> CbzBuilder<true, rnSET, immSET> {
            self.non = Some(non);
            CbzBuilder {
                non: self.non,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const nonSET: bool, const immSET: bool> CbzBuilder<nonSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> CbzBuilder<nonSET, true, immSET> {
            self.rn = Some(rn);
            CbzBuilder {
                non: self.non,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const nonSET: bool, const rnSET: bool> CbzBuilder<nonSET, rnSET, false> {
        pub fn set_imm(mut self, imm: u32) -> CbzBuilder<nonSET, rnSET, true> {
            self.imm = Some(imm);
            CbzBuilder {
                non: self.non,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl CbzBuilder<false, false, false> {
        pub fn new() -> CbzBuilder<false, false, false> {
            CbzBuilder {
                non: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Cbz {
        pub fn builder() -> CbzBuilder<false, false, false> {
            CbzBuilder {
                non: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl CbzBuilder<true, true, true> {
        pub fn complete(self) -> Cbz {
            Cbz {
                non: self.non.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct CbzConsumer<const nonSET: bool, const rnSET: bool, const immSET: bool> {
        non: Option<Option<bool>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > CbzConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_non(
            mut self,
        ) -> (Option<bool>, CbzConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.non.unwrap();
            self.non = None;
            (
                ret,
                CbzConsumer {
                    non: self.non,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const nonCONSUMED: bool,
        const immCONSUMED: bool,
    > CbzConsumer<nonCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, CbzConsumer<nonCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                CbzConsumer {
                    non: self.non,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const nonCONSUMED: bool,
        const rnCONSUMED: bool,
    > CbzConsumer<nonCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, CbzConsumer<nonCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                CbzConsumer {
                    non: self.non,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Cbz {
        pub fn consumer(self) -> CbzConsumer<false, false, false> {
            CbzConsumer {
                non: Some(self.non),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl CbzConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Cbz {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Cbz",
                "non",
                &self.non,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Cbz {
        #[inline]
        fn clone(&self) -> Cbz {
            Cbz {
                non: ::core::clone::Clone::clone(&self.non),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Cbz {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Cbz {
        #[inline]
        fn eq(&self, other: &Cbz) -> bool {
            self.non == other.non && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Cbz> for Operation {
        fn from(val: Cbz) -> Operation {
            Operation::Cbz(val)
        }
    }
    pub struct Cdp {
        pub coproc: CoProcessor,
        pub opc1: u8,
        pub crd: u8,
        pub crn: u8,
        pub crm: u8,
        pub opc2: u8,
    }
    pub struct CdpBuilder<
        const coprocSET: bool,
        const opc1SET: bool,
        const crdSET: bool,
        const crnSET: bool,
        const crmSET: bool,
        const opc2SET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        crd: Option<u8>,
        crn: Option<u8>,
        crm: Option<u8>,
        opc2: Option<u8>,
    }
    impl<
        const opc1SET: bool,
        const crdSET: bool,
        const crnSET: bool,
        const crmSET: bool,
        const opc2SET: bool,
    > CdpBuilder<false, opc1SET, crdSET, crnSET, crmSET, opc2SET> {
        pub fn set_coproc(
            mut self,
            coproc: CoProcessor,
        ) -> CdpBuilder<true, opc1SET, crdSET, crnSET, crmSET, opc2SET> {
            self.coproc = Some(coproc);
            CdpBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                crd: self.crd,
                crn: self.crn,
                crm: self.crm,
                opc2: self.opc2,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const crnSET: bool,
        const crmSET: bool,
        const opc2SET: bool,
    > CdpBuilder<coprocSET, false, crdSET, crnSET, crmSET, opc2SET> {
        pub fn set_opc1(
            mut self,
            opc1: u8,
        ) -> CdpBuilder<coprocSET, true, crdSET, crnSET, crmSET, opc2SET> {
            self.opc1 = Some(opc1);
            CdpBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                crd: self.crd,
                crn: self.crn,
                crm: self.crm,
                opc2: self.opc2,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const crnSET: bool,
        const crmSET: bool,
        const opc2SET: bool,
    > CdpBuilder<coprocSET, opc1SET, false, crnSET, crmSET, opc2SET> {
        pub fn set_crd(
            mut self,
            crd: u8,
        ) -> CdpBuilder<coprocSET, opc1SET, true, crnSET, crmSET, opc2SET> {
            self.crd = Some(crd);
            CdpBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                crd: self.crd,
                crn: self.crn,
                crm: self.crm,
                opc2: self.opc2,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const crdSET: bool,
        const crmSET: bool,
        const opc2SET: bool,
    > CdpBuilder<coprocSET, opc1SET, crdSET, false, crmSET, opc2SET> {
        pub fn set_crn(
            mut self,
            crn: u8,
        ) -> CdpBuilder<coprocSET, opc1SET, crdSET, true, crmSET, opc2SET> {
            self.crn = Some(crn);
            CdpBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                crd: self.crd,
                crn: self.crn,
                crm: self.crm,
                opc2: self.opc2,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const crdSET: bool,
        const crnSET: bool,
        const opc2SET: bool,
    > CdpBuilder<coprocSET, opc1SET, crdSET, crnSET, false, opc2SET> {
        pub fn set_crm(
            mut self,
            crm: u8,
        ) -> CdpBuilder<coprocSET, opc1SET, crdSET, crnSET, true, opc2SET> {
            self.crm = Some(crm);
            CdpBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                crd: self.crd,
                crn: self.crn,
                crm: self.crm,
                opc2: self.opc2,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const crdSET: bool,
        const crnSET: bool,
        const crmSET: bool,
    > CdpBuilder<coprocSET, opc1SET, crdSET, crnSET, crmSET, false> {
        pub fn set_opc2(
            mut self,
            opc2: u8,
        ) -> CdpBuilder<coprocSET, opc1SET, crdSET, crnSET, crmSET, true> {
            self.opc2 = Some(opc2);
            CdpBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                crd: self.crd,
                crn: self.crn,
                crm: self.crm,
                opc2: self.opc2,
            }
        }
    }
    impl CdpBuilder<false, false, false, false, false, false> {
        pub fn new() -> CdpBuilder<false, false, false, false, false, false> {
            CdpBuilder {
                coproc: None,
                opc1: None,
                crd: None,
                crn: None,
                crm: None,
                opc2: None,
            }
        }
    }
    impl Cdp {
        pub fn builder() -> CdpBuilder<false, false, false, false, false, false> {
            CdpBuilder {
                coproc: None,
                opc1: None,
                crd: None,
                crn: None,
                crm: None,
                opc2: None,
            }
        }
    }
    impl CdpBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> Cdp {
            Cdp {
                coproc: self.coproc.unwrap(),
                opc1: self.opc1.unwrap(),
                crd: self.crd.unwrap(),
                crn: self.crn.unwrap(),
                crm: self.crm.unwrap(),
                opc2: self.opc2.unwrap(),
            }
        }
    }
    pub struct CdpConsumer<
        const coprocSET: bool,
        const opc1SET: bool,
        const crdSET: bool,
        const crnSET: bool,
        const crmSET: bool,
        const opc2SET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        crd: Option<u8>,
        crn: Option<u8>,
        crm: Option<u8>,
        opc2: Option<u8>,
    }
    impl<
        const opc1CONSUMED: bool,
        const crdCONSUMED: bool,
        const crnCONSUMED: bool,
        const crmCONSUMED: bool,
        const opc2CONSUMED: bool,
    > CdpConsumer<
        false,
        opc1CONSUMED,
        crdCONSUMED,
        crnCONSUMED,
        crmCONSUMED,
        opc2CONSUMED,
    > {
        pub fn consume_coproc(
            mut self,
        ) -> (
            CoProcessor,
            CdpConsumer<
                true,
                opc1CONSUMED,
                crdCONSUMED,
                crnCONSUMED,
                crmCONSUMED,
                opc2CONSUMED,
            >,
        ) {
            let ret = self.coproc.unwrap();
            self.coproc = None;
            (
                ret,
                CdpConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    crd: self.crd,
                    crn: self.crn,
                    crm: self.crm,
                    opc2: self.opc2,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const crnCONSUMED: bool,
        const crmCONSUMED: bool,
        const opc2CONSUMED: bool,
    > CdpConsumer<
        coprocCONSUMED,
        false,
        crdCONSUMED,
        crnCONSUMED,
        crmCONSUMED,
        opc2CONSUMED,
    > {
        pub fn consume_opc1(
            mut self,
        ) -> (
            u8,
            CdpConsumer<
                coprocCONSUMED,
                true,
                crdCONSUMED,
                crnCONSUMED,
                crmCONSUMED,
                opc2CONSUMED,
            >,
        ) {
            let ret = self.opc1.unwrap();
            self.opc1 = None;
            (
                ret,
                CdpConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    crd: self.crd,
                    crn: self.crn,
                    crm: self.crm,
                    opc2: self.opc2,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const crnCONSUMED: bool,
        const crmCONSUMED: bool,
        const opc2CONSUMED: bool,
    > CdpConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        false,
        crnCONSUMED,
        crmCONSUMED,
        opc2CONSUMED,
    > {
        pub fn consume_crd(
            mut self,
        ) -> (
            u8,
            CdpConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                true,
                crnCONSUMED,
                crmCONSUMED,
                opc2CONSUMED,
            >,
        ) {
            let ret = self.crd.unwrap();
            self.crd = None;
            (
                ret,
                CdpConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    crd: self.crd,
                    crn: self.crn,
                    crm: self.crm,
                    opc2: self.opc2,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const crdCONSUMED: bool,
        const crmCONSUMED: bool,
        const opc2CONSUMED: bool,
    > CdpConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        crdCONSUMED,
        false,
        crmCONSUMED,
        opc2CONSUMED,
    > {
        pub fn consume_crn(
            mut self,
        ) -> (
            u8,
            CdpConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                crdCONSUMED,
                true,
                crmCONSUMED,
                opc2CONSUMED,
            >,
        ) {
            let ret = self.crn.unwrap();
            self.crn = None;
            (
                ret,
                CdpConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    crd: self.crd,
                    crn: self.crn,
                    crm: self.crm,
                    opc2: self.opc2,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const crdCONSUMED: bool,
        const crnCONSUMED: bool,
        const opc2CONSUMED: bool,
    > CdpConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        crdCONSUMED,
        crnCONSUMED,
        false,
        opc2CONSUMED,
    > {
        pub fn consume_crm(
            mut self,
        ) -> (
            u8,
            CdpConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                crdCONSUMED,
                crnCONSUMED,
                true,
                opc2CONSUMED,
            >,
        ) {
            let ret = self.crm.unwrap();
            self.crm = None;
            (
                ret,
                CdpConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    crd: self.crd,
                    crn: self.crn,
                    crm: self.crm,
                    opc2: self.opc2,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const crdCONSUMED: bool,
        const crnCONSUMED: bool,
        const crmCONSUMED: bool,
    > CdpConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        crdCONSUMED,
        crnCONSUMED,
        crmCONSUMED,
        false,
    > {
        pub fn consume_opc2(
            mut self,
        ) -> (
            u8,
            CdpConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                crdCONSUMED,
                crnCONSUMED,
                crmCONSUMED,
                true,
            >,
        ) {
            let ret = self.opc2.unwrap();
            self.opc2 = None;
            (
                ret,
                CdpConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    crd: self.crd,
                    crn: self.crn,
                    crm: self.crm,
                    opc2: self.opc2,
                },
            )
        }
    }
    impl Cdp {
        pub fn consumer(self) -> CdpConsumer<false, false, false, false, false, false> {
            CdpConsumer {
                coproc: Some(self.coproc),
                opc1: Some(self.opc1),
                crd: Some(self.crd),
                crn: Some(self.crn),
                crm: Some(self.crm),
                opc2: Some(self.opc2),
            }
        }
    }
    impl CdpConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Cdp {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["coproc", "opc1", "crd", "crn", "crm", "opc2"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.coproc,
                &self.opc1,
                &self.crd,
                &self.crn,
                &self.crm,
                &&self.opc2,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Cdp", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Cdp {
        #[inline]
        fn clone(&self) -> Cdp {
            Cdp {
                coproc: ::core::clone::Clone::clone(&self.coproc),
                opc1: ::core::clone::Clone::clone(&self.opc1),
                crd: ::core::clone::Clone::clone(&self.crd),
                crn: ::core::clone::Clone::clone(&self.crn),
                crm: ::core::clone::Clone::clone(&self.crm),
                opc2: ::core::clone::Clone::clone(&self.opc2),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Cdp {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Cdp {
        #[inline]
        fn eq(&self, other: &Cdp) -> bool {
            self.coproc == other.coproc && self.opc1 == other.opc1
                && self.crd == other.crd && self.crn == other.crn
                && self.crm == other.crm && self.opc2 == other.opc2
        }
    }
    impl From<Cdp> for Operation {
        fn from(val: Cdp) -> Operation {
            Operation::Cdp(val)
        }
    }
    pub struct Clrex {}
    pub struct ClrexBuilder {}
    impl ClrexBuilder {
        pub fn new() -> ClrexBuilder {
            ClrexBuilder {}
        }
    }
    impl Clrex {
        pub fn builder() -> ClrexBuilder {
            ClrexBuilder {}
        }
    }
    impl ClrexBuilder {
        pub fn complete(self) -> Clrex {
            Clrex {}
        }
    }
    pub struct ClrexConsumer {}
    impl Clrex {
        pub fn consumer(self) -> ClrexConsumer {
            ClrexConsumer {}
        }
    }
    impl ClrexConsumer {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Clrex {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Clrex")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Clrex {
        #[inline]
        fn clone(&self) -> Clrex {
            Clrex {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Clrex {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Clrex {
        #[inline]
        fn eq(&self, other: &Clrex) -> bool {
            true
        }
    }
    impl From<Clrex> for Operation {
        fn from(val: Clrex) -> Operation {
            Operation::Clrex(val)
        }
    }
    pub struct Clz {
        pub rd: Register,
        pub rm: Register,
    }
    pub struct ClzBuilder<const rdSET: bool, const rmSET: bool> {
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rmSET: bool> ClzBuilder<false, rmSET> {
        pub fn set_rd(mut self, rd: Register) -> ClzBuilder<true, rmSET> {
            self.rd = Some(rd);
            ClzBuilder {
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool> ClzBuilder<rdSET, false> {
        pub fn set_rm(mut self, rm: Register) -> ClzBuilder<rdSET, true> {
            self.rm = Some(rm);
            ClzBuilder {
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl ClzBuilder<false, false> {
        pub fn new() -> ClzBuilder<false, false> {
            ClzBuilder { rd: None, rm: None }
        }
    }
    impl Clz {
        pub fn builder() -> ClzBuilder<false, false> {
            ClzBuilder { rd: None, rm: None }
        }
    }
    impl ClzBuilder<true, true> {
        pub fn complete(self) -> Clz {
            Clz {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct ClzConsumer<const rdSET: bool, const rmSET: bool> {
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rmCONSUMED: bool> ClzConsumer<false, rmCONSUMED> {
        pub fn consume_rd(mut self) -> (Register, ClzConsumer<true, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                ClzConsumer {
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl<const rdCONSUMED: bool> ClzConsumer<rdCONSUMED, false> {
        pub fn consume_rm(mut self) -> (Register, ClzConsumer<rdCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                ClzConsumer {
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl Clz {
        pub fn consumer(self) -> ClzConsumer<false, false> {
            ClzConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
            }
        }
    }
    impl ClzConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Clz {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Clz",
                "rd",
                &self.rd,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Clz {
        #[inline]
        fn clone(&self) -> Clz {
            Clz {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Clz {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Clz {
        #[inline]
        fn eq(&self, other: &Clz) -> bool {
            self.rd == other.rd && self.rm == other.rm
        }
    }
    impl From<Clz> for Operation {
        fn from(val: Clz) -> Operation {
            Operation::Clz(val)
        }
    }
    pub struct CmnImmediate {
        pub rn: Register,
        pub imm: u32,
    }
    pub struct CmnImmediateBuilder<const rnSET: bool, const immSET: bool> {
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<const immSET: bool> CmnImmediateBuilder<false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> CmnImmediateBuilder<true, immSET> {
            self.rn = Some(rn);
            CmnImmediateBuilder {
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rnSET: bool> CmnImmediateBuilder<rnSET, false> {
        pub fn set_imm(mut self, imm: u32) -> CmnImmediateBuilder<rnSET, true> {
            self.imm = Some(imm);
            CmnImmediateBuilder {
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl CmnImmediateBuilder<false, false> {
        pub fn new() -> CmnImmediateBuilder<false, false> {
            CmnImmediateBuilder {
                rn: None,
                imm: None,
            }
        }
    }
    impl CmnImmediate {
        pub fn builder() -> CmnImmediateBuilder<false, false> {
            CmnImmediateBuilder {
                rn: None,
                imm: None,
            }
        }
    }
    impl CmnImmediateBuilder<true, true> {
        pub fn complete(self) -> CmnImmediate {
            CmnImmediate {
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct CmnImmediateConsumer<const rnSET: bool, const immSET: bool> {
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<const immCONSUMED: bool> CmnImmediateConsumer<false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, CmnImmediateConsumer<true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                CmnImmediateConsumer {
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<const rnCONSUMED: bool> CmnImmediateConsumer<rnCONSUMED, false> {
        pub fn consume_imm(mut self) -> (u32, CmnImmediateConsumer<rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                CmnImmediateConsumer {
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl CmnImmediate {
        pub fn consumer(self) -> CmnImmediateConsumer<false, false> {
            CmnImmediateConsumer {
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl CmnImmediateConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CmnImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "CmnImmediate",
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CmnImmediate {
        #[inline]
        fn clone(&self) -> CmnImmediate {
            CmnImmediate {
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CmnImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CmnImmediate {
        #[inline]
        fn eq(&self, other: &CmnImmediate) -> bool {
            self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<CmnImmediate> for Operation {
        fn from(val: CmnImmediate) -> Operation {
            Operation::CmnImmediate(val)
        }
    }
    pub struct CmnRegister {
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct CmnRegisterBuilder<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmSET: bool,
        const shiftSET: bool,
    > CmnRegisterBuilder<false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> CmnRegisterBuilder<true, rmSET, shiftSET> {
            self.rn = Some(rn);
            CmnRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rnSET: bool,
        const shiftSET: bool,
    > CmnRegisterBuilder<rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> CmnRegisterBuilder<rnSET, true, shiftSET> {
            self.rm = Some(rm);
            CmnRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<const rnSET: bool, const rmSET: bool> CmnRegisterBuilder<rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> CmnRegisterBuilder<rnSET, rmSET, true> {
            self.shift = Some(shift);
            CmnRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl CmnRegisterBuilder<false, false, false> {
        pub fn new() -> CmnRegisterBuilder<false, false, false> {
            CmnRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl CmnRegister {
        pub fn builder() -> CmnRegisterBuilder<false, false, false> {
            CmnRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl CmnRegisterBuilder<true, true, true> {
        pub fn complete(self) -> CmnRegister {
            CmnRegister {
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct CmnRegisterConsumer<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > CmnRegisterConsumer<false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, CmnRegisterConsumer<true, rmCONSUMED, shiftCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                CmnRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > CmnRegisterConsumer<rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, CmnRegisterConsumer<rnCONSUMED, true, shiftCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                CmnRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > CmnRegisterConsumer<rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (Option<ImmShift>, CmnRegisterConsumer<rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                CmnRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl CmnRegister {
        pub fn consumer(self) -> CmnRegisterConsumer<false, false, false> {
            CmnRegisterConsumer {
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl CmnRegisterConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CmnRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "CmnRegister",
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CmnRegister {
        #[inline]
        fn clone(&self) -> CmnRegister {
            CmnRegister {
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CmnRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CmnRegister {
        #[inline]
        fn eq(&self, other: &CmnRegister) -> bool {
            self.rn == other.rn && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<CmnRegister> for Operation {
        fn from(val: CmnRegister) -> Operation {
            Operation::CmnRegister(val)
        }
    }
    pub struct CmpImmediate {
        pub rn: Register,
        pub imm: u32,
    }
    pub struct CmpImmediateBuilder<const rnSET: bool, const immSET: bool> {
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<const immSET: bool> CmpImmediateBuilder<false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> CmpImmediateBuilder<true, immSET> {
            self.rn = Some(rn);
            CmpImmediateBuilder {
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rnSET: bool> CmpImmediateBuilder<rnSET, false> {
        pub fn set_imm(mut self, imm: u32) -> CmpImmediateBuilder<rnSET, true> {
            self.imm = Some(imm);
            CmpImmediateBuilder {
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl CmpImmediateBuilder<false, false> {
        pub fn new() -> CmpImmediateBuilder<false, false> {
            CmpImmediateBuilder {
                rn: None,
                imm: None,
            }
        }
    }
    impl CmpImmediate {
        pub fn builder() -> CmpImmediateBuilder<false, false> {
            CmpImmediateBuilder {
                rn: None,
                imm: None,
            }
        }
    }
    impl CmpImmediateBuilder<true, true> {
        pub fn complete(self) -> CmpImmediate {
            CmpImmediate {
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct CmpImmediateConsumer<const rnSET: bool, const immSET: bool> {
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<const immCONSUMED: bool> CmpImmediateConsumer<false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, CmpImmediateConsumer<true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                CmpImmediateConsumer {
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<const rnCONSUMED: bool> CmpImmediateConsumer<rnCONSUMED, false> {
        pub fn consume_imm(mut self) -> (u32, CmpImmediateConsumer<rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                CmpImmediateConsumer {
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl CmpImmediate {
        pub fn consumer(self) -> CmpImmediateConsumer<false, false> {
            CmpImmediateConsumer {
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl CmpImmediateConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CmpImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "CmpImmediate",
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CmpImmediate {
        #[inline]
        fn clone(&self) -> CmpImmediate {
            CmpImmediate {
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CmpImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CmpImmediate {
        #[inline]
        fn eq(&self, other: &CmpImmediate) -> bool {
            self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<CmpImmediate> for Operation {
        fn from(val: CmpImmediate) -> Operation {
            Operation::CmpImmediate(val)
        }
    }
    pub struct CmpRegister {
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct CmpRegisterBuilder<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmSET: bool,
        const shiftSET: bool,
    > CmpRegisterBuilder<false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> CmpRegisterBuilder<true, rmSET, shiftSET> {
            self.rn = Some(rn);
            CmpRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rnSET: bool,
        const shiftSET: bool,
    > CmpRegisterBuilder<rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> CmpRegisterBuilder<rnSET, true, shiftSET> {
            self.rm = Some(rm);
            CmpRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<const rnSET: bool, const rmSET: bool> CmpRegisterBuilder<rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> CmpRegisterBuilder<rnSET, rmSET, true> {
            self.shift = Some(shift);
            CmpRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl CmpRegisterBuilder<false, false, false> {
        pub fn new() -> CmpRegisterBuilder<false, false, false> {
            CmpRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl CmpRegister {
        pub fn builder() -> CmpRegisterBuilder<false, false, false> {
            CmpRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl CmpRegisterBuilder<true, true, true> {
        pub fn complete(self) -> CmpRegister {
            CmpRegister {
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct CmpRegisterConsumer<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > CmpRegisterConsumer<false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, CmpRegisterConsumer<true, rmCONSUMED, shiftCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                CmpRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > CmpRegisterConsumer<rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, CmpRegisterConsumer<rnCONSUMED, true, shiftCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                CmpRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > CmpRegisterConsumer<rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (Option<ImmShift>, CmpRegisterConsumer<rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                CmpRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl CmpRegister {
        pub fn consumer(self) -> CmpRegisterConsumer<false, false, false> {
            CmpRegisterConsumer {
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl CmpRegisterConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CmpRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "CmpRegister",
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CmpRegister {
        #[inline]
        fn clone(&self) -> CmpRegister {
            CmpRegister {
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CmpRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CmpRegister {
        #[inline]
        fn eq(&self, other: &CmpRegister) -> bool {
            self.rn == other.rn && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<CmpRegister> for Operation {
        fn from(val: CmpRegister) -> Operation {
            Operation::CmpRegister(val)
        }
    }
    pub struct Cps {
        pub enable: bool,
        pub disable: bool,
        pub affect_pri: bool,
        pub affect_fault: bool,
    }
    pub struct CpsBuilder<
        const enableSET: bool,
        const disableSET: bool,
        const affect_priSET: bool,
        const affect_faultSET: bool,
    > {
        enable: Option<bool>,
        disable: Option<bool>,
        affect_pri: Option<bool>,
        affect_fault: Option<bool>,
    }
    impl<
        const disableSET: bool,
        const affect_priSET: bool,
        const affect_faultSET: bool,
    > CpsBuilder<false, disableSET, affect_priSET, affect_faultSET> {
        pub fn set_enable(
            mut self,
            enable: bool,
        ) -> CpsBuilder<true, disableSET, affect_priSET, affect_faultSET> {
            self.enable = Some(enable);
            CpsBuilder {
                enable: self.enable,
                disable: self.disable,
                affect_pri: self.affect_pri,
                affect_fault: self.affect_fault,
            }
        }
    }
    impl<
        const enableSET: bool,
        const affect_priSET: bool,
        const affect_faultSET: bool,
    > CpsBuilder<enableSET, false, affect_priSET, affect_faultSET> {
        pub fn set_disable(
            mut self,
            disable: bool,
        ) -> CpsBuilder<enableSET, true, affect_priSET, affect_faultSET> {
            self.disable = Some(disable);
            CpsBuilder {
                enable: self.enable,
                disable: self.disable,
                affect_pri: self.affect_pri,
                affect_fault: self.affect_fault,
            }
        }
    }
    impl<
        const enableSET: bool,
        const disableSET: bool,
        const affect_faultSET: bool,
    > CpsBuilder<enableSET, disableSET, false, affect_faultSET> {
        pub fn set_affect_pri(
            mut self,
            affect_pri: bool,
        ) -> CpsBuilder<enableSET, disableSET, true, affect_faultSET> {
            self.affect_pri = Some(affect_pri);
            CpsBuilder {
                enable: self.enable,
                disable: self.disable,
                affect_pri: self.affect_pri,
                affect_fault: self.affect_fault,
            }
        }
    }
    impl<
        const enableSET: bool,
        const disableSET: bool,
        const affect_priSET: bool,
    > CpsBuilder<enableSET, disableSET, affect_priSET, false> {
        pub fn set_affect_fault(
            mut self,
            affect_fault: bool,
        ) -> CpsBuilder<enableSET, disableSET, affect_priSET, true> {
            self.affect_fault = Some(affect_fault);
            CpsBuilder {
                enable: self.enable,
                disable: self.disable,
                affect_pri: self.affect_pri,
                affect_fault: self.affect_fault,
            }
        }
    }
    impl CpsBuilder<false, false, false, false> {
        pub fn new() -> CpsBuilder<false, false, false, false> {
            CpsBuilder {
                enable: None,
                disable: None,
                affect_pri: None,
                affect_fault: None,
            }
        }
    }
    impl Cps {
        pub fn builder() -> CpsBuilder<false, false, false, false> {
            CpsBuilder {
                enable: None,
                disable: None,
                affect_pri: None,
                affect_fault: None,
            }
        }
    }
    impl CpsBuilder<true, true, true, true> {
        pub fn complete(self) -> Cps {
            Cps {
                enable: self.enable.unwrap(),
                disable: self.disable.unwrap(),
                affect_pri: self.affect_pri.unwrap(),
                affect_fault: self.affect_fault.unwrap(),
            }
        }
    }
    pub struct CpsConsumer<
        const enableSET: bool,
        const disableSET: bool,
        const affect_priSET: bool,
        const affect_faultSET: bool,
    > {
        enable: Option<bool>,
        disable: Option<bool>,
        affect_pri: Option<bool>,
        affect_fault: Option<bool>,
    }
    impl<
        const disableCONSUMED: bool,
        const affect_priCONSUMED: bool,
        const affect_faultCONSUMED: bool,
    > CpsConsumer<false, disableCONSUMED, affect_priCONSUMED, affect_faultCONSUMED> {
        pub fn consume_enable(
            mut self,
        ) -> (
            bool,
            CpsConsumer<true, disableCONSUMED, affect_priCONSUMED, affect_faultCONSUMED>,
        ) {
            let ret = self.enable.unwrap();
            self.enable = None;
            (
                ret,
                CpsConsumer {
                    enable: self.enable,
                    disable: self.disable,
                    affect_pri: self.affect_pri,
                    affect_fault: self.affect_fault,
                },
            )
        }
    }
    impl<
        const enableCONSUMED: bool,
        const affect_priCONSUMED: bool,
        const affect_faultCONSUMED: bool,
    > CpsConsumer<enableCONSUMED, false, affect_priCONSUMED, affect_faultCONSUMED> {
        pub fn consume_disable(
            mut self,
        ) -> (
            bool,
            CpsConsumer<enableCONSUMED, true, affect_priCONSUMED, affect_faultCONSUMED>,
        ) {
            let ret = self.disable.unwrap();
            self.disable = None;
            (
                ret,
                CpsConsumer {
                    enable: self.enable,
                    disable: self.disable,
                    affect_pri: self.affect_pri,
                    affect_fault: self.affect_fault,
                },
            )
        }
    }
    impl<
        const enableCONSUMED: bool,
        const disableCONSUMED: bool,
        const affect_faultCONSUMED: bool,
    > CpsConsumer<enableCONSUMED, disableCONSUMED, false, affect_faultCONSUMED> {
        pub fn consume_affect_pri(
            mut self,
        ) -> (
            bool,
            CpsConsumer<enableCONSUMED, disableCONSUMED, true, affect_faultCONSUMED>,
        ) {
            let ret = self.affect_pri.unwrap();
            self.affect_pri = None;
            (
                ret,
                CpsConsumer {
                    enable: self.enable,
                    disable: self.disable,
                    affect_pri: self.affect_pri,
                    affect_fault: self.affect_fault,
                },
            )
        }
    }
    impl<
        const enableCONSUMED: bool,
        const disableCONSUMED: bool,
        const affect_priCONSUMED: bool,
    > CpsConsumer<enableCONSUMED, disableCONSUMED, affect_priCONSUMED, false> {
        pub fn consume_affect_fault(
            mut self,
        ) -> (
            bool,
            CpsConsumer<enableCONSUMED, disableCONSUMED, affect_priCONSUMED, true>,
        ) {
            let ret = self.affect_fault.unwrap();
            self.affect_fault = None;
            (
                ret,
                CpsConsumer {
                    enable: self.enable,
                    disable: self.disable,
                    affect_pri: self.affect_pri,
                    affect_fault: self.affect_fault,
                },
            )
        }
    }
    impl Cps {
        pub fn consumer(self) -> CpsConsumer<false, false, false, false> {
            CpsConsumer {
                enable: Some(self.enable),
                disable: Some(self.disable),
                affect_pri: Some(self.affect_pri),
                affect_fault: Some(self.affect_fault),
            }
        }
    }
    impl CpsConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Cps {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Cps",
                "enable",
                &self.enable,
                "disable",
                &self.disable,
                "affect_pri",
                &self.affect_pri,
                "affect_fault",
                &&self.affect_fault,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Cps {
        #[inline]
        fn clone(&self) -> Cps {
            Cps {
                enable: ::core::clone::Clone::clone(&self.enable),
                disable: ::core::clone::Clone::clone(&self.disable),
                affect_pri: ::core::clone::Clone::clone(&self.affect_pri),
                affect_fault: ::core::clone::Clone::clone(&self.affect_fault),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Cps {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Cps {
        #[inline]
        fn eq(&self, other: &Cps) -> bool {
            self.enable == other.enable && self.disable == other.disable
                && self.affect_pri == other.affect_pri
                && self.affect_fault == other.affect_fault
        }
    }
    impl From<Cps> for Operation {
        fn from(val: Cps) -> Operation {
            Operation::Cps(val)
        }
    }
    pub struct Dbg {
        pub option: u8,
    }
    pub struct DbgBuilder<const optionSET: bool> {
        option: Option<u8>,
    }
    impl DbgBuilder<false> {
        pub fn set_option(mut self, option: u8) -> DbgBuilder<true> {
            self.option = Some(option);
            DbgBuilder { option: self.option }
        }
    }
    impl DbgBuilder<false> {
        pub fn new() -> DbgBuilder<false> {
            DbgBuilder { option: None }
        }
    }
    impl Dbg {
        pub fn builder() -> DbgBuilder<false> {
            DbgBuilder { option: None }
        }
    }
    impl DbgBuilder<true> {
        pub fn complete(self) -> Dbg {
            Dbg {
                option: self.option.unwrap(),
            }
        }
    }
    pub struct DbgConsumer<const optionSET: bool> {
        option: Option<u8>,
    }
    impl DbgConsumer<false> {
        pub fn consume_option(mut self) -> (u8, DbgConsumer<true>) {
            let ret = self.option.unwrap();
            self.option = None;
            (ret, DbgConsumer { option: self.option })
        }
    }
    impl Dbg {
        pub fn consumer(self) -> DbgConsumer<false> {
            DbgConsumer {
                option: Some(self.option),
            }
        }
    }
    impl DbgConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Dbg {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Dbg",
                "option",
                &&self.option,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Dbg {
        #[inline]
        fn clone(&self) -> Dbg {
            Dbg {
                option: ::core::clone::Clone::clone(&self.option),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Dbg {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Dbg {
        #[inline]
        fn eq(&self, other: &Dbg) -> bool {
            self.option == other.option
        }
    }
    impl From<Dbg> for Operation {
        fn from(val: Dbg) -> Operation {
            Operation::Dbg(val)
        }
    }
    pub struct Dmb {
        pub option: Option<u8>,
    }
    pub struct DmbBuilder<const optionSET: bool> {
        option: Option<Option<u8>>,
    }
    impl DmbBuilder<false> {
        pub fn set_option(mut self, option: Option<u8>) -> DmbBuilder<true> {
            self.option = Some(option);
            DmbBuilder { option: self.option }
        }
    }
    impl DmbBuilder<false> {
        pub fn new() -> DmbBuilder<false> {
            DmbBuilder { option: None }
        }
    }
    impl Dmb {
        pub fn builder() -> DmbBuilder<false> {
            DmbBuilder { option: None }
        }
    }
    impl DmbBuilder<true> {
        pub fn complete(self) -> Dmb {
            Dmb {
                option: self.option.unwrap(),
            }
        }
    }
    pub struct DmbConsumer<const optionSET: bool> {
        option: Option<Option<u8>>,
    }
    impl DmbConsumer<false> {
        pub fn consume_option(mut self) -> (Option<u8>, DmbConsumer<true>) {
            let ret = self.option.unwrap();
            self.option = None;
            (ret, DmbConsumer { option: self.option })
        }
    }
    impl Dmb {
        pub fn consumer(self) -> DmbConsumer<false> {
            DmbConsumer {
                option: Some(self.option),
            }
        }
    }
    impl DmbConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Dmb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Dmb",
                "option",
                &&self.option,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Dmb {
        #[inline]
        fn clone(&self) -> Dmb {
            Dmb {
                option: ::core::clone::Clone::clone(&self.option),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Dmb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Dmb {
        #[inline]
        fn eq(&self, other: &Dmb) -> bool {
            self.option == other.option
        }
    }
    impl From<Dmb> for Operation {
        fn from(val: Dmb) -> Operation {
            Operation::Dmb(val)
        }
    }
    pub struct Dsb {
        pub option: Option<u8>,
    }
    pub struct DsbBuilder<const optionSET: bool> {
        option: Option<Option<u8>>,
    }
    impl DsbBuilder<false> {
        pub fn set_option(mut self, option: Option<u8>) -> DsbBuilder<true> {
            self.option = Some(option);
            DsbBuilder { option: self.option }
        }
    }
    impl DsbBuilder<false> {
        pub fn new() -> DsbBuilder<false> {
            DsbBuilder { option: None }
        }
    }
    impl Dsb {
        pub fn builder() -> DsbBuilder<false> {
            DsbBuilder { option: None }
        }
    }
    impl DsbBuilder<true> {
        pub fn complete(self) -> Dsb {
            Dsb {
                option: self.option.unwrap(),
            }
        }
    }
    pub struct DsbConsumer<const optionSET: bool> {
        option: Option<Option<u8>>,
    }
    impl DsbConsumer<false> {
        pub fn consume_option(mut self) -> (Option<u8>, DsbConsumer<true>) {
            let ret = self.option.unwrap();
            self.option = None;
            (ret, DsbConsumer { option: self.option })
        }
    }
    impl Dsb {
        pub fn consumer(self) -> DsbConsumer<false> {
            DsbConsumer {
                option: Some(self.option),
            }
        }
    }
    impl DsbConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Dsb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Dsb",
                "option",
                &&self.option,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Dsb {
        #[inline]
        fn clone(&self) -> Dsb {
            Dsb {
                option: ::core::clone::Clone::clone(&self.option),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Dsb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Dsb {
        #[inline]
        fn eq(&self, other: &Dsb) -> bool {
            self.option == other.option
        }
    }
    impl From<Dsb> for Operation {
        fn from(val: Dsb) -> Operation {
            Operation::Dsb(val)
        }
    }
    pub struct EorImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub imm: u32,
        pub carry: Option<bool>,
    }
    pub struct EorImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
        carry: Option<Option<bool>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > EorImmediateBuilder<false, rdSET, rnSET, immSET, carrySET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> EorImmediateBuilder<true, rdSET, rnSET, immSET, carrySET> {
            self.s = Some(s);
            EorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > EorImmediateBuilder<sSET, false, rnSET, immSET, carrySET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> EorImmediateBuilder<sSET, true, rnSET, immSET, carrySET> {
            self.rd = Some(rd);
            EorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > EorImmediateBuilder<sSET, rdSET, false, immSET, carrySET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> EorImmediateBuilder<sSET, rdSET, true, immSET, carrySET> {
            self.rn = Some(rn);
            EorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
    > EorImmediateBuilder<sSET, rdSET, rnSET, false, carrySET> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> EorImmediateBuilder<sSET, rdSET, rnSET, true, carrySET> {
            self.imm = Some(imm);
            EorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > EorImmediateBuilder<sSET, rdSET, rnSET, immSET, false> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> EorImmediateBuilder<sSET, rdSET, rnSET, immSET, true> {
            self.carry = Some(carry);
            EorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl EorImmediateBuilder<false, false, false, false, false> {
        pub fn new() -> EorImmediateBuilder<false, false, false, false, false> {
            EorImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
                carry: None,
            }
        }
    }
    impl EorImmediate {
        pub fn builder() -> EorImmediateBuilder<false, false, false, false, false> {
            EorImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
                carry: None,
            }
        }
    }
    impl EorImmediateBuilder<true, true, true, true, true> {
        pub fn complete(self) -> EorImmediate {
            EorImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
                carry: self.carry.unwrap(),
            }
        }
    }
    pub struct EorImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
        carry: Option<Option<bool>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > EorImmediateConsumer<false, rdCONSUMED, rnCONSUMED, immCONSUMED, carryCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            EorImmediateConsumer<
                true,
                rdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                carryCONSUMED,
            >,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                EorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > EorImmediateConsumer<sCONSUMED, false, rnCONSUMED, immCONSUMED, carryCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            EorImmediateConsumer<sCONSUMED, true, rnCONSUMED, immCONSUMED, carryCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                EorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > EorImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED, carryCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            EorImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED, carryCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                EorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
    > EorImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, carryCONSUMED> {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            EorImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, carryCONSUMED>,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                EorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > EorImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, immCONSUMED, false> {
        pub fn consume_carry(
            mut self,
        ) -> (
            Option<bool>,
            EorImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, immCONSUMED, true>,
        ) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                EorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl EorImmediate {
        pub fn consumer(
            self,
        ) -> EorImmediateConsumer<false, false, false, false, false> {
            EorImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                imm: Some(self.imm),
                carry: Some(self.carry),
            }
        }
    }
    impl EorImmediateConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EorImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "EorImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "imm",
                &self.imm,
                "carry",
                &&self.carry,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EorImmediate {
        #[inline]
        fn clone(&self) -> EorImmediate {
            EorImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
                carry: ::core::clone::Clone::clone(&self.carry),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EorImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EorImmediate {
        #[inline]
        fn eq(&self, other: &EorImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.imm == other.imm && self.carry == other.carry
        }
    }
    impl From<EorImmediate> for Operation {
        fn from(val: EorImmediate) -> Operation {
            Operation::EorImmediate(val)
        }
    }
    pub struct EorRegister {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct EorRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > EorRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> EorRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            EorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > EorRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> EorRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            EorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > EorRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> EorRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            EorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > EorRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> EorRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            EorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > EorRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> EorRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            EorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl EorRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> EorRegisterBuilder<false, false, false, false, false> {
            EorRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl EorRegister {
        pub fn builder() -> EorRegisterBuilder<false, false, false, false, false> {
            EorRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl EorRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> EorRegister {
            EorRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct EorRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > EorRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            EorRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                EorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > EorRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            EorRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                EorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > EorRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            EorRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                EorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > EorRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            EorRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                EorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > EorRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            EorRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                EorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl EorRegister {
        pub fn consumer(self) -> EorRegisterConsumer<false, false, false, false, false> {
            EorRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl EorRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EorRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "EorRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EorRegister {
        #[inline]
        fn clone(&self) -> EorRegister {
            EorRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EorRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EorRegister {
        #[inline]
        fn eq(&self, other: &EorRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<EorRegister> for Operation {
        fn from(val: EorRegister) -> Operation {
            Operation::EorRegister(val)
        }
    }
    pub struct Isb {
        pub option: Option<Imm4>,
    }
    pub struct IsbBuilder<const optionSET: bool> {
        option: Option<Option<Imm4>>,
    }
    impl IsbBuilder<false> {
        pub fn set_option(mut self, option: Option<Imm4>) -> IsbBuilder<true> {
            self.option = Some(option);
            IsbBuilder { option: self.option }
        }
    }
    impl IsbBuilder<false> {
        pub fn new() -> IsbBuilder<false> {
            IsbBuilder { option: None }
        }
    }
    impl Isb {
        pub fn builder() -> IsbBuilder<false> {
            IsbBuilder { option: None }
        }
    }
    impl IsbBuilder<true> {
        pub fn complete(self) -> Isb {
            Isb {
                option: self.option.unwrap(),
            }
        }
    }
    pub struct IsbConsumer<const optionSET: bool> {
        option: Option<Option<Imm4>>,
    }
    impl IsbConsumer<false> {
        pub fn consume_option(mut self) -> (Option<Imm4>, IsbConsumer<true>) {
            let ret = self.option.unwrap();
            self.option = None;
            (ret, IsbConsumer { option: self.option })
        }
    }
    impl Isb {
        pub fn consumer(self) -> IsbConsumer<false> {
            IsbConsumer {
                option: Some(self.option),
            }
        }
    }
    impl IsbConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Isb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Isb",
                "option",
                &&self.option,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Isb {
        #[inline]
        fn clone(&self) -> Isb {
            Isb {
                option: ::core::clone::Clone::clone(&self.option),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Isb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Isb {
        #[inline]
        fn eq(&self, other: &Isb) -> bool {
            self.option == other.option
        }
    }
    impl From<Isb> for Operation {
        fn from(val: Isb) -> Operation {
            Operation::Isb(val)
        }
    }
    pub struct It {
        pub conds: ITCondition,
    }
    pub struct ItBuilder<const condsSET: bool> {
        conds: Option<ITCondition>,
    }
    impl ItBuilder<false> {
        pub fn set_conds(mut self, conds: ITCondition) -> ItBuilder<true> {
            self.conds = Some(conds);
            ItBuilder { conds: self.conds }
        }
    }
    impl ItBuilder<false> {
        pub fn new() -> ItBuilder<false> {
            ItBuilder { conds: None }
        }
    }
    impl It {
        pub fn builder() -> ItBuilder<false> {
            ItBuilder { conds: None }
        }
    }
    impl ItBuilder<true> {
        pub fn complete(self) -> It {
            It { conds: self.conds.unwrap() }
        }
    }
    pub struct ItConsumer<const condsSET: bool> {
        conds: Option<ITCondition>,
    }
    impl ItConsumer<false> {
        pub fn consume_conds(mut self) -> (ITCondition, ItConsumer<true>) {
            let ret = self.conds.unwrap();
            self.conds = None;
            (ret, ItConsumer { conds: self.conds })
        }
    }
    impl It {
        pub fn consumer(self) -> ItConsumer<false> {
            ItConsumer {
                conds: Some(self.conds),
            }
        }
    }
    impl ItConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for It {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "It",
                "conds",
                &&self.conds,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for It {
        #[inline]
        fn clone(&self) -> It {
            It {
                conds: ::core::clone::Clone::clone(&self.conds),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for It {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for It {
        #[inline]
        fn eq(&self, other: &It) -> bool {
            self.conds == other.conds
        }
    }
    impl From<It> for Operation {
        fn from(val: It) -> Operation {
            Operation::It(val)
        }
    }
    pub struct Ldm {
        pub w: Option<bool>,
        pub rn: Register,
        pub registers: RegisterList,
    }
    pub struct LdmBuilder<
        const wSET: bool,
        const rnSET: bool,
        const registersSET: bool,
    > {
        w: Option<Option<bool>>,
        rn: Option<Register>,
        registers: Option<RegisterList>,
    }
    impl<
        const rnSET: bool,
        const registersSET: bool,
    > LdmBuilder<false, rnSET, registersSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> LdmBuilder<true, rnSET, registersSET> {
            self.w = Some(w);
            LdmBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl<
        const wSET: bool,
        const registersSET: bool,
    > LdmBuilder<wSET, false, registersSET> {
        pub fn set_rn(mut self, rn: Register) -> LdmBuilder<wSET, true, registersSET> {
            self.rn = Some(rn);
            LdmBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl<const wSET: bool, const rnSET: bool> LdmBuilder<wSET, rnSET, false> {
        pub fn set_registers(
            mut self,
            registers: RegisterList,
        ) -> LdmBuilder<wSET, rnSET, true> {
            self.registers = Some(registers);
            LdmBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl LdmBuilder<false, false, false> {
        pub fn new() -> LdmBuilder<false, false, false> {
            LdmBuilder {
                w: None,
                rn: None,
                registers: None,
            }
        }
    }
    impl Ldm {
        pub fn builder() -> LdmBuilder<false, false, false> {
            LdmBuilder {
                w: None,
                rn: None,
                registers: None,
            }
        }
    }
    impl LdmBuilder<true, true, true> {
        pub fn complete(self) -> Ldm {
            Ldm {
                w: self.w.unwrap(),
                rn: self.rn.unwrap(),
                registers: self.registers.unwrap(),
            }
        }
    }
    pub struct LdmConsumer<
        const wSET: bool,
        const rnSET: bool,
        const registersSET: bool,
    > {
        w: Option<Option<bool>>,
        rn: Option<Register>,
        registers: Option<RegisterList>,
    }
    impl<
        const rnCONSUMED: bool,
        const registersCONSUMED: bool,
    > LdmConsumer<false, rnCONSUMED, registersCONSUMED> {
        pub fn consume_w(
            mut self,
        ) -> (Option<bool>, LdmConsumer<true, rnCONSUMED, registersCONSUMED>) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdmConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const registersCONSUMED: bool,
    > LdmConsumer<wCONSUMED, false, registersCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LdmConsumer<wCONSUMED, true, registersCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdmConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdmConsumer<wCONSUMED, rnCONSUMED, false> {
        pub fn consume_registers(
            mut self,
        ) -> (RegisterList, LdmConsumer<wCONSUMED, rnCONSUMED, true>) {
            let ret = self.registers.unwrap();
            self.registers = None;
            (
                ret,
                LdmConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl Ldm {
        pub fn consumer(self) -> LdmConsumer<false, false, false> {
            LdmConsumer {
                w: Some(self.w),
                rn: Some(self.rn),
                registers: Some(self.registers),
            }
        }
    }
    impl LdmConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldm {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ldm",
                "w",
                &self.w,
                "rn",
                &self.rn,
                "registers",
                &&self.registers,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldm {
        #[inline]
        fn clone(&self) -> Ldm {
            Ldm {
                w: ::core::clone::Clone::clone(&self.w),
                rn: ::core::clone::Clone::clone(&self.rn),
                registers: ::core::clone::Clone::clone(&self.registers),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldm {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldm {
        #[inline]
        fn eq(&self, other: &Ldm) -> bool {
            self.w == other.w && self.rn == other.rn && self.registers == other.registers
        }
    }
    impl From<Ldm> for Operation {
        fn from(val: Ldm) -> Operation {
            Operation::Ldm(val)
        }
    }
    pub struct Ldmdb {
        pub w: Option<bool>,
        pub rn: Register,
        pub registers: RegisterList,
    }
    pub struct LdmdbBuilder<
        const wSET: bool,
        const rnSET: bool,
        const registersSET: bool,
    > {
        w: Option<Option<bool>>,
        rn: Option<Register>,
        registers: Option<RegisterList>,
    }
    impl<
        const rnSET: bool,
        const registersSET: bool,
    > LdmdbBuilder<false, rnSET, registersSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> LdmdbBuilder<true, rnSET, registersSET> {
            self.w = Some(w);
            LdmdbBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl<
        const wSET: bool,
        const registersSET: bool,
    > LdmdbBuilder<wSET, false, registersSET> {
        pub fn set_rn(mut self, rn: Register) -> LdmdbBuilder<wSET, true, registersSET> {
            self.rn = Some(rn);
            LdmdbBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl<const wSET: bool, const rnSET: bool> LdmdbBuilder<wSET, rnSET, false> {
        pub fn set_registers(
            mut self,
            registers: RegisterList,
        ) -> LdmdbBuilder<wSET, rnSET, true> {
            self.registers = Some(registers);
            LdmdbBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl LdmdbBuilder<false, false, false> {
        pub fn new() -> LdmdbBuilder<false, false, false> {
            LdmdbBuilder {
                w: None,
                rn: None,
                registers: None,
            }
        }
    }
    impl Ldmdb {
        pub fn builder() -> LdmdbBuilder<false, false, false> {
            LdmdbBuilder {
                w: None,
                rn: None,
                registers: None,
            }
        }
    }
    impl LdmdbBuilder<true, true, true> {
        pub fn complete(self) -> Ldmdb {
            Ldmdb {
                w: self.w.unwrap(),
                rn: self.rn.unwrap(),
                registers: self.registers.unwrap(),
            }
        }
    }
    pub struct LdmdbConsumer<
        const wSET: bool,
        const rnSET: bool,
        const registersSET: bool,
    > {
        w: Option<Option<bool>>,
        rn: Option<Register>,
        registers: Option<RegisterList>,
    }
    impl<
        const rnCONSUMED: bool,
        const registersCONSUMED: bool,
    > LdmdbConsumer<false, rnCONSUMED, registersCONSUMED> {
        pub fn consume_w(
            mut self,
        ) -> (Option<bool>, LdmdbConsumer<true, rnCONSUMED, registersCONSUMED>) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdmdbConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const registersCONSUMED: bool,
    > LdmdbConsumer<wCONSUMED, false, registersCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LdmdbConsumer<wCONSUMED, true, registersCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdmdbConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdmdbConsumer<wCONSUMED, rnCONSUMED, false> {
        pub fn consume_registers(
            mut self,
        ) -> (RegisterList, LdmdbConsumer<wCONSUMED, rnCONSUMED, true>) {
            let ret = self.registers.unwrap();
            self.registers = None;
            (
                ret,
                LdmdbConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl Ldmdb {
        pub fn consumer(self) -> LdmdbConsumer<false, false, false> {
            LdmdbConsumer {
                w: Some(self.w),
                rn: Some(self.rn),
                registers: Some(self.registers),
            }
        }
    }
    impl LdmdbConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldmdb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ldmdb",
                "w",
                &self.w,
                "rn",
                &self.rn,
                "registers",
                &&self.registers,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldmdb {
        #[inline]
        fn clone(&self) -> Ldmdb {
            Ldmdb {
                w: ::core::clone::Clone::clone(&self.w),
                rn: ::core::clone::Clone::clone(&self.rn),
                registers: ::core::clone::Clone::clone(&self.registers),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldmdb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldmdb {
        #[inline]
        fn eq(&self, other: &Ldmdb) -> bool {
            self.w == other.w && self.rn == other.rn && self.registers == other.registers
        }
    }
    impl From<Ldmdb> for Operation {
        fn from(val: Ldmdb) -> Operation {
            Operation::Ldmdb(val)
        }
    }
    pub struct LdrImmediate {
        pub w: Option<bool>,
        pub add: bool,
        pub index: bool,
        pub rt: Register,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct LdrImmediateBuilder<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<bool>,
        index: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrImmediateBuilder<false, addSET, indexSET, rtSET, rnSET, immSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> LdrImmediateBuilder<true, addSET, indexSET, rtSET, rnSET, immSET> {
            self.w = Some(w);
            LdrImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrImmediateBuilder<wSET, false, indexSET, rtSET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> LdrImmediateBuilder<wSET, true, indexSET, rtSET, rnSET, immSET> {
            self.add = Some(add);
            LdrImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrImmediateBuilder<wSET, addSET, false, rtSET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: bool,
        ) -> LdrImmediateBuilder<wSET, addSET, true, rtSET, rnSET, immSET> {
            self.index = Some(index);
            LdrImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrImmediateBuilder<wSET, addSET, indexSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrImmediateBuilder<wSET, addSET, indexSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > LdrImmediateBuilder<wSET, addSET, indexSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrImmediateBuilder<wSET, addSET, indexSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > LdrImmediateBuilder<wSET, addSET, indexSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> LdrImmediateBuilder<wSET, addSET, indexSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrImmediateBuilder<false, false, false, false, false, false> {
        pub fn new() -> LdrImmediateBuilder<false, false, false, false, false, false> {
            LdrImmediateBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrImmediate {
        pub fn builder() -> LdrImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdrImmediateBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrImmediateBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> LdrImmediate {
            LdrImmediate {
                w: self.w.unwrap(),
                add: self.add.unwrap(),
                index: self.index.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrImmediateConsumer<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<bool>,
        index: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrImmediateConsumer<
        false,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            LdrImmediateConsumer<
                true,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdrImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrImmediateConsumer<
        wCONSUMED,
        false,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            LdrImmediateConsumer<
                wCONSUMED,
                true,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        false,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            bool,
            LdrImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                true,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdrImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            LdrImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrImmediate {
        pub fn consumer(
            self,
        ) -> LdrImmediateConsumer<false, false, false, false, false, false> {
            LdrImmediateConsumer {
                w: Some(self.w),
                add: Some(self.add),
                index: Some(self.index),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrImmediateConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["w", "add", "index", "rt", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.w,
                &self.add,
                &self.index,
                &self.rt,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LdrImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrImmediate {
        #[inline]
        fn clone(&self) -> LdrImmediate {
            LdrImmediate {
                w: ::core::clone::Clone::clone(&self.w),
                add: ::core::clone::Clone::clone(&self.add),
                index: ::core::clone::Clone::clone(&self.index),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrImmediate {
        #[inline]
        fn eq(&self, other: &LdrImmediate) -> bool {
            self.w == other.w && self.add == other.add && self.index == other.index
                && self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<LdrImmediate> for Operation {
        fn from(val: LdrImmediate) -> Operation {
            Operation::LdrImmediate(val)
        }
    }
    pub struct LdrLiteral {
        pub add: bool,
        pub rt: Register,
        pub imm: u32,
    }
    pub struct LdrLiteralBuilder<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<const rtSET: bool, const immSET: bool> LdrLiteralBuilder<false, rtSET, immSET> {
        pub fn set_add(mut self, add: bool) -> LdrLiteralBuilder<true, rtSET, immSET> {
            self.add = Some(add);
            LdrLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const immSET: bool,
    > LdrLiteralBuilder<addSET, false, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrLiteralBuilder<addSET, true, immSET> {
            self.rt = Some(rt);
            LdrLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<const addSET: bool, const rtSET: bool> LdrLiteralBuilder<addSET, rtSET, false> {
        pub fn set_imm(mut self, imm: u32) -> LdrLiteralBuilder<addSET, rtSET, true> {
            self.imm = Some(imm);
            LdrLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl LdrLiteralBuilder<false, false, false> {
        pub fn new() -> LdrLiteralBuilder<false, false, false> {
            LdrLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrLiteral {
        pub fn builder() -> LdrLiteralBuilder<false, false, false> {
            LdrLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrLiteralBuilder<true, true, true> {
        pub fn complete(self) -> LdrLiteral {
            LdrLiteral {
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrLiteralConsumer<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrLiteralConsumer<false, rtCONSUMED, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (bool, LdrLiteralConsumer<true, rtCONSUMED, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrLiteralConsumer<addCONSUMED, false, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrLiteralConsumer<addCONSUMED, true, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
    > LdrLiteralConsumer<addCONSUMED, rtCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, LdrLiteralConsumer<addCONSUMED, rtCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrLiteral {
        pub fn consumer(self) -> LdrLiteralConsumer<false, false, false> {
            LdrLiteralConsumer {
                add: Some(self.add),
                rt: Some(self.rt),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrLiteralConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrLiteral {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LdrLiteral",
                "add",
                &self.add,
                "rt",
                &self.rt,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrLiteral {
        #[inline]
        fn clone(&self) -> LdrLiteral {
            LdrLiteral {
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrLiteral {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrLiteral {
        #[inline]
        fn eq(&self, other: &LdrLiteral) -> bool {
            self.add == other.add && self.rt == other.rt && self.imm == other.imm
        }
    }
    impl From<LdrLiteral> for Operation {
        fn from(val: LdrLiteral) -> Operation {
            Operation::LdrLiteral(val)
        }
    }
    pub struct LdrRegister {
        pub w: Option<bool>,
        pub rt: Register,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct LdrRegisterBuilder<
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        w: Option<Option<bool>>,
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrRegisterBuilder<false, rtSET, rnSET, rmSET, shiftSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> LdrRegisterBuilder<true, rtSET, rnSET, rmSET, shiftSET> {
            self.w = Some(w);
            LdrRegisterBuilder {
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const wSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrRegisterBuilder<wSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrRegisterBuilder<wSET, true, rnSET, rmSET, shiftSET> {
            self.rt = Some(rt);
            LdrRegisterBuilder {
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const wSET: bool,
        const rtSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrRegisterBuilder<wSET, rtSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrRegisterBuilder<wSET, rtSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            LdrRegisterBuilder {
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > LdrRegisterBuilder<wSET, rtSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LdrRegisterBuilder<wSET, rtSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            LdrRegisterBuilder {
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LdrRegisterBuilder<wSET, rtSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> LdrRegisterBuilder<wSET, rtSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            LdrRegisterBuilder {
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl LdrRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> LdrRegisterBuilder<false, false, false, false, false> {
            LdrRegisterBuilder {
                w: None,
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrRegister {
        pub fn builder() -> LdrRegisterBuilder<false, false, false, false, false> {
            LdrRegisterBuilder {
                w: None,
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> LdrRegister {
            LdrRegister {
                w: self.w.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct LdrRegisterConsumer<
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        w: Option<Option<bool>>,
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrRegisterConsumer<false, rtCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            LdrRegisterConsumer<true, rtCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdrRegisterConsumer {
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrRegisterConsumer<wCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrRegisterConsumer<wCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrRegisterConsumer {
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const rtCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrRegisterConsumer<wCONSUMED, rtCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrRegisterConsumer<wCONSUMED, rtCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrRegisterConsumer {
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrRegisterConsumer<wCONSUMED, rtCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            LdrRegisterConsumer<wCONSUMED, rtCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LdrRegisterConsumer {
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LdrRegisterConsumer<wCONSUMED, rtCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            LdrRegisterConsumer<wCONSUMED, rtCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                LdrRegisterConsumer {
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl LdrRegister {
        pub fn consumer(self) -> LdrRegisterConsumer<false, false, false, false, false> {
            LdrRegisterConsumer {
                w: Some(self.w),
                rt: Some(self.rt),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl LdrRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "LdrRegister",
                "w",
                &self.w,
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrRegister {
        #[inline]
        fn clone(&self) -> LdrRegister {
            LdrRegister {
                w: ::core::clone::Clone::clone(&self.w),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrRegister {
        #[inline]
        fn eq(&self, other: &LdrRegister) -> bool {
            self.w == other.w && self.rt == other.rt && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<LdrRegister> for Operation {
        fn from(val: LdrRegister) -> Operation {
            Operation::LdrRegister(val)
        }
    }
    pub struct LdrbImmediate {
        pub w: Option<bool>,
        pub add: Option<bool>,
        pub index: bool,
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct LdrbImmediateBuilder<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<Option<bool>>,
        index: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrbImmediateBuilder<false, addSET, indexSET, rtSET, rnSET, immSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> LdrbImmediateBuilder<true, addSET, indexSET, rtSET, rnSET, immSET> {
            self.w = Some(w);
            LdrbImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrbImmediateBuilder<wSET, false, indexSET, rtSET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> LdrbImmediateBuilder<wSET, true, indexSET, rtSET, rnSET, immSET> {
            self.add = Some(add);
            LdrbImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrbImmediateBuilder<wSET, addSET, false, rtSET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: bool,
        ) -> LdrbImmediateBuilder<wSET, addSET, true, rtSET, rnSET, immSET> {
            self.index = Some(index);
            LdrbImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrbImmediateBuilder<wSET, addSET, indexSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrbImmediateBuilder<wSET, addSET, indexSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrbImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > LdrbImmediateBuilder<wSET, addSET, indexSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrbImmediateBuilder<wSET, addSET, indexSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrbImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > LdrbImmediateBuilder<wSET, addSET, indexSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: Option<u32>,
        ) -> LdrbImmediateBuilder<wSET, addSET, indexSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrbImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrbImmediateBuilder<false, false, false, false, false, false> {
        pub fn new() -> LdrbImmediateBuilder<false, false, false, false, false, false> {
            LdrbImmediateBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrbImmediate {
        pub fn builder() -> LdrbImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdrbImmediateBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrbImmediateBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> LdrbImmediate {
            LdrbImmediate {
                w: self.w.unwrap(),
                add: self.add.unwrap(),
                index: self.index.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrbImmediateConsumer<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<Option<bool>>,
        index: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbImmediateConsumer<
        false,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            LdrbImmediateConsumer<
                true,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdrbImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbImmediateConsumer<
        wCONSUMED,
        false,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            Option<bool>,
            LdrbImmediateConsumer<
                wCONSUMED,
                true,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrbImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        false,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            bool,
            LdrbImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                true,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdrbImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrbImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrbImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrbImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrbImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrbImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            Option<u32>,
            LdrbImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrbImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrbImmediate {
        pub fn consumer(
            self,
        ) -> LdrbImmediateConsumer<false, false, false, false, false, false> {
            LdrbImmediateConsumer {
                w: Some(self.w),
                add: Some(self.add),
                index: Some(self.index),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrbImmediateConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrbImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["w", "add", "index", "rt", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.w,
                &self.add,
                &self.index,
                &self.rt,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LdrbImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrbImmediate {
        #[inline]
        fn clone(&self) -> LdrbImmediate {
            LdrbImmediate {
                w: ::core::clone::Clone::clone(&self.w),
                add: ::core::clone::Clone::clone(&self.add),
                index: ::core::clone::Clone::clone(&self.index),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrbImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrbImmediate {
        #[inline]
        fn eq(&self, other: &LdrbImmediate) -> bool {
            self.w == other.w && self.add == other.add && self.index == other.index
                && self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<LdrbImmediate> for Operation {
        fn from(val: LdrbImmediate) -> Operation {
            Operation::LdrbImmediate(val)
        }
    }
    pub struct LdrbLiteral {
        pub add: Option<bool>,
        pub rt: Register,
        pub imm: u32,
    }
    pub struct LdrbLiteralBuilder<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<Option<bool>>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtSET: bool,
        const immSET: bool,
    > LdrbLiteralBuilder<false, rtSET, immSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> LdrbLiteralBuilder<true, rtSET, immSET> {
            self.add = Some(add);
            LdrbLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const immSET: bool,
    > LdrbLiteralBuilder<addSET, false, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrbLiteralBuilder<addSET, true, immSET> {
            self.rt = Some(rt);
            LdrbLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const rtSET: bool,
    > LdrbLiteralBuilder<addSET, rtSET, false> {
        pub fn set_imm(mut self, imm: u32) -> LdrbLiteralBuilder<addSET, rtSET, true> {
            self.imm = Some(imm);
            LdrbLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl LdrbLiteralBuilder<false, false, false> {
        pub fn new() -> LdrbLiteralBuilder<false, false, false> {
            LdrbLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrbLiteral {
        pub fn builder() -> LdrbLiteralBuilder<false, false, false> {
            LdrbLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrbLiteralBuilder<true, true, true> {
        pub fn complete(self) -> LdrbLiteral {
            LdrbLiteral {
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrbLiteralConsumer<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<Option<bool>>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbLiteralConsumer<false, rtCONSUMED, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (Option<bool>, LdrbLiteralConsumer<true, rtCONSUMED, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrbLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbLiteralConsumer<addCONSUMED, false, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrbLiteralConsumer<addCONSUMED, true, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrbLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
    > LdrbLiteralConsumer<addCONSUMED, rtCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, LdrbLiteralConsumer<addCONSUMED, rtCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrbLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrbLiteral {
        pub fn consumer(self) -> LdrbLiteralConsumer<false, false, false> {
            LdrbLiteralConsumer {
                add: Some(self.add),
                rt: Some(self.rt),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrbLiteralConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrbLiteral {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LdrbLiteral",
                "add",
                &self.add,
                "rt",
                &self.rt,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrbLiteral {
        #[inline]
        fn clone(&self) -> LdrbLiteral {
            LdrbLiteral {
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrbLiteral {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrbLiteral {
        #[inline]
        fn eq(&self, other: &LdrbLiteral) -> bool {
            self.add == other.add && self.rt == other.rt && self.imm == other.imm
        }
    }
    impl From<LdrbLiteral> for Operation {
        fn from(val: LdrbLiteral) -> Operation {
            Operation::LdrbLiteral(val)
        }
    }
    pub struct LdrbRegister {
        pub add: Option<bool>,
        pub rt: Register,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct LdrbRegisterBuilder<
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        add: Option<Option<bool>>,
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrbRegisterBuilder<false, rtSET, rnSET, rmSET, shiftSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> LdrbRegisterBuilder<true, rtSET, rnSET, rmSET, shiftSET> {
            self.add = Some(add);
            LdrbRegisterBuilder {
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const addSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrbRegisterBuilder<addSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrbRegisterBuilder<addSET, true, rnSET, rmSET, shiftSET> {
            self.rt = Some(rt);
            LdrbRegisterBuilder {
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const addSET: bool,
        const rtSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrbRegisterBuilder<addSET, rtSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrbRegisterBuilder<addSET, rtSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            LdrbRegisterBuilder {
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > LdrbRegisterBuilder<addSET, rtSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LdrbRegisterBuilder<addSET, rtSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            LdrbRegisterBuilder {
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LdrbRegisterBuilder<addSET, rtSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> LdrbRegisterBuilder<addSET, rtSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            LdrbRegisterBuilder {
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl LdrbRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> LdrbRegisterBuilder<false, false, false, false, false> {
            LdrbRegisterBuilder {
                add: None,
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrbRegister {
        pub fn builder() -> LdrbRegisterBuilder<false, false, false, false, false> {
            LdrbRegisterBuilder {
                add: None,
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrbRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> LdrbRegister {
            LdrbRegister {
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct LdrbRegisterConsumer<
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        add: Option<Option<bool>>,
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrbRegisterConsumer<false, rtCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (
            Option<bool>,
            LdrbRegisterConsumer<true, rtCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrbRegisterConsumer {
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrbRegisterConsumer<addCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrbRegisterConsumer<
                addCONSUMED,
                true,
                rnCONSUMED,
                rmCONSUMED,
                shiftCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrbRegisterConsumer {
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrbRegisterConsumer<addCONSUMED, rtCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrbRegisterConsumer<
                addCONSUMED,
                rtCONSUMED,
                true,
                rmCONSUMED,
                shiftCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrbRegisterConsumer {
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrbRegisterConsumer<addCONSUMED, rtCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            LdrbRegisterConsumer<
                addCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
                shiftCONSUMED,
            >,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LdrbRegisterConsumer {
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LdrbRegisterConsumer<addCONSUMED, rtCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            LdrbRegisterConsumer<addCONSUMED, rtCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                LdrbRegisterConsumer {
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl LdrbRegister {
        pub fn consumer(
            self,
        ) -> LdrbRegisterConsumer<false, false, false, false, false> {
            LdrbRegisterConsumer {
                add: Some(self.add),
                rt: Some(self.rt),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl LdrbRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrbRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "LdrbRegister",
                "add",
                &self.add,
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrbRegister {
        #[inline]
        fn clone(&self) -> LdrbRegister {
            LdrbRegister {
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrbRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrbRegister {
        #[inline]
        fn eq(&self, other: &LdrbRegister) -> bool {
            self.add == other.add && self.rt == other.rt && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<LdrbRegister> for Operation {
        fn from(val: LdrbRegister) -> Operation {
            Operation::LdrbRegister(val)
        }
    }
    pub struct Ldrbt {
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct LdrbtBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<const rnSET: bool, const immSET: bool> LdrbtBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> LdrbtBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> LdrbtBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> LdrbtBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> LdrbtBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: Option<u32>) -> LdrbtBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrbtBuilder<false, false, false> {
        pub fn new() -> LdrbtBuilder<false, false, false> {
            LdrbtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Ldrbt {
        pub fn builder() -> LdrbtBuilder<false, false, false> {
            LdrbtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrbtBuilder<true, true, true> {
        pub fn complete(self) -> Ldrbt {
            Ldrbt {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrbtConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbtConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrbtConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrbtConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LdrbtConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrbtConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (Option<u32>, LdrbtConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Ldrbt {
        pub fn consumer(self) -> LdrbtConsumer<false, false, false> {
            LdrbtConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrbtConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldrbt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ldrbt",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldrbt {
        #[inline]
        fn clone(&self) -> Ldrbt {
            Ldrbt {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldrbt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldrbt {
        #[inline]
        fn eq(&self, other: &Ldrbt) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Ldrbt> for Operation {
        fn from(val: Ldrbt) -> Operation {
            Operation::Ldrbt(val)
        }
    }
    pub struct LdrdImmediate {
        pub w: Option<bool>,
        pub add: Option<bool>,
        pub index: Option<bool>,
        pub rt: Register,
        pub rt2: Register,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct LdrdImmediateBuilder<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<Option<bool>>,
        index: Option<Option<bool>>,
        rt: Option<Register>,
        rt2: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrdImmediateBuilder<false, addSET, indexSET, rtSET, rt2SET, rnSET, immSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> LdrdImmediateBuilder<true, addSET, indexSET, rtSET, rt2SET, rnSET, immSET> {
            self.w = Some(w);
            LdrdImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrdImmediateBuilder<wSET, false, indexSET, rtSET, rt2SET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> LdrdImmediateBuilder<wSET, true, indexSET, rtSET, rt2SET, rnSET, immSET> {
            self.add = Some(add);
            LdrdImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrdImmediateBuilder<wSET, addSET, false, rtSET, rt2SET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: Option<bool>,
        ) -> LdrdImmediateBuilder<wSET, addSET, true, rtSET, rt2SET, rnSET, immSET> {
            self.index = Some(index);
            LdrdImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrdImmediateBuilder<wSET, addSET, indexSET, false, rt2SET, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrdImmediateBuilder<wSET, addSET, indexSET, true, rt2SET, rnSET, immSET> {
            self.rt = Some(rt);
            LdrdImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrdImmediateBuilder<wSET, addSET, indexSET, rtSET, false, rnSET, immSET> {
        pub fn set_rt2(
            mut self,
            rt2: Register,
        ) -> LdrdImmediateBuilder<wSET, addSET, indexSET, rtSET, true, rnSET, immSET> {
            self.rt2 = Some(rt2);
            LdrdImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const immSET: bool,
    > LdrdImmediateBuilder<wSET, addSET, indexSET, rtSET, rt2SET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrdImmediateBuilder<wSET, addSET, indexSET, rtSET, rt2SET, true, immSET> {
            self.rn = Some(rn);
            LdrdImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
    > LdrdImmediateBuilder<wSET, addSET, indexSET, rtSET, rt2SET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> LdrdImmediateBuilder<wSET, addSET, indexSET, rtSET, rt2SET, rnSET, true> {
            self.imm = Some(imm);
            LdrdImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrdImmediateBuilder<false, false, false, false, false, false, false> {
        pub fn new() -> LdrdImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdrdImmediateBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rt2: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrdImmediate {
        pub fn builder() -> LdrdImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdrdImmediateBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rt2: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrdImmediateBuilder<true, true, true, true, true, true, true> {
        pub fn complete(self) -> LdrdImmediate {
            LdrdImmediate {
                w: self.w.unwrap(),
                add: self.add.unwrap(),
                index: self.index.unwrap(),
                rt: self.rt.unwrap(),
                rt2: self.rt2.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrdImmediateConsumer<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<Option<bool>>,
        index: Option<Option<bool>>,
        rt: Option<Register>,
        rt2: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdImmediateConsumer<
        false,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            LdrdImmediateConsumer<
                true,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdrdImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdImmediateConsumer<
        wCONSUMED,
        false,
        indexCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            Option<bool>,
            LdrdImmediateConsumer<
                wCONSUMED,
                true,
                indexCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrdImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        false,
        rtCONSUMED,
        rt2CONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            Option<bool>,
            LdrdImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                true,
                rtCONSUMED,
                rt2CONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdrdImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        false,
        rt2CONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrdImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                true,
                rt2CONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrdImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt2(
            mut self,
        ) -> (
            Register,
            LdrdImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt2.unwrap();
            self.rt2 = None;
            (
                ret,
                LdrdImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrdImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrdImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrdImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            LdrdImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrdImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrdImmediate {
        pub fn consumer(
            self,
        ) -> LdrdImmediateConsumer<false, false, false, false, false, false, false> {
            LdrdImmediateConsumer {
                w: Some(self.w),
                add: Some(self.add),
                index: Some(self.index),
                rt: Some(self.rt),
                rt2: Some(self.rt2),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrdImmediateConsumer<true, true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrdImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["w", "add", "index", "rt", "rt2", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.w,
                &self.add,
                &self.index,
                &self.rt,
                &self.rt2,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LdrdImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrdImmediate {
        #[inline]
        fn clone(&self) -> LdrdImmediate {
            LdrdImmediate {
                w: ::core::clone::Clone::clone(&self.w),
                add: ::core::clone::Clone::clone(&self.add),
                index: ::core::clone::Clone::clone(&self.index),
                rt: ::core::clone::Clone::clone(&self.rt),
                rt2: ::core::clone::Clone::clone(&self.rt2),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrdImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrdImmediate {
        #[inline]
        fn eq(&self, other: &LdrdImmediate) -> bool {
            self.w == other.w && self.add == other.add && self.index == other.index
                && self.rt == other.rt && self.rt2 == other.rt2 && self.rn == other.rn
                && self.imm == other.imm
        }
    }
    impl From<LdrdImmediate> for Operation {
        fn from(val: LdrdImmediate) -> Operation {
            Operation::LdrdImmediate(val)
        }
    }
    pub struct LdrdLiteral {
        pub w: Option<bool>,
        pub add: Option<bool>,
        pub index: Option<bool>,
        pub rt: Register,
        pub rt2: Register,
        pub imm: u32,
    }
    pub struct LdrdLiteralBuilder<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<Option<bool>>,
        index: Option<Option<bool>>,
        rt: Option<Register>,
        rt2: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const immSET: bool,
    > LdrdLiteralBuilder<false, addSET, indexSET, rtSET, rt2SET, immSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> LdrdLiteralBuilder<true, addSET, indexSET, rtSET, rt2SET, immSET> {
            self.w = Some(w);
            LdrdLiteralBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const immSET: bool,
    > LdrdLiteralBuilder<wSET, false, indexSET, rtSET, rt2SET, immSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> LdrdLiteralBuilder<wSET, true, indexSET, rtSET, rt2SET, immSET> {
            self.add = Some(add);
            LdrdLiteralBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const immSET: bool,
    > LdrdLiteralBuilder<wSET, addSET, false, rtSET, rt2SET, immSET> {
        pub fn set_index(
            mut self,
            index: Option<bool>,
        ) -> LdrdLiteralBuilder<wSET, addSET, true, rtSET, rt2SET, immSET> {
            self.index = Some(index);
            LdrdLiteralBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rt2SET: bool,
        const immSET: bool,
    > LdrdLiteralBuilder<wSET, addSET, indexSET, false, rt2SET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrdLiteralBuilder<wSET, addSET, indexSET, true, rt2SET, immSET> {
            self.rt = Some(rt);
            LdrdLiteralBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > LdrdLiteralBuilder<wSET, addSET, indexSET, rtSET, false, immSET> {
        pub fn set_rt2(
            mut self,
            rt2: Register,
        ) -> LdrdLiteralBuilder<wSET, addSET, indexSET, rtSET, true, immSET> {
            self.rt2 = Some(rt2);
            LdrdLiteralBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
    > LdrdLiteralBuilder<wSET, addSET, indexSET, rtSET, rt2SET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> LdrdLiteralBuilder<wSET, addSET, indexSET, rtSET, rt2SET, true> {
            self.imm = Some(imm);
            LdrdLiteralBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rt2: self.rt2,
                imm: self.imm,
            }
        }
    }
    impl LdrdLiteralBuilder<false, false, false, false, false, false> {
        pub fn new() -> LdrdLiteralBuilder<false, false, false, false, false, false> {
            LdrdLiteralBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rt2: None,
                imm: None,
            }
        }
    }
    impl LdrdLiteral {
        pub fn builder() -> LdrdLiteralBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdrdLiteralBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rt2: None,
                imm: None,
            }
        }
    }
    impl LdrdLiteralBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> LdrdLiteral {
            LdrdLiteral {
                w: self.w.unwrap(),
                add: self.add.unwrap(),
                index: self.index.unwrap(),
                rt: self.rt.unwrap(),
                rt2: self.rt2.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrdLiteralConsumer<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<Option<bool>>,
        index: Option<Option<bool>>,
        rt: Option<Register>,
        rt2: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdLiteralConsumer<
        false,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            LdrdLiteralConsumer<
                true,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdrdLiteralConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdLiteralConsumer<
        wCONSUMED,
        false,
        indexCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            Option<bool>,
            LdrdLiteralConsumer<
                wCONSUMED,
                true,
                indexCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrdLiteralConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdLiteralConsumer<
        wCONSUMED,
        addCONSUMED,
        false,
        rtCONSUMED,
        rt2CONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            Option<bool>,
            LdrdLiteralConsumer<
                wCONSUMED,
                addCONSUMED,
                true,
                rtCONSUMED,
                rt2CONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdrdLiteralConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rt2CONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdLiteralConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        false,
        rt2CONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrdLiteralConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                true,
                rt2CONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrdLiteralConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrdLiteralConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rt2(
            mut self,
        ) -> (
            Register,
            LdrdLiteralConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt2.unwrap();
            self.rt2 = None;
            (
                ret,
                LdrdLiteralConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
    > LdrdLiteralConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            LdrdLiteralConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrdLiteralConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rt2: self.rt2,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrdLiteral {
        pub fn consumer(
            self,
        ) -> LdrdLiteralConsumer<false, false, false, false, false, false> {
            LdrdLiteralConsumer {
                w: Some(self.w),
                add: Some(self.add),
                index: Some(self.index),
                rt: Some(self.rt),
                rt2: Some(self.rt2),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrdLiteralConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrdLiteral {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["w", "add", "index", "rt", "rt2", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.w,
                &self.add,
                &self.index,
                &self.rt,
                &self.rt2,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LdrdLiteral",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrdLiteral {
        #[inline]
        fn clone(&self) -> LdrdLiteral {
            LdrdLiteral {
                w: ::core::clone::Clone::clone(&self.w),
                add: ::core::clone::Clone::clone(&self.add),
                index: ::core::clone::Clone::clone(&self.index),
                rt: ::core::clone::Clone::clone(&self.rt),
                rt2: ::core::clone::Clone::clone(&self.rt2),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrdLiteral {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrdLiteral {
        #[inline]
        fn eq(&self, other: &LdrdLiteral) -> bool {
            self.w == other.w && self.add == other.add && self.index == other.index
                && self.rt == other.rt && self.rt2 == other.rt2 && self.imm == other.imm
        }
    }
    impl From<LdrdLiteral> for Operation {
        fn from(val: LdrdLiteral) -> Operation {
            Operation::LdrdLiteral(val)
        }
    }
    pub struct Ldrex {
        pub rt: Register,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct LdrexBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<const rnSET: bool, const immSET: bool> LdrexBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> LdrexBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrexBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> LdrexBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> LdrexBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrexBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> LdrexBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: u32) -> LdrexBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrexBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrexBuilder<false, false, false> {
        pub fn new() -> LdrexBuilder<false, false, false> {
            LdrexBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Ldrex {
        pub fn builder() -> LdrexBuilder<false, false, false> {
            LdrexBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrexBuilder<true, true, true> {
        pub fn complete(self) -> Ldrex {
            Ldrex {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrexConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrexConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrexConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrexConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrexConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LdrexConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrexConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrexConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, LdrexConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrexConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Ldrex {
        pub fn consumer(self) -> LdrexConsumer<false, false, false> {
            LdrexConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrexConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldrex {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ldrex",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldrex {
        #[inline]
        fn clone(&self) -> Ldrex {
            Ldrex {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldrex {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldrex {
        #[inline]
        fn eq(&self, other: &Ldrex) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Ldrex> for Operation {
        fn from(val: Ldrex) -> Operation {
            Operation::Ldrex(val)
        }
    }
    pub struct Ldrexb {
        pub rt: Register,
        pub rn: Register,
    }
    pub struct LdrexbBuilder<const rtSET: bool, const rnSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rnSET: bool> LdrexbBuilder<false, rnSET> {
        pub fn set_rt(mut self, rt: Register) -> LdrexbBuilder<true, rnSET> {
            self.rt = Some(rt);
            LdrexbBuilder {
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl<const rtSET: bool> LdrexbBuilder<rtSET, false> {
        pub fn set_rn(mut self, rn: Register) -> LdrexbBuilder<rtSET, true> {
            self.rn = Some(rn);
            LdrexbBuilder {
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl LdrexbBuilder<false, false> {
        pub fn new() -> LdrexbBuilder<false, false> {
            LdrexbBuilder {
                rt: None,
                rn: None,
            }
        }
    }
    impl Ldrexb {
        pub fn builder() -> LdrexbBuilder<false, false> {
            LdrexbBuilder {
                rt: None,
                rn: None,
            }
        }
    }
    impl LdrexbBuilder<true, true> {
        pub fn complete(self) -> Ldrexb {
            Ldrexb {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct LdrexbConsumer<const rtSET: bool, const rnSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rnCONSUMED: bool> LdrexbConsumer<false, rnCONSUMED> {
        pub fn consume_rt(mut self) -> (Register, LdrexbConsumer<true, rnCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrexbConsumer {
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl<const rtCONSUMED: bool> LdrexbConsumer<rtCONSUMED, false> {
        pub fn consume_rn(mut self) -> (Register, LdrexbConsumer<rtCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrexbConsumer {
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl Ldrexb {
        pub fn consumer(self) -> LdrexbConsumer<false, false> {
            LdrexbConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
            }
        }
    }
    impl LdrexbConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldrexb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Ldrexb",
                "rt",
                &self.rt,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldrexb {
        #[inline]
        fn clone(&self) -> Ldrexb {
            Ldrexb {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldrexb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldrexb {
        #[inline]
        fn eq(&self, other: &Ldrexb) -> bool {
            self.rt == other.rt && self.rn == other.rn
        }
    }
    impl From<Ldrexb> for Operation {
        fn from(val: Ldrexb) -> Operation {
            Operation::Ldrexb(val)
        }
    }
    pub struct Ldrexh {
        pub rt: Register,
        pub rn: Register,
    }
    pub struct LdrexhBuilder<const rtSET: bool, const rnSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rnSET: bool> LdrexhBuilder<false, rnSET> {
        pub fn set_rt(mut self, rt: Register) -> LdrexhBuilder<true, rnSET> {
            self.rt = Some(rt);
            LdrexhBuilder {
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl<const rtSET: bool> LdrexhBuilder<rtSET, false> {
        pub fn set_rn(mut self, rn: Register) -> LdrexhBuilder<rtSET, true> {
            self.rn = Some(rn);
            LdrexhBuilder {
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl LdrexhBuilder<false, false> {
        pub fn new() -> LdrexhBuilder<false, false> {
            LdrexhBuilder {
                rt: None,
                rn: None,
            }
        }
    }
    impl Ldrexh {
        pub fn builder() -> LdrexhBuilder<false, false> {
            LdrexhBuilder {
                rt: None,
                rn: None,
            }
        }
    }
    impl LdrexhBuilder<true, true> {
        pub fn complete(self) -> Ldrexh {
            Ldrexh {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct LdrexhConsumer<const rtSET: bool, const rnSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rnCONSUMED: bool> LdrexhConsumer<false, rnCONSUMED> {
        pub fn consume_rt(mut self) -> (Register, LdrexhConsumer<true, rnCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrexhConsumer {
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl<const rtCONSUMED: bool> LdrexhConsumer<rtCONSUMED, false> {
        pub fn consume_rn(mut self) -> (Register, LdrexhConsumer<rtCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrexhConsumer {
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl Ldrexh {
        pub fn consumer(self) -> LdrexhConsumer<false, false> {
            LdrexhConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
            }
        }
    }
    impl LdrexhConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldrexh {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Ldrexh",
                "rt",
                &self.rt,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldrexh {
        #[inline]
        fn clone(&self) -> Ldrexh {
            Ldrexh {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldrexh {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldrexh {
        #[inline]
        fn eq(&self, other: &Ldrexh) -> bool {
            self.rt == other.rt && self.rn == other.rn
        }
    }
    impl From<Ldrexh> for Operation {
        fn from(val: Ldrexh) -> Operation {
            Operation::Ldrexh(val)
        }
    }
    pub struct LdrhImmediate {
        pub w: Option<bool>,
        pub add: Option<bool>,
        pub index: Option<bool>,
        pub rt: Register,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct LdrhImmediateBuilder<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<Option<bool>>,
        index: Option<Option<bool>>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrhImmediateBuilder<false, addSET, indexSET, rtSET, rnSET, immSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> LdrhImmediateBuilder<true, addSET, indexSET, rtSET, rnSET, immSET> {
            self.w = Some(w);
            LdrhImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrhImmediateBuilder<wSET, false, indexSET, rtSET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> LdrhImmediateBuilder<wSET, true, indexSET, rtSET, rnSET, immSET> {
            self.add = Some(add);
            LdrhImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrhImmediateBuilder<wSET, addSET, false, rtSET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: Option<bool>,
        ) -> LdrhImmediateBuilder<wSET, addSET, true, rtSET, rnSET, immSET> {
            self.index = Some(index);
            LdrhImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrhImmediateBuilder<wSET, addSET, indexSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrhImmediateBuilder<wSET, addSET, indexSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrhImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > LdrhImmediateBuilder<wSET, addSET, indexSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrhImmediateBuilder<wSET, addSET, indexSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrhImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > LdrhImmediateBuilder<wSET, addSET, indexSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> LdrhImmediateBuilder<wSET, addSET, indexSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrhImmediateBuilder {
                w: self.w,
                add: self.add,
                index: self.index,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrhImmediateBuilder<false, false, false, false, false, false> {
        pub fn new() -> LdrhImmediateBuilder<false, false, false, false, false, false> {
            LdrhImmediateBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrhImmediate {
        pub fn builder() -> LdrhImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdrhImmediateBuilder {
                w: None,
                add: None,
                index: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrhImmediateBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> LdrhImmediate {
            LdrhImmediate {
                w: self.w.unwrap(),
                add: self.add.unwrap(),
                index: self.index.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrhImmediateConsumer<
        const wSET: bool,
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        add: Option<Option<bool>>,
        index: Option<Option<bool>>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhImmediateConsumer<
        false,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            LdrhImmediateConsumer<
                true,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdrhImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhImmediateConsumer<
        wCONSUMED,
        false,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            Option<bool>,
            LdrhImmediateConsumer<
                wCONSUMED,
                true,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrhImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        false,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            Option<bool>,
            LdrhImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                true,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdrhImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrhImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrhImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrhImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrhImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrhImmediateConsumer<
        wCONSUMED,
        addCONSUMED,
        indexCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            LdrhImmediateConsumer<
                wCONSUMED,
                addCONSUMED,
                indexCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrhImmediateConsumer {
                    w: self.w,
                    add: self.add,
                    index: self.index,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrhImmediate {
        pub fn consumer(
            self,
        ) -> LdrhImmediateConsumer<false, false, false, false, false, false> {
            LdrhImmediateConsumer {
                w: Some(self.w),
                add: Some(self.add),
                index: Some(self.index),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrhImmediateConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrhImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["w", "add", "index", "rt", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.w,
                &self.add,
                &self.index,
                &self.rt,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LdrhImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrhImmediate {
        #[inline]
        fn clone(&self) -> LdrhImmediate {
            LdrhImmediate {
                w: ::core::clone::Clone::clone(&self.w),
                add: ::core::clone::Clone::clone(&self.add),
                index: ::core::clone::Clone::clone(&self.index),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrhImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrhImmediate {
        #[inline]
        fn eq(&self, other: &LdrhImmediate) -> bool {
            self.w == other.w && self.add == other.add && self.index == other.index
                && self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<LdrhImmediate> for Operation {
        fn from(val: LdrhImmediate) -> Operation {
            Operation::LdrhImmediate(val)
        }
    }
    pub struct LdrhLiteral {
        pub add: Option<bool>,
        pub rt: Register,
        pub imm: u32,
    }
    pub struct LdrhLiteralBuilder<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<Option<bool>>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtSET: bool,
        const immSET: bool,
    > LdrhLiteralBuilder<false, rtSET, immSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> LdrhLiteralBuilder<true, rtSET, immSET> {
            self.add = Some(add);
            LdrhLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const immSET: bool,
    > LdrhLiteralBuilder<addSET, false, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrhLiteralBuilder<addSET, true, immSET> {
            self.rt = Some(rt);
            LdrhLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const rtSET: bool,
    > LdrhLiteralBuilder<addSET, rtSET, false> {
        pub fn set_imm(mut self, imm: u32) -> LdrhLiteralBuilder<addSET, rtSET, true> {
            self.imm = Some(imm);
            LdrhLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl LdrhLiteralBuilder<false, false, false> {
        pub fn new() -> LdrhLiteralBuilder<false, false, false> {
            LdrhLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrhLiteral {
        pub fn builder() -> LdrhLiteralBuilder<false, false, false> {
            LdrhLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrhLiteralBuilder<true, true, true> {
        pub fn complete(self) -> LdrhLiteral {
            LdrhLiteral {
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrhLiteralConsumer<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<Option<bool>>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhLiteralConsumer<false, rtCONSUMED, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (Option<bool>, LdrhLiteralConsumer<true, rtCONSUMED, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrhLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhLiteralConsumer<addCONSUMED, false, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrhLiteralConsumer<addCONSUMED, true, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrhLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
    > LdrhLiteralConsumer<addCONSUMED, rtCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, LdrhLiteralConsumer<addCONSUMED, rtCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrhLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrhLiteral {
        pub fn consumer(self) -> LdrhLiteralConsumer<false, false, false> {
            LdrhLiteralConsumer {
                add: Some(self.add),
                rt: Some(self.rt),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrhLiteralConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrhLiteral {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LdrhLiteral",
                "add",
                &self.add,
                "rt",
                &self.rt,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrhLiteral {
        #[inline]
        fn clone(&self) -> LdrhLiteral {
            LdrhLiteral {
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrhLiteral {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrhLiteral {
        #[inline]
        fn eq(&self, other: &LdrhLiteral) -> bool {
            self.add == other.add && self.rt == other.rt && self.imm == other.imm
        }
    }
    impl From<LdrhLiteral> for Operation {
        fn from(val: LdrhLiteral) -> Operation {
            Operation::LdrhLiteral(val)
        }
    }
    pub struct LdrhRegister {
        pub rt: Register,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct LdrhRegisterBuilder<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrhRegisterBuilder<false, rnSET, rmSET, shiftSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrhRegisterBuilder<true, rnSET, rmSET, shiftSET> {
            self.rt = Some(rt);
            LdrhRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrhRegisterBuilder<rtSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrhRegisterBuilder<rtSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            LdrhRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > LdrhRegisterBuilder<rtSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LdrhRegisterBuilder<rtSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            LdrhRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LdrhRegisterBuilder<rtSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> LdrhRegisterBuilder<rtSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            LdrhRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl LdrhRegisterBuilder<false, false, false, false> {
        pub fn new() -> LdrhRegisterBuilder<false, false, false, false> {
            LdrhRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrhRegister {
        pub fn builder() -> LdrhRegisterBuilder<false, false, false, false> {
            LdrhRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrhRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> LdrhRegister {
            LdrhRegister {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct LdrhRegisterConsumer<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrhRegisterConsumer<false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrhRegisterConsumer<true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrhRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrhRegisterConsumer<rtCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrhRegisterConsumer<rtCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrhRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrhRegisterConsumer<rtCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            LdrhRegisterConsumer<rtCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LdrhRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LdrhRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            LdrhRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                LdrhRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl LdrhRegister {
        pub fn consumer(self) -> LdrhRegisterConsumer<false, false, false, false> {
            LdrhRegisterConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl LdrhRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrhRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LdrhRegister",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrhRegister {
        #[inline]
        fn clone(&self) -> LdrhRegister {
            LdrhRegister {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrhRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrhRegister {
        #[inline]
        fn eq(&self, other: &LdrhRegister) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<LdrhRegister> for Operation {
        fn from(val: LdrhRegister) -> Operation {
            Operation::LdrhRegister(val)
        }
    }
    pub struct Ldrht {
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct LdrhtBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<const rnSET: bool, const immSET: bool> LdrhtBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> LdrhtBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrhtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> LdrhtBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> LdrhtBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrhtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> LdrhtBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: Option<u32>) -> LdrhtBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrhtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrhtBuilder<false, false, false> {
        pub fn new() -> LdrhtBuilder<false, false, false> {
            LdrhtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Ldrht {
        pub fn builder() -> LdrhtBuilder<false, false, false> {
            LdrhtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrhtBuilder<true, true, true> {
        pub fn complete(self) -> Ldrht {
            Ldrht {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrhtConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhtConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrhtConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrhtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrhtConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LdrhtConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrhtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrhtConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (Option<u32>, LdrhtConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrhtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Ldrht {
        pub fn consumer(self) -> LdrhtConsumer<false, false, false> {
            LdrhtConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrhtConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldrht {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ldrht",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldrht {
        #[inline]
        fn clone(&self) -> Ldrht {
            Ldrht {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldrht {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldrht {
        #[inline]
        fn eq(&self, other: &Ldrht) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Ldrht> for Operation {
        fn from(val: Ldrht) -> Operation {
            Operation::Ldrht(val)
        }
    }
    pub struct LdrsbImmediate {
        pub add: bool,
        pub index: bool,
        pub wback: bool,
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct LdrsbImmediateBuilder<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        index: Option<bool>,
        wback: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrsbImmediateBuilder<false, indexSET, wbackSET, rtSET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> LdrsbImmediateBuilder<true, indexSET, wbackSET, rtSET, rnSET, immSET> {
            self.add = Some(add);
            LdrsbImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrsbImmediateBuilder<addSET, false, wbackSET, rtSET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: bool,
        ) -> LdrsbImmediateBuilder<addSET, true, wbackSET, rtSET, rnSET, immSET> {
            self.index = Some(index);
            LdrsbImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrsbImmediateBuilder<addSET, indexSET, false, rtSET, rnSET, immSET> {
        pub fn set_wback(
            mut self,
            wback: bool,
        ) -> LdrsbImmediateBuilder<addSET, indexSET, true, rtSET, rnSET, immSET> {
            self.wback = Some(wback);
            LdrsbImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrsbImmediateBuilder<addSET, indexSET, wbackSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrsbImmediateBuilder<addSET, indexSET, wbackSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrsbImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > LdrsbImmediateBuilder<addSET, indexSET, wbackSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrsbImmediateBuilder<addSET, indexSET, wbackSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrsbImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > LdrsbImmediateBuilder<addSET, indexSET, wbackSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: Option<u32>,
        ) -> LdrsbImmediateBuilder<addSET, indexSET, wbackSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrsbImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrsbImmediateBuilder<false, false, false, false, false, false> {
        pub fn new() -> LdrsbImmediateBuilder<false, false, false, false, false, false> {
            LdrsbImmediateBuilder {
                add: None,
                index: None,
                wback: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrsbImmediate {
        pub fn builder() -> LdrsbImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdrsbImmediateBuilder {
                add: None,
                index: None,
                wback: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrsbImmediateBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> LdrsbImmediate {
            LdrsbImmediate {
                add: self.add.unwrap(),
                index: self.index.unwrap(),
                wback: self.wback.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrsbImmediateConsumer<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        index: Option<bool>,
        wback: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const indexCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbImmediateConsumer<
        false,
        indexCONSUMED,
        wbackCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            LdrsbImmediateConsumer<
                true,
                indexCONSUMED,
                wbackCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrsbImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbImmediateConsumer<
        addCONSUMED,
        false,
        wbackCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            bool,
            LdrsbImmediateConsumer<
                addCONSUMED,
                true,
                wbackCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdrsbImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbImmediateConsumer<
        addCONSUMED,
        indexCONSUMED,
        false,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_wback(
            mut self,
        ) -> (
            bool,
            LdrsbImmediateConsumer<
                addCONSUMED,
                indexCONSUMED,
                true,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.wback.unwrap();
            self.wback = None;
            (
                ret,
                LdrsbImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbImmediateConsumer<
        addCONSUMED,
        indexCONSUMED,
        wbackCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrsbImmediateConsumer<
                addCONSUMED,
                indexCONSUMED,
                wbackCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrsbImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbImmediateConsumer<
        addCONSUMED,
        indexCONSUMED,
        wbackCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrsbImmediateConsumer<
                addCONSUMED,
                indexCONSUMED,
                wbackCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrsbImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrsbImmediateConsumer<
        addCONSUMED,
        indexCONSUMED,
        wbackCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            Option<u32>,
            LdrsbImmediateConsumer<
                addCONSUMED,
                indexCONSUMED,
                wbackCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrsbImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrsbImmediate {
        pub fn consumer(
            self,
        ) -> LdrsbImmediateConsumer<false, false, false, false, false, false> {
            LdrsbImmediateConsumer {
                add: Some(self.add),
                index: Some(self.index),
                wback: Some(self.wback),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrsbImmediateConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrsbImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["add", "index", "wback", "rt", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.add,
                &self.index,
                &self.wback,
                &self.rt,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LdrsbImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrsbImmediate {
        #[inline]
        fn clone(&self) -> LdrsbImmediate {
            LdrsbImmediate {
                add: ::core::clone::Clone::clone(&self.add),
                index: ::core::clone::Clone::clone(&self.index),
                wback: ::core::clone::Clone::clone(&self.wback),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrsbImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrsbImmediate {
        #[inline]
        fn eq(&self, other: &LdrsbImmediate) -> bool {
            self.add == other.add && self.index == other.index
                && self.wback == other.wback && self.rt == other.rt
                && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<LdrsbImmediate> for Operation {
        fn from(val: LdrsbImmediate) -> Operation {
            Operation::LdrsbImmediate(val)
        }
    }
    pub struct LdrsbLiteral {
        pub add: bool,
        pub rt: Register,
        pub imm: u32,
    }
    pub struct LdrsbLiteralBuilder<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtSET: bool,
        const immSET: bool,
    > LdrsbLiteralBuilder<false, rtSET, immSET> {
        pub fn set_add(mut self, add: bool) -> LdrsbLiteralBuilder<true, rtSET, immSET> {
            self.add = Some(add);
            LdrsbLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const immSET: bool,
    > LdrsbLiteralBuilder<addSET, false, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrsbLiteralBuilder<addSET, true, immSET> {
            self.rt = Some(rt);
            LdrsbLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const rtSET: bool,
    > LdrsbLiteralBuilder<addSET, rtSET, false> {
        pub fn set_imm(mut self, imm: u32) -> LdrsbLiteralBuilder<addSET, rtSET, true> {
            self.imm = Some(imm);
            LdrsbLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl LdrsbLiteralBuilder<false, false, false> {
        pub fn new() -> LdrsbLiteralBuilder<false, false, false> {
            LdrsbLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrsbLiteral {
        pub fn builder() -> LdrsbLiteralBuilder<false, false, false> {
            LdrsbLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrsbLiteralBuilder<true, true, true> {
        pub fn complete(self) -> LdrsbLiteral {
            LdrsbLiteral {
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrsbLiteralConsumer<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbLiteralConsumer<false, rtCONSUMED, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (bool, LdrsbLiteralConsumer<true, rtCONSUMED, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrsbLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbLiteralConsumer<addCONSUMED, false, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrsbLiteralConsumer<addCONSUMED, true, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrsbLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
    > LdrsbLiteralConsumer<addCONSUMED, rtCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, LdrsbLiteralConsumer<addCONSUMED, rtCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrsbLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrsbLiteral {
        pub fn consumer(self) -> LdrsbLiteralConsumer<false, false, false> {
            LdrsbLiteralConsumer {
                add: Some(self.add),
                rt: Some(self.rt),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrsbLiteralConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrsbLiteral {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LdrsbLiteral",
                "add",
                &self.add,
                "rt",
                &self.rt,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrsbLiteral {
        #[inline]
        fn clone(&self) -> LdrsbLiteral {
            LdrsbLiteral {
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrsbLiteral {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrsbLiteral {
        #[inline]
        fn eq(&self, other: &LdrsbLiteral) -> bool {
            self.add == other.add && self.rt == other.rt && self.imm == other.imm
        }
    }
    impl From<LdrsbLiteral> for Operation {
        fn from(val: LdrsbLiteral) -> Operation {
            Operation::LdrsbLiteral(val)
        }
    }
    pub struct LdrsbRegister {
        pub rt: Register,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct LdrsbRegisterBuilder<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrsbRegisterBuilder<false, rnSET, rmSET, shiftSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrsbRegisterBuilder<true, rnSET, rmSET, shiftSET> {
            self.rt = Some(rt);
            LdrsbRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrsbRegisterBuilder<rtSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrsbRegisterBuilder<rtSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            LdrsbRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > LdrsbRegisterBuilder<rtSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LdrsbRegisterBuilder<rtSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            LdrsbRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LdrsbRegisterBuilder<rtSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> LdrsbRegisterBuilder<rtSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            LdrsbRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl LdrsbRegisterBuilder<false, false, false, false> {
        pub fn new() -> LdrsbRegisterBuilder<false, false, false, false> {
            LdrsbRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrsbRegister {
        pub fn builder() -> LdrsbRegisterBuilder<false, false, false, false> {
            LdrsbRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrsbRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> LdrsbRegister {
            LdrsbRegister {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct LdrsbRegisterConsumer<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrsbRegisterConsumer<false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrsbRegisterConsumer<true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrsbRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrsbRegisterConsumer<rtCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrsbRegisterConsumer<rtCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrsbRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrsbRegisterConsumer<rtCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            LdrsbRegisterConsumer<rtCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LdrsbRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LdrsbRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            LdrsbRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                LdrsbRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl LdrsbRegister {
        pub fn consumer(self) -> LdrsbRegisterConsumer<false, false, false, false> {
            LdrsbRegisterConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl LdrsbRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrsbRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LdrsbRegister",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrsbRegister {
        #[inline]
        fn clone(&self) -> LdrsbRegister {
            LdrsbRegister {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrsbRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrsbRegister {
        #[inline]
        fn eq(&self, other: &LdrsbRegister) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<LdrsbRegister> for Operation {
        fn from(val: LdrsbRegister) -> Operation {
            Operation::LdrsbRegister(val)
        }
    }
    pub struct Ldrsbt {
        pub rt: Register,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct LdrsbtBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<const rnSET: bool, const immSET: bool> LdrsbtBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> LdrsbtBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrsbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> LdrsbtBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> LdrsbtBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrsbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> LdrsbtBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: u32) -> LdrsbtBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrsbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrsbtBuilder<false, false, false> {
        pub fn new() -> LdrsbtBuilder<false, false, false> {
            LdrsbtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Ldrsbt {
        pub fn builder() -> LdrsbtBuilder<false, false, false> {
            LdrsbtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrsbtBuilder<true, true, true> {
        pub fn complete(self) -> Ldrsbt {
            Ldrsbt {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrsbtConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbtConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrsbtConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrsbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrsbtConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LdrsbtConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrsbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrsbtConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, LdrsbtConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrsbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Ldrsbt {
        pub fn consumer(self) -> LdrsbtConsumer<false, false, false> {
            LdrsbtConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrsbtConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldrsbt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ldrsbt",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldrsbt {
        #[inline]
        fn clone(&self) -> Ldrsbt {
            Ldrsbt {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldrsbt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldrsbt {
        #[inline]
        fn eq(&self, other: &Ldrsbt) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Ldrsbt> for Operation {
        fn from(val: Ldrsbt) -> Operation {
            Operation::Ldrsbt(val)
        }
    }
    pub struct LdrshImmediate {
        pub add: bool,
        pub index: bool,
        pub wback: bool,
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct LdrshImmediateBuilder<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        index: Option<bool>,
        wback: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrshImmediateBuilder<false, indexSET, wbackSET, rtSET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> LdrshImmediateBuilder<true, indexSET, wbackSET, rtSET, rnSET, immSET> {
            self.add = Some(add);
            LdrshImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrshImmediateBuilder<addSET, false, wbackSET, rtSET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: bool,
        ) -> LdrshImmediateBuilder<addSET, true, wbackSET, rtSET, rnSET, immSET> {
            self.index = Some(index);
            LdrshImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrshImmediateBuilder<addSET, indexSET, false, rtSET, rnSET, immSET> {
        pub fn set_wback(
            mut self,
            wback: bool,
        ) -> LdrshImmediateBuilder<addSET, indexSET, true, rtSET, rnSET, immSET> {
            self.wback = Some(wback);
            LdrshImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > LdrshImmediateBuilder<addSET, indexSET, wbackSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrshImmediateBuilder<addSET, indexSET, wbackSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrshImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > LdrshImmediateBuilder<addSET, indexSET, wbackSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrshImmediateBuilder<addSET, indexSET, wbackSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrshImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > LdrshImmediateBuilder<addSET, indexSET, wbackSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: Option<u32>,
        ) -> LdrshImmediateBuilder<addSET, indexSET, wbackSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrshImmediateBuilder {
                add: self.add,
                index: self.index,
                wback: self.wback,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrshImmediateBuilder<false, false, false, false, false, false> {
        pub fn new() -> LdrshImmediateBuilder<false, false, false, false, false, false> {
            LdrshImmediateBuilder {
                add: None,
                index: None,
                wback: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrshImmediate {
        pub fn builder() -> LdrshImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdrshImmediateBuilder {
                add: None,
                index: None,
                wback: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrshImmediateBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> LdrshImmediate {
            LdrshImmediate {
                add: self.add.unwrap(),
                index: self.index.unwrap(),
                wback: self.wback.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrshImmediateConsumer<
        const addSET: bool,
        const indexSET: bool,
        const wbackSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        index: Option<bool>,
        wback: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const indexCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshImmediateConsumer<
        false,
        indexCONSUMED,
        wbackCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            LdrshImmediateConsumer<
                true,
                indexCONSUMED,
                wbackCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrshImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshImmediateConsumer<
        addCONSUMED,
        false,
        wbackCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            bool,
            LdrshImmediateConsumer<
                addCONSUMED,
                true,
                wbackCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdrshImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshImmediateConsumer<
        addCONSUMED,
        indexCONSUMED,
        false,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_wback(
            mut self,
        ) -> (
            bool,
            LdrshImmediateConsumer<
                addCONSUMED,
                indexCONSUMED,
                true,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.wback.unwrap();
            self.wback = None;
            (
                ret,
                LdrshImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshImmediateConsumer<
        addCONSUMED,
        indexCONSUMED,
        wbackCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrshImmediateConsumer<
                addCONSUMED,
                indexCONSUMED,
                wbackCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrshImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshImmediateConsumer<
        addCONSUMED,
        indexCONSUMED,
        wbackCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrshImmediateConsumer<
                addCONSUMED,
                indexCONSUMED,
                wbackCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrshImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
        const wbackCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrshImmediateConsumer<
        addCONSUMED,
        indexCONSUMED,
        wbackCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            Option<u32>,
            LdrshImmediateConsumer<
                addCONSUMED,
                indexCONSUMED,
                wbackCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrshImmediateConsumer {
                    add: self.add,
                    index: self.index,
                    wback: self.wback,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrshImmediate {
        pub fn consumer(
            self,
        ) -> LdrshImmediateConsumer<false, false, false, false, false, false> {
            LdrshImmediateConsumer {
                add: Some(self.add),
                index: Some(self.index),
                wback: Some(self.wback),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrshImmediateConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrshImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["add", "index", "wback", "rt", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.add,
                &self.index,
                &self.wback,
                &self.rt,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LdrshImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrshImmediate {
        #[inline]
        fn clone(&self) -> LdrshImmediate {
            LdrshImmediate {
                add: ::core::clone::Clone::clone(&self.add),
                index: ::core::clone::Clone::clone(&self.index),
                wback: ::core::clone::Clone::clone(&self.wback),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrshImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrshImmediate {
        #[inline]
        fn eq(&self, other: &LdrshImmediate) -> bool {
            self.add == other.add && self.index == other.index
                && self.wback == other.wback && self.rt == other.rt
                && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<LdrshImmediate> for Operation {
        fn from(val: LdrshImmediate) -> Operation {
            Operation::LdrshImmediate(val)
        }
    }
    pub struct LdrshLiteral {
        pub add: bool,
        pub rt: Register,
        pub imm: u32,
    }
    pub struct LdrshLiteralBuilder<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtSET: bool,
        const immSET: bool,
    > LdrshLiteralBuilder<false, rtSET, immSET> {
        pub fn set_add(mut self, add: bool) -> LdrshLiteralBuilder<true, rtSET, immSET> {
            self.add = Some(add);
            LdrshLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const immSET: bool,
    > LdrshLiteralBuilder<addSET, false, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrshLiteralBuilder<addSET, true, immSET> {
            self.rt = Some(rt);
            LdrshLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const rtSET: bool,
    > LdrshLiteralBuilder<addSET, rtSET, false> {
        pub fn set_imm(mut self, imm: u32) -> LdrshLiteralBuilder<addSET, rtSET, true> {
            self.imm = Some(imm);
            LdrshLiteralBuilder {
                add: self.add,
                rt: self.rt,
                imm: self.imm,
            }
        }
    }
    impl LdrshLiteralBuilder<false, false, false> {
        pub fn new() -> LdrshLiteralBuilder<false, false, false> {
            LdrshLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrshLiteral {
        pub fn builder() -> LdrshLiteralBuilder<false, false, false> {
            LdrshLiteralBuilder {
                add: None,
                rt: None,
                imm: None,
            }
        }
    }
    impl LdrshLiteralBuilder<true, true, true> {
        pub fn complete(self) -> LdrshLiteral {
            LdrshLiteral {
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrshLiteralConsumer<
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > {
        add: Option<bool>,
        rt: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshLiteralConsumer<false, rtCONSUMED, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (bool, LdrshLiteralConsumer<true, rtCONSUMED, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdrshLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshLiteralConsumer<addCONSUMED, false, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrshLiteralConsumer<addCONSUMED, true, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrshLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
    > LdrshLiteralConsumer<addCONSUMED, rtCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, LdrshLiteralConsumer<addCONSUMED, rtCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrshLiteralConsumer {
                    add: self.add,
                    rt: self.rt,
                    imm: self.imm,
                },
            )
        }
    }
    impl LdrshLiteral {
        pub fn consumer(self) -> LdrshLiteralConsumer<false, false, false> {
            LdrshLiteralConsumer {
                add: Some(self.add),
                rt: Some(self.rt),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrshLiteralConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrshLiteral {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LdrshLiteral",
                "add",
                &self.add,
                "rt",
                &self.rt,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrshLiteral {
        #[inline]
        fn clone(&self) -> LdrshLiteral {
            LdrshLiteral {
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrshLiteral {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrshLiteral {
        #[inline]
        fn eq(&self, other: &LdrshLiteral) -> bool {
            self.add == other.add && self.rt == other.rt && self.imm == other.imm
        }
    }
    impl From<LdrshLiteral> for Operation {
        fn from(val: LdrshLiteral) -> Operation {
            Operation::LdrshLiteral(val)
        }
    }
    pub struct LdrshRegister {
        pub rt: Register,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct LdrshRegisterBuilder<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrshRegisterBuilder<false, rnSET, rmSET, shiftSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> LdrshRegisterBuilder<true, rnSET, rmSET, shiftSET> {
            self.rt = Some(rt);
            LdrshRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > LdrshRegisterBuilder<rtSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdrshRegisterBuilder<rtSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            LdrshRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > LdrshRegisterBuilder<rtSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LdrshRegisterBuilder<rtSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            LdrshRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LdrshRegisterBuilder<rtSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> LdrshRegisterBuilder<rtSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            LdrshRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl LdrshRegisterBuilder<false, false, false, false> {
        pub fn new() -> LdrshRegisterBuilder<false, false, false, false> {
            LdrshRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrshRegister {
        pub fn builder() -> LdrshRegisterBuilder<false, false, false, false> {
            LdrshRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl LdrshRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> LdrshRegister {
            LdrshRegister {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct LdrshRegisterConsumer<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrshRegisterConsumer<false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            LdrshRegisterConsumer<true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrshRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrshRegisterConsumer<rtCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdrshRegisterConsumer<rtCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrshRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > LdrshRegisterConsumer<rtCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            LdrshRegisterConsumer<rtCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LdrshRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LdrshRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            LdrshRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                LdrshRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl LdrshRegister {
        pub fn consumer(self) -> LdrshRegisterConsumer<false, false, false, false> {
            LdrshRegisterConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl LdrshRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdrshRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LdrshRegister",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdrshRegister {
        #[inline]
        fn clone(&self) -> LdrshRegister {
            LdrshRegister {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdrshRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdrshRegister {
        #[inline]
        fn eq(&self, other: &LdrshRegister) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<LdrshRegister> for Operation {
        fn from(val: LdrshRegister) -> Operation {
            Operation::LdrshRegister(val)
        }
    }
    pub struct Ldrsht {
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct LdrshtBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<const rnSET: bool, const immSET: bool> LdrshtBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> LdrshtBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrshtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> LdrshtBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> LdrshtBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrshtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> LdrshtBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: Option<u32>) -> LdrshtBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrshtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrshtBuilder<false, false, false> {
        pub fn new() -> LdrshtBuilder<false, false, false> {
            LdrshtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Ldrsht {
        pub fn builder() -> LdrshtBuilder<false, false, false> {
            LdrshtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrshtBuilder<true, true, true> {
        pub fn complete(self) -> Ldrsht {
            Ldrsht {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrshtConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshtConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrshtConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrshtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrshtConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LdrshtConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrshtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrshtConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (Option<u32>, LdrshtConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrshtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Ldrsht {
        pub fn consumer(self) -> LdrshtConsumer<false, false, false> {
            LdrshtConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrshtConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldrsht {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ldrsht",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldrsht {
        #[inline]
        fn clone(&self) -> Ldrsht {
            Ldrsht {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldrsht {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldrsht {
        #[inline]
        fn eq(&self, other: &Ldrsht) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Ldrsht> for Operation {
        fn from(val: Ldrsht) -> Operation {
            Operation::Ldrsht(val)
        }
    }
    pub struct Ldrt {
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct LdrtBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<const rnSET: bool, const immSET: bool> LdrtBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> LdrtBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            LdrtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> LdrtBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> LdrtBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            LdrtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> LdrtBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: Option<u32>) -> LdrtBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            LdrtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl LdrtBuilder<false, false, false> {
        pub fn new() -> LdrtBuilder<false, false, false> {
            LdrtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Ldrt {
        pub fn builder() -> LdrtBuilder<false, false, false> {
            LdrtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl LdrtBuilder<true, true, true> {
        pub fn complete(self) -> Ldrt {
            Ldrt {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LdrtConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrtConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, LdrtConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                LdrtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > LdrtConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LdrtConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdrtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > LdrtConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (Option<u32>, LdrtConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdrtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Ldrt {
        pub fn consumer(self) -> LdrtConsumer<false, false, false> {
            LdrtConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl LdrtConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ldrt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ldrt",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ldrt {
        #[inline]
        fn clone(&self) -> Ldrt {
            Ldrt {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ldrt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ldrt {
        #[inline]
        fn eq(&self, other: &Ldrt) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Ldrt> for Operation {
        fn from(val: Ldrt) -> Operation {
            Operation::Ldrt(val)
        }
    }
    pub struct LdcImmediate {
        pub coproc: CoProcessor,
        pub crd: u8,
        pub rn: Register,
        pub imm: Option<u32>,
        pub add: bool,
        pub w: bool,
        pub index: bool,
    }
    pub struct LdcImmediateBuilder<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > {
        coproc: Option<CoProcessor>,
        crd: Option<u8>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
        add: Option<bool>,
        w: Option<bool>,
        index: Option<bool>,
    }
    impl<
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > LdcImmediateBuilder<false, crdSET, rnSET, immSET, addSET, wSET, indexSET> {
        pub fn set_coproc(
            mut self,
            coproc: CoProcessor,
        ) -> LdcImmediateBuilder<true, crdSET, rnSET, immSET, addSET, wSET, indexSET> {
            self.coproc = Some(coproc);
            LdcImmediateBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > LdcImmediateBuilder<coprocSET, false, rnSET, immSET, addSET, wSET, indexSET> {
        pub fn set_crd(
            mut self,
            crd: u8,
        ) -> LdcImmediateBuilder<
            coprocSET,
            true,
            rnSET,
            immSET,
            addSET,
            wSET,
            indexSET,
        > {
            self.crd = Some(crd);
            LdcImmediateBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > LdcImmediateBuilder<coprocSET, crdSET, false, immSET, addSET, wSET, indexSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LdcImmediateBuilder<
            coprocSET,
            crdSET,
            true,
            immSET,
            addSET,
            wSET,
            indexSET,
        > {
            self.rn = Some(rn);
            LdcImmediateBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > LdcImmediateBuilder<coprocSET, crdSET, rnSET, false, addSET, wSET, indexSET> {
        pub fn set_imm(
            mut self,
            imm: Option<u32>,
        ) -> LdcImmediateBuilder<
            coprocSET,
            crdSET,
            rnSET,
            true,
            addSET,
            wSET,
            indexSET,
        > {
            self.imm = Some(imm);
            LdcImmediateBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > LdcImmediateBuilder<coprocSET, crdSET, rnSET, immSET, false, wSET, indexSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> LdcImmediateBuilder<
            coprocSET,
            crdSET,
            rnSET,
            immSET,
            true,
            wSET,
            indexSET,
        > {
            self.add = Some(add);
            LdcImmediateBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const indexSET: bool,
    > LdcImmediateBuilder<coprocSET, crdSET, rnSET, immSET, addSET, false, indexSET> {
        pub fn set_w(
            mut self,
            w: bool,
        ) -> LdcImmediateBuilder<
            coprocSET,
            crdSET,
            rnSET,
            immSET,
            addSET,
            true,
            indexSET,
        > {
            self.w = Some(w);
            LdcImmediateBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
    > LdcImmediateBuilder<coprocSET, crdSET, rnSET, immSET, addSET, wSET, false> {
        pub fn set_index(
            mut self,
            index: bool,
        ) -> LdcImmediateBuilder<coprocSET, crdSET, rnSET, immSET, addSET, wSET, true> {
            self.index = Some(index);
            LdcImmediateBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl LdcImmediateBuilder<false, false, false, false, false, false, false> {
        pub fn new() -> LdcImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdcImmediateBuilder {
                coproc: None,
                crd: None,
                rn: None,
                imm: None,
                add: None,
                w: None,
                index: None,
            }
        }
    }
    impl LdcImmediate {
        pub fn builder() -> LdcImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            LdcImmediateBuilder {
                coproc: None,
                crd: None,
                rn: None,
                imm: None,
                add: None,
                w: None,
                index: None,
            }
        }
    }
    impl LdcImmediateBuilder<true, true, true, true, true, true, true> {
        pub fn complete(self) -> LdcImmediate {
            LdcImmediate {
                coproc: self.coproc.unwrap(),
                crd: self.crd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
                add: self.add.unwrap(),
                w: self.w.unwrap(),
                index: self.index.unwrap(),
            }
        }
    }
    pub struct LdcImmediateConsumer<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > {
        coproc: Option<CoProcessor>,
        crd: Option<u8>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
        add: Option<bool>,
        w: Option<bool>,
        index: Option<bool>,
    }
    impl<
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcImmediateConsumer<
        false,
        crdCONSUMED,
        rnCONSUMED,
        immCONSUMED,
        addCONSUMED,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_coproc(
            mut self,
        ) -> (
            CoProcessor,
            LdcImmediateConsumer<
                true,
                crdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                addCONSUMED,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.coproc.unwrap();
            self.coproc = None;
            (
                ret,
                LdcImmediateConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcImmediateConsumer<
        coprocCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
        addCONSUMED,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_crd(
            mut self,
        ) -> (
            u8,
            LdcImmediateConsumer<
                coprocCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
                addCONSUMED,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.crd.unwrap();
            self.crd = None;
            (
                ret,
                LdcImmediateConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcImmediateConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        false,
        immCONSUMED,
        addCONSUMED,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            LdcImmediateConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                true,
                immCONSUMED,
                addCONSUMED,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LdcImmediateConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcImmediateConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        rnCONSUMED,
        false,
        addCONSUMED,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            Option<u32>,
            LdcImmediateConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                rnCONSUMED,
                true,
                addCONSUMED,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdcImmediateConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcImmediateConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        rnCONSUMED,
        immCONSUMED,
        false,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            LdcImmediateConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                true,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdcImmediateConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcImmediateConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        rnCONSUMED,
        immCONSUMED,
        addCONSUMED,
        false,
        indexCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            bool,
            LdcImmediateConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                addCONSUMED,
                true,
                indexCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                LdcImmediateConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
    > LdcImmediateConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        rnCONSUMED,
        immCONSUMED,
        addCONSUMED,
        wCONSUMED,
        false,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            bool,
            LdcImmediateConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                addCONSUMED,
                wCONSUMED,
                true,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdcImmediateConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl LdcImmediate {
        pub fn consumer(
            self,
        ) -> LdcImmediateConsumer<false, false, false, false, false, false, false> {
            LdcImmediateConsumer {
                coproc: Some(self.coproc),
                crd: Some(self.crd),
                rn: Some(self.rn),
                imm: Some(self.imm),
                add: Some(self.add),
                w: Some(self.w),
                index: Some(self.index),
            }
        }
    }
    impl LdcImmediateConsumer<true, true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdcImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["coproc", "crd", "rn", "imm", "add", "w", "index"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.coproc,
                &self.crd,
                &self.rn,
                &self.imm,
                &self.add,
                &self.w,
                &&self.index,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "LdcImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdcImmediate {
        #[inline]
        fn clone(&self) -> LdcImmediate {
            LdcImmediate {
                coproc: ::core::clone::Clone::clone(&self.coproc),
                crd: ::core::clone::Clone::clone(&self.crd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
                add: ::core::clone::Clone::clone(&self.add),
                w: ::core::clone::Clone::clone(&self.w),
                index: ::core::clone::Clone::clone(&self.index),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdcImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdcImmediate {
        #[inline]
        fn eq(&self, other: &LdcImmediate) -> bool {
            self.coproc == other.coproc && self.crd == other.crd && self.rn == other.rn
                && self.imm == other.imm && self.add == other.add && self.w == other.w
                && self.index == other.index
        }
    }
    impl From<LdcImmediate> for Operation {
        fn from(val: LdcImmediate) -> Operation {
            Operation::LdcImmediate(val)
        }
    }
    pub struct LdcLiteral {
        pub coproc: CoProcessor,
        pub crd: u8,
        pub imm: u32,
        pub add: bool,
        pub index: bool,
    }
    pub struct LdcLiteralBuilder<
        const coprocSET: bool,
        const crdSET: bool,
        const immSET: bool,
        const addSET: bool,
        const indexSET: bool,
    > {
        coproc: Option<CoProcessor>,
        crd: Option<u8>,
        imm: Option<u32>,
        add: Option<bool>,
        index: Option<bool>,
    }
    impl<
        const crdSET: bool,
        const immSET: bool,
        const addSET: bool,
        const indexSET: bool,
    > LdcLiteralBuilder<false, crdSET, immSET, addSET, indexSET> {
        pub fn set_coproc(
            mut self,
            coproc: CoProcessor,
        ) -> LdcLiteralBuilder<true, crdSET, immSET, addSET, indexSET> {
            self.coproc = Some(coproc);
            LdcLiteralBuilder {
                coproc: self.coproc,
                crd: self.crd,
                imm: self.imm,
                add: self.add,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const immSET: bool,
        const addSET: bool,
        const indexSET: bool,
    > LdcLiteralBuilder<coprocSET, false, immSET, addSET, indexSET> {
        pub fn set_crd(
            mut self,
            crd: u8,
        ) -> LdcLiteralBuilder<coprocSET, true, immSET, addSET, indexSET> {
            self.crd = Some(crd);
            LdcLiteralBuilder {
                coproc: self.coproc,
                crd: self.crd,
                imm: self.imm,
                add: self.add,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const addSET: bool,
        const indexSET: bool,
    > LdcLiteralBuilder<coprocSET, crdSET, false, addSET, indexSET> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> LdcLiteralBuilder<coprocSET, crdSET, true, addSET, indexSET> {
            self.imm = Some(imm);
            LdcLiteralBuilder {
                coproc: self.coproc,
                crd: self.crd,
                imm: self.imm,
                add: self.add,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const immSET: bool,
        const indexSET: bool,
    > LdcLiteralBuilder<coprocSET, crdSET, immSET, false, indexSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> LdcLiteralBuilder<coprocSET, crdSET, immSET, true, indexSET> {
            self.add = Some(add);
            LdcLiteralBuilder {
                coproc: self.coproc,
                crd: self.crd,
                imm: self.imm,
                add: self.add,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const immSET: bool,
        const addSET: bool,
    > LdcLiteralBuilder<coprocSET, crdSET, immSET, addSET, false> {
        pub fn set_index(
            mut self,
            index: bool,
        ) -> LdcLiteralBuilder<coprocSET, crdSET, immSET, addSET, true> {
            self.index = Some(index);
            LdcLiteralBuilder {
                coproc: self.coproc,
                crd: self.crd,
                imm: self.imm,
                add: self.add,
                index: self.index,
            }
        }
    }
    impl LdcLiteralBuilder<false, false, false, false, false> {
        pub fn new() -> LdcLiteralBuilder<false, false, false, false, false> {
            LdcLiteralBuilder {
                coproc: None,
                crd: None,
                imm: None,
                add: None,
                index: None,
            }
        }
    }
    impl LdcLiteral {
        pub fn builder() -> LdcLiteralBuilder<false, false, false, false, false> {
            LdcLiteralBuilder {
                coproc: None,
                crd: None,
                imm: None,
                add: None,
                index: None,
            }
        }
    }
    impl LdcLiteralBuilder<true, true, true, true, true> {
        pub fn complete(self) -> LdcLiteral {
            LdcLiteral {
                coproc: self.coproc.unwrap(),
                crd: self.crd.unwrap(),
                imm: self.imm.unwrap(),
                add: self.add.unwrap(),
                index: self.index.unwrap(),
            }
        }
    }
    pub struct LdcLiteralConsumer<
        const coprocSET: bool,
        const crdSET: bool,
        const immSET: bool,
        const addSET: bool,
        const indexSET: bool,
    > {
        coproc: Option<CoProcessor>,
        crd: Option<u8>,
        imm: Option<u32>,
        add: Option<bool>,
        index: Option<bool>,
    }
    impl<
        const crdCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcLiteralConsumer<false, crdCONSUMED, immCONSUMED, addCONSUMED, indexCONSUMED> {
        pub fn consume_coproc(
            mut self,
        ) -> (
            CoProcessor,
            LdcLiteralConsumer<
                true,
                crdCONSUMED,
                immCONSUMED,
                addCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.coproc.unwrap();
            self.coproc = None;
            (
                ret,
                LdcLiteralConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    imm: self.imm,
                    add: self.add,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcLiteralConsumer<
        coprocCONSUMED,
        false,
        immCONSUMED,
        addCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_crd(
            mut self,
        ) -> (
            u8,
            LdcLiteralConsumer<
                coprocCONSUMED,
                true,
                immCONSUMED,
                addCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.crd.unwrap();
            self.crd = None;
            (
                ret,
                LdcLiteralConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    imm: self.imm,
                    add: self.add,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcLiteralConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        false,
        addCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            LdcLiteralConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                true,
                addCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LdcLiteralConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    imm: self.imm,
                    add: self.add,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const immCONSUMED: bool,
        const indexCONSUMED: bool,
    > LdcLiteralConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        immCONSUMED,
        false,
        indexCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            LdcLiteralConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                immCONSUMED,
                true,
                indexCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                LdcLiteralConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    imm: self.imm,
                    add: self.add,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
    > LdcLiteralConsumer<coprocCONSUMED, crdCONSUMED, immCONSUMED, addCONSUMED, false> {
        pub fn consume_index(
            mut self,
        ) -> (
            bool,
            LdcLiteralConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                immCONSUMED,
                addCONSUMED,
                true,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                LdcLiteralConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    imm: self.imm,
                    add: self.add,
                    index: self.index,
                },
            )
        }
    }
    impl LdcLiteral {
        pub fn consumer(self) -> LdcLiteralConsumer<false, false, false, false, false> {
            LdcLiteralConsumer {
                coproc: Some(self.coproc),
                crd: Some(self.crd),
                imm: Some(self.imm),
                add: Some(self.add),
                index: Some(self.index),
            }
        }
    }
    impl LdcLiteralConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LdcLiteral {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "LdcLiteral",
                "coproc",
                &self.coproc,
                "crd",
                &self.crd,
                "imm",
                &self.imm,
                "add",
                &self.add,
                "index",
                &&self.index,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LdcLiteral {
        #[inline]
        fn clone(&self) -> LdcLiteral {
            LdcLiteral {
                coproc: ::core::clone::Clone::clone(&self.coproc),
                crd: ::core::clone::Clone::clone(&self.crd),
                imm: ::core::clone::Clone::clone(&self.imm),
                add: ::core::clone::Clone::clone(&self.add),
                index: ::core::clone::Clone::clone(&self.index),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LdcLiteral {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LdcLiteral {
        #[inline]
        fn eq(&self, other: &LdcLiteral) -> bool {
            self.coproc == other.coproc && self.crd == other.crd && self.imm == other.imm
                && self.add == other.add && self.index == other.index
        }
    }
    impl From<LdcLiteral> for Operation {
        fn from(val: LdcLiteral) -> Operation {
            Operation::LdcLiteral(val)
        }
    }
    pub struct LslImmediate {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub rm: Register,
        pub imm: u8,
    }
    pub struct LslImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rm: Option<Register>,
        imm: Option<u8>,
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > LslImmediateBuilder<false, rdSET, rmSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> LslImmediateBuilder<true, rdSET, rmSET, immSET> {
            self.s = Some(s);
            LslImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > LslImmediateBuilder<sSET, false, rmSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> LslImmediateBuilder<sSET, true, rmSET, immSET> {
            self.rd = Some(rd);
            LslImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > LslImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LslImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rm = Some(rm);
            LslImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > LslImmediateBuilder<sSET, rdSET, rmSET, false> {
        pub fn set_imm(
            mut self,
            imm: u8,
        ) -> LslImmediateBuilder<sSET, rdSET, rmSET, true> {
            self.imm = Some(imm);
            LslImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl LslImmediateBuilder<false, false, false, false> {
        pub fn new() -> LslImmediateBuilder<false, false, false, false> {
            LslImmediateBuilder {
                s: None,
                rd: None,
                rm: None,
                imm: None,
            }
        }
    }
    impl LslImmediate {
        pub fn builder() -> LslImmediateBuilder<false, false, false, false> {
            LslImmediateBuilder {
                s: None,
                rd: None,
                rm: None,
                imm: None,
            }
        }
    }
    impl LslImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> LslImmediate {
            LslImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LslImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rm: Option<Register>,
        imm: Option<u8>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const immCONSUMED: bool,
    > LslImmediateConsumer<false, rdCONSUMED, rmCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            LslImmediateConsumer<true, rdCONSUMED, rmCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                LslImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
        const immCONSUMED: bool,
    > LslImmediateConsumer<sCONSUMED, false, rmCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, LslImmediateConsumer<sCONSUMED, true, rmCONSUMED, immCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                LslImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > LslImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, LslImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LslImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > LslImmediateConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u8, LslImmediateConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LslImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl LslImmediate {
        pub fn consumer(self) -> LslImmediateConsumer<false, false, false, false> {
            LslImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
                imm: Some(self.imm),
            }
        }
    }
    impl LslImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LslImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LslImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LslImmediate {
        #[inline]
        fn clone(&self) -> LslImmediate {
            LslImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LslImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LslImmediate {
        #[inline]
        fn eq(&self, other: &LslImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
                && self.imm == other.imm
        }
    }
    impl From<LslImmediate> for Operation {
        fn from(val: LslImmediate) -> Operation {
            Operation::LslImmediate(val)
        }
    }
    pub struct LslRegister {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct LslRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LslRegisterBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> LslRegisterBuilder<true, rdSET, rnSET, rmSET> {
            self.s = Some(s);
            LslRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LslRegisterBuilder<sSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> LslRegisterBuilder<sSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            LslRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > LslRegisterBuilder<sSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LslRegisterBuilder<sSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            LslRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > LslRegisterBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LslRegisterBuilder<sSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            LslRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl LslRegisterBuilder<false, false, false, false> {
        pub fn new() -> LslRegisterBuilder<false, false, false, false> {
            LslRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl LslRegister {
        pub fn builder() -> LslRegisterBuilder<false, false, false, false> {
            LslRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl LslRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> LslRegister {
            LslRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct LslRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LslRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            LslRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                LslRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LslRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, LslRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                LslRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > LslRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LslRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LslRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > LslRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, LslRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LslRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl LslRegister {
        pub fn consumer(self) -> LslRegisterConsumer<false, false, false, false> {
            LslRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl LslRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LslRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LslRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LslRegister {
        #[inline]
        fn clone(&self) -> LslRegister {
            LslRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LslRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LslRegister {
        #[inline]
        fn eq(&self, other: &LslRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<LslRegister> for Operation {
        fn from(val: LslRegister) -> Operation {
            Operation::LslRegister(val)
        }
    }
    pub struct LsrImmediate {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub rm: Register,
        pub imm: u8,
    }
    pub struct LsrImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rm: Option<Register>,
        imm: Option<u8>,
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > LsrImmediateBuilder<false, rdSET, rmSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> LsrImmediateBuilder<true, rdSET, rmSET, immSET> {
            self.s = Some(s);
            LsrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > LsrImmediateBuilder<sSET, false, rmSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> LsrImmediateBuilder<sSET, true, rmSET, immSET> {
            self.rd = Some(rd);
            LsrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > LsrImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LsrImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rm = Some(rm);
            LsrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > LsrImmediateBuilder<sSET, rdSET, rmSET, false> {
        pub fn set_imm(
            mut self,
            imm: u8,
        ) -> LsrImmediateBuilder<sSET, rdSET, rmSET, true> {
            self.imm = Some(imm);
            LsrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl LsrImmediateBuilder<false, false, false, false> {
        pub fn new() -> LsrImmediateBuilder<false, false, false, false> {
            LsrImmediateBuilder {
                s: None,
                rd: None,
                rm: None,
                imm: None,
            }
        }
    }
    impl LsrImmediate {
        pub fn builder() -> LsrImmediateBuilder<false, false, false, false> {
            LsrImmediateBuilder {
                s: None,
                rd: None,
                rm: None,
                imm: None,
            }
        }
    }
    impl LsrImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> LsrImmediate {
            LsrImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct LsrImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rm: Option<Register>,
        imm: Option<u8>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const immCONSUMED: bool,
    > LsrImmediateConsumer<false, rdCONSUMED, rmCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            LsrImmediateConsumer<true, rdCONSUMED, rmCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                LsrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
        const immCONSUMED: bool,
    > LsrImmediateConsumer<sCONSUMED, false, rmCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, LsrImmediateConsumer<sCONSUMED, true, rmCONSUMED, immCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                LsrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > LsrImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, LsrImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LsrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > LsrImmediateConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u8, LsrImmediateConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                LsrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl LsrImmediate {
        pub fn consumer(self) -> LsrImmediateConsumer<false, false, false, false> {
            LsrImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
                imm: Some(self.imm),
            }
        }
    }
    impl LsrImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LsrImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LsrImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LsrImmediate {
        #[inline]
        fn clone(&self) -> LsrImmediate {
            LsrImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LsrImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LsrImmediate {
        #[inline]
        fn eq(&self, other: &LsrImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
                && self.imm == other.imm
        }
    }
    impl From<LsrImmediate> for Operation {
        fn from(val: LsrImmediate) -> Operation {
            Operation::LsrImmediate(val)
        }
    }
    pub struct LsrRegister {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct LsrRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LsrRegisterBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> LsrRegisterBuilder<true, rdSET, rnSET, rmSET> {
            self.s = Some(s);
            LsrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > LsrRegisterBuilder<sSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> LsrRegisterBuilder<sSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            LsrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > LsrRegisterBuilder<sSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> LsrRegisterBuilder<sSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            LsrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > LsrRegisterBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> LsrRegisterBuilder<sSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            LsrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl LsrRegisterBuilder<false, false, false, false> {
        pub fn new() -> LsrRegisterBuilder<false, false, false, false> {
            LsrRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl LsrRegister {
        pub fn builder() -> LsrRegisterBuilder<false, false, false, false> {
            LsrRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl LsrRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> LsrRegister {
            LsrRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct LsrRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LsrRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            LsrRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                LsrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > LsrRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, LsrRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                LsrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > LsrRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, LsrRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                LsrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > LsrRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, LsrRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                LsrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl LsrRegister {
        pub fn consumer(self) -> LsrRegisterConsumer<false, false, false, false> {
            LsrRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl LsrRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LsrRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LsrRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LsrRegister {
        #[inline]
        fn clone(&self) -> LsrRegister {
            LsrRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LsrRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LsrRegister {
        #[inline]
        fn eq(&self, other: &LsrRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<LsrRegister> for Operation {
        fn from(val: LsrRegister) -> Operation {
            Operation::LsrRegister(val)
        }
    }
    pub struct Mcrr {
        pub coproc: CoProcessor,
        pub opc1: u8,
        pub rt: Register,
        pub rt2: Register,
        pub crm: u8,
    }
    pub struct McrrBuilder<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        rt: Option<Register>,
        rt2: Option<Register>,
        crm: Option<u8>,
    }
    impl<
        const opc1SET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > McrrBuilder<false, opc1SET, rtSET, rt2SET, crmSET> {
        pub fn set_coproc(
            mut self,
            coproc: CoProcessor,
        ) -> McrrBuilder<true, opc1SET, rtSET, rt2SET, crmSET> {
            self.coproc = Some(coproc);
            McrrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > McrrBuilder<coprocSET, false, rtSET, rt2SET, crmSET> {
        pub fn set_opc1(
            mut self,
            opc1: u8,
        ) -> McrrBuilder<coprocSET, true, rtSET, rt2SET, crmSET> {
            self.opc1 = Some(opc1);
            McrrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > McrrBuilder<coprocSET, opc1SET, false, rt2SET, crmSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> McrrBuilder<coprocSET, opc1SET, true, rt2SET, crmSET> {
            self.rt = Some(rt);
            McrrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const crmSET: bool,
    > McrrBuilder<coprocSET, opc1SET, rtSET, false, crmSET> {
        pub fn set_rt2(
            mut self,
            rt2: Register,
        ) -> McrrBuilder<coprocSET, opc1SET, rtSET, true, crmSET> {
            self.rt2 = Some(rt2);
            McrrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const rt2SET: bool,
    > McrrBuilder<coprocSET, opc1SET, rtSET, rt2SET, false> {
        pub fn set_crm(
            mut self,
            crm: u8,
        ) -> McrrBuilder<coprocSET, opc1SET, rtSET, rt2SET, true> {
            self.crm = Some(crm);
            McrrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl McrrBuilder<false, false, false, false, false> {
        pub fn new() -> McrrBuilder<false, false, false, false, false> {
            McrrBuilder {
                coproc: None,
                opc1: None,
                rt: None,
                rt2: None,
                crm: None,
            }
        }
    }
    impl Mcrr {
        pub fn builder() -> McrrBuilder<false, false, false, false, false> {
            McrrBuilder {
                coproc: None,
                opc1: None,
                rt: None,
                rt2: None,
                crm: None,
            }
        }
    }
    impl McrrBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Mcrr {
            Mcrr {
                coproc: self.coproc.unwrap(),
                opc1: self.opc1.unwrap(),
                rt: self.rt.unwrap(),
                rt2: self.rt2.unwrap(),
                crm: self.crm.unwrap(),
            }
        }
    }
    pub struct McrrConsumer<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        rt: Option<Register>,
        rt2: Option<Register>,
        crm: Option<u8>,
    }
    impl<
        const opc1CONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const crmCONSUMED: bool,
    > McrrConsumer<false, opc1CONSUMED, rtCONSUMED, rt2CONSUMED, crmCONSUMED> {
        pub fn consume_coproc(
            mut self,
        ) -> (
            CoProcessor,
            McrrConsumer<true, opc1CONSUMED, rtCONSUMED, rt2CONSUMED, crmCONSUMED>,
        ) {
            let ret = self.coproc.unwrap();
            self.coproc = None;
            (
                ret,
                McrrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const crmCONSUMED: bool,
    > McrrConsumer<coprocCONSUMED, false, rtCONSUMED, rt2CONSUMED, crmCONSUMED> {
        pub fn consume_opc1(
            mut self,
        ) -> (
            u8,
            McrrConsumer<coprocCONSUMED, true, rtCONSUMED, rt2CONSUMED, crmCONSUMED>,
        ) {
            let ret = self.opc1.unwrap();
            self.opc1 = None;
            (
                ret,
                McrrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const rt2CONSUMED: bool,
        const crmCONSUMED: bool,
    > McrrConsumer<coprocCONSUMED, opc1CONSUMED, false, rt2CONSUMED, crmCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            McrrConsumer<coprocCONSUMED, opc1CONSUMED, true, rt2CONSUMED, crmCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                McrrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
    > McrrConsumer<coprocCONSUMED, opc1CONSUMED, rtCONSUMED, false, crmCONSUMED> {
        pub fn consume_rt2(
            mut self,
        ) -> (
            Register,
            McrrConsumer<coprocCONSUMED, opc1CONSUMED, rtCONSUMED, true, crmCONSUMED>,
        ) {
            let ret = self.rt2.unwrap();
            self.rt2 = None;
            (
                ret,
                McrrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
    > McrrConsumer<coprocCONSUMED, opc1CONSUMED, rtCONSUMED, rt2CONSUMED, false> {
        pub fn consume_crm(
            mut self,
        ) -> (
            u8,
            McrrConsumer<coprocCONSUMED, opc1CONSUMED, rtCONSUMED, rt2CONSUMED, true>,
        ) {
            let ret = self.crm.unwrap();
            self.crm = None;
            (
                ret,
                McrrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl Mcrr {
        pub fn consumer(self) -> McrrConsumer<false, false, false, false, false> {
            McrrConsumer {
                coproc: Some(self.coproc),
                opc1: Some(self.opc1),
                rt: Some(self.rt),
                rt2: Some(self.rt2),
                crm: Some(self.crm),
            }
        }
    }
    impl McrrConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mcrr {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Mcrr",
                "coproc",
                &self.coproc,
                "opc1",
                &self.opc1,
                "rt",
                &self.rt,
                "rt2",
                &self.rt2,
                "crm",
                &&self.crm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mcrr {
        #[inline]
        fn clone(&self) -> Mcrr {
            Mcrr {
                coproc: ::core::clone::Clone::clone(&self.coproc),
                opc1: ::core::clone::Clone::clone(&self.opc1),
                rt: ::core::clone::Clone::clone(&self.rt),
                rt2: ::core::clone::Clone::clone(&self.rt2),
                crm: ::core::clone::Clone::clone(&self.crm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mcrr {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mcrr {
        #[inline]
        fn eq(&self, other: &Mcrr) -> bool {
            self.coproc == other.coproc && self.opc1 == other.opc1 && self.rt == other.rt
                && self.rt2 == other.rt2 && self.crm == other.crm
        }
    }
    impl From<Mcrr> for Operation {
        fn from(val: Mcrr) -> Operation {
            Operation::Mcrr(val)
        }
    }
    pub struct Mcr {
        pub coproc: CoProcessor,
        pub opc1: u8,
        pub opc2: Option<u8>,
        pub rt: Register,
        pub crm: u8,
        pub crn: u8,
    }
    pub struct McrBuilder<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        opc2: Option<Option<u8>>,
        rt: Option<Register>,
        crm: Option<u8>,
        crn: Option<u8>,
    }
    impl<
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > McrBuilder<false, opc1SET, opc2SET, rtSET, crmSET, crnSET> {
        pub fn set_coproc(
            mut self,
            coproc: CoProcessor,
        ) -> McrBuilder<true, opc1SET, opc2SET, rtSET, crmSET, crnSET> {
            self.coproc = Some(coproc);
            McrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > McrBuilder<coprocSET, false, opc2SET, rtSET, crmSET, crnSET> {
        pub fn set_opc1(
            mut self,
            opc1: u8,
        ) -> McrBuilder<coprocSET, true, opc2SET, rtSET, crmSET, crnSET> {
            self.opc1 = Some(opc1);
            McrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > McrBuilder<coprocSET, opc1SET, false, rtSET, crmSET, crnSET> {
        pub fn set_opc2(
            mut self,
            opc2: Option<u8>,
        ) -> McrBuilder<coprocSET, opc1SET, true, rtSET, crmSET, crnSET> {
            self.opc2 = Some(opc2);
            McrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > McrBuilder<coprocSET, opc1SET, opc2SET, false, crmSET, crnSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> McrBuilder<coprocSET, opc1SET, opc2SET, true, crmSET, crnSET> {
            self.rt = Some(rt);
            McrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crnSET: bool,
    > McrBuilder<coprocSET, opc1SET, opc2SET, rtSET, false, crnSET> {
        pub fn set_crm(
            mut self,
            crm: u8,
        ) -> McrBuilder<coprocSET, opc1SET, opc2SET, rtSET, true, crnSET> {
            self.crm = Some(crm);
            McrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
    > McrBuilder<coprocSET, opc1SET, opc2SET, rtSET, crmSET, false> {
        pub fn set_crn(
            mut self,
            crn: u8,
        ) -> McrBuilder<coprocSET, opc1SET, opc2SET, rtSET, crmSET, true> {
            self.crn = Some(crn);
            McrBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl McrBuilder<false, false, false, false, false, false> {
        pub fn new() -> McrBuilder<false, false, false, false, false, false> {
            McrBuilder {
                coproc: None,
                opc1: None,
                opc2: None,
                rt: None,
                crm: None,
                crn: None,
            }
        }
    }
    impl Mcr {
        pub fn builder() -> McrBuilder<false, false, false, false, false, false> {
            McrBuilder {
                coproc: None,
                opc1: None,
                opc2: None,
                rt: None,
                crm: None,
                crn: None,
            }
        }
    }
    impl McrBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> Mcr {
            Mcr {
                coproc: self.coproc.unwrap(),
                opc1: self.opc1.unwrap(),
                opc2: self.opc2.unwrap(),
                rt: self.rt.unwrap(),
                crm: self.crm.unwrap(),
                crn: self.crn.unwrap(),
            }
        }
    }
    pub struct McrConsumer<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        opc2: Option<Option<u8>>,
        rt: Option<Register>,
        crm: Option<u8>,
        crn: Option<u8>,
    }
    impl<
        const opc1CONSUMED: bool,
        const opc2CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
        const crnCONSUMED: bool,
    > McrConsumer<
        false,
        opc1CONSUMED,
        opc2CONSUMED,
        rtCONSUMED,
        crmCONSUMED,
        crnCONSUMED,
    > {
        pub fn consume_coproc(
            mut self,
        ) -> (
            CoProcessor,
            McrConsumer<
                true,
                opc1CONSUMED,
                opc2CONSUMED,
                rtCONSUMED,
                crmCONSUMED,
                crnCONSUMED,
            >,
        ) {
            let ret = self.coproc.unwrap();
            self.coproc = None;
            (
                ret,
                McrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc2CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
        const crnCONSUMED: bool,
    > McrConsumer<
        coprocCONSUMED,
        false,
        opc2CONSUMED,
        rtCONSUMED,
        crmCONSUMED,
        crnCONSUMED,
    > {
        pub fn consume_opc1(
            mut self,
        ) -> (
            u8,
            McrConsumer<
                coprocCONSUMED,
                true,
                opc2CONSUMED,
                rtCONSUMED,
                crmCONSUMED,
                crnCONSUMED,
            >,
        ) {
            let ret = self.opc1.unwrap();
            self.opc1 = None;
            (
                ret,
                McrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
        const crnCONSUMED: bool,
    > McrConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        false,
        rtCONSUMED,
        crmCONSUMED,
        crnCONSUMED,
    > {
        pub fn consume_opc2(
            mut self,
        ) -> (
            Option<u8>,
            McrConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                true,
                rtCONSUMED,
                crmCONSUMED,
                crnCONSUMED,
            >,
        ) {
            let ret = self.opc2.unwrap();
            self.opc2 = None;
            (
                ret,
                McrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const opc2CONSUMED: bool,
        const crmCONSUMED: bool,
        const crnCONSUMED: bool,
    > McrConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        opc2CONSUMED,
        false,
        crmCONSUMED,
        crnCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            McrConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                opc2CONSUMED,
                true,
                crmCONSUMED,
                crnCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                McrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const opc2CONSUMED: bool,
        const rtCONSUMED: bool,
        const crnCONSUMED: bool,
    > McrConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        opc2CONSUMED,
        rtCONSUMED,
        false,
        crnCONSUMED,
    > {
        pub fn consume_crm(
            mut self,
        ) -> (
            u8,
            McrConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                opc2CONSUMED,
                rtCONSUMED,
                true,
                crnCONSUMED,
            >,
        ) {
            let ret = self.crm.unwrap();
            self.crm = None;
            (
                ret,
                McrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const opc2CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
    > McrConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        opc2CONSUMED,
        rtCONSUMED,
        crmCONSUMED,
        false,
    > {
        pub fn consume_crn(
            mut self,
        ) -> (
            u8,
            McrConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                opc2CONSUMED,
                rtCONSUMED,
                crmCONSUMED,
                true,
            >,
        ) {
            let ret = self.crn.unwrap();
            self.crn = None;
            (
                ret,
                McrConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl Mcr {
        pub fn consumer(self) -> McrConsumer<false, false, false, false, false, false> {
            McrConsumer {
                coproc: Some(self.coproc),
                opc1: Some(self.opc1),
                opc2: Some(self.opc2),
                rt: Some(self.rt),
                crm: Some(self.crm),
                crn: Some(self.crn),
            }
        }
    }
    impl McrConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mcr {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["coproc", "opc1", "opc2", "rt", "crm", "crn"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.coproc,
                &self.opc1,
                &self.opc2,
                &self.rt,
                &self.crm,
                &&self.crn,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Mcr", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mcr {
        #[inline]
        fn clone(&self) -> Mcr {
            Mcr {
                coproc: ::core::clone::Clone::clone(&self.coproc),
                opc1: ::core::clone::Clone::clone(&self.opc1),
                opc2: ::core::clone::Clone::clone(&self.opc2),
                rt: ::core::clone::Clone::clone(&self.rt),
                crm: ::core::clone::Clone::clone(&self.crm),
                crn: ::core::clone::Clone::clone(&self.crn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mcr {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mcr {
        #[inline]
        fn eq(&self, other: &Mcr) -> bool {
            self.coproc == other.coproc && self.opc1 == other.opc1
                && self.opc2 == other.opc2 && self.rt == other.rt
                && self.crm == other.crm && self.crn == other.crn
        }
    }
    impl From<Mcr> for Operation {
        fn from(val: Mcr) -> Operation {
            Operation::Mcr(val)
        }
    }
    pub struct Mla {
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct MlaBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > MlaBuilder<false, rnSET, rmSET, raSET> {
        pub fn set_rd(mut self, rd: Register) -> MlaBuilder<true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            MlaBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > MlaBuilder<rdSET, false, rmSET, raSET> {
        pub fn set_rn(mut self, rn: Register) -> MlaBuilder<rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            MlaBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > MlaBuilder<rdSET, rnSET, false, raSET> {
        pub fn set_rm(mut self, rm: Register) -> MlaBuilder<rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            MlaBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > MlaBuilder<rdSET, rnSET, rmSET, false> {
        pub fn set_ra(mut self, ra: Register) -> MlaBuilder<rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            MlaBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl MlaBuilder<false, false, false, false> {
        pub fn new() -> MlaBuilder<false, false, false, false> {
            MlaBuilder {
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Mla {
        pub fn builder() -> MlaBuilder<false, false, false, false> {
            MlaBuilder {
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl MlaBuilder<true, true, true, true> {
        pub fn complete(self) -> Mla {
            Mla {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct MlaConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > MlaConsumer<false, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, MlaConsumer<true, rnCONSUMED, rmCONSUMED, raCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MlaConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > MlaConsumer<rdCONSUMED, false, rmCONSUMED, raCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, MlaConsumer<rdCONSUMED, true, rmCONSUMED, raCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                MlaConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > MlaConsumer<rdCONSUMED, rnCONSUMED, false, raCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, MlaConsumer<rdCONSUMED, rnCONSUMED, true, raCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                MlaConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > MlaConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_ra(
            mut self,
        ) -> (Register, MlaConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                MlaConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Mla {
        pub fn consumer(self) -> MlaConsumer<false, false, false, false> {
            MlaConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl MlaConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mla {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Mla",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "ra",
                &&self.ra,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mla {
        #[inline]
        fn clone(&self) -> Mla {
            Mla {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mla {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mla {
        #[inline]
        fn eq(&self, other: &Mla) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.ra == other.ra
        }
    }
    impl From<Mla> for Operation {
        fn from(val: Mla) -> Operation {
            Operation::Mla(val)
        }
    }
    pub struct Mls {
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct MlsBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > MlsBuilder<false, rnSET, rmSET, raSET> {
        pub fn set_rd(mut self, rd: Register) -> MlsBuilder<true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            MlsBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > MlsBuilder<rdSET, false, rmSET, raSET> {
        pub fn set_rn(mut self, rn: Register) -> MlsBuilder<rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            MlsBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > MlsBuilder<rdSET, rnSET, false, raSET> {
        pub fn set_rm(mut self, rm: Register) -> MlsBuilder<rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            MlsBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > MlsBuilder<rdSET, rnSET, rmSET, false> {
        pub fn set_ra(mut self, ra: Register) -> MlsBuilder<rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            MlsBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl MlsBuilder<false, false, false, false> {
        pub fn new() -> MlsBuilder<false, false, false, false> {
            MlsBuilder {
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Mls {
        pub fn builder() -> MlsBuilder<false, false, false, false> {
            MlsBuilder {
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl MlsBuilder<true, true, true, true> {
        pub fn complete(self) -> Mls {
            Mls {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct MlsConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > MlsConsumer<false, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, MlsConsumer<true, rnCONSUMED, rmCONSUMED, raCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MlsConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > MlsConsumer<rdCONSUMED, false, rmCONSUMED, raCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, MlsConsumer<rdCONSUMED, true, rmCONSUMED, raCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                MlsConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > MlsConsumer<rdCONSUMED, rnCONSUMED, false, raCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, MlsConsumer<rdCONSUMED, rnCONSUMED, true, raCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                MlsConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > MlsConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_ra(
            mut self,
        ) -> (Register, MlsConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                MlsConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Mls {
        pub fn consumer(self) -> MlsConsumer<false, false, false, false> {
            MlsConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl MlsConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mls {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Mls",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "ra",
                &&self.ra,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mls {
        #[inline]
        fn clone(&self) -> Mls {
            Mls {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mls {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mls {
        #[inline]
        fn eq(&self, other: &Mls) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.ra == other.ra
        }
    }
    impl From<Mls> for Operation {
        fn from(val: Mls) -> Operation {
            Operation::Mls(val)
        }
    }
    pub struct MovImmediate {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub imm: u32,
        pub carry: Option<bool>,
    }
    pub struct MovImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        imm: Option<u32>,
        carry: Option<Option<bool>>,
    }
    impl<
        const rdSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > MovImmediateBuilder<false, rdSET, immSET, carrySET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> MovImmediateBuilder<true, rdSET, immSET, carrySET> {
            self.s = Some(s);
            MovImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > MovImmediateBuilder<sSET, false, immSET, carrySET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> MovImmediateBuilder<sSET, true, immSET, carrySET> {
            self.rd = Some(rd);
            MovImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const carrySET: bool,
    > MovImmediateBuilder<sSET, rdSET, false, carrySET> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> MovImmediateBuilder<sSET, rdSET, true, carrySET> {
            self.imm = Some(imm);
            MovImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > MovImmediateBuilder<sSET, rdSET, immSET, false> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> MovImmediateBuilder<sSET, rdSET, immSET, true> {
            self.carry = Some(carry);
            MovImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
                carry: self.carry,
            }
        }
    }
    impl MovImmediateBuilder<false, false, false, false> {
        pub fn new() -> MovImmediateBuilder<false, false, false, false> {
            MovImmediateBuilder {
                s: None,
                rd: None,
                imm: None,
                carry: None,
            }
        }
    }
    impl MovImmediate {
        pub fn builder() -> MovImmediateBuilder<false, false, false, false> {
            MovImmediateBuilder {
                s: None,
                rd: None,
                imm: None,
                carry: None,
            }
        }
    }
    impl MovImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> MovImmediate {
            MovImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                imm: self.imm.unwrap(),
                carry: self.carry.unwrap(),
            }
        }
    }
    pub struct MovImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
        const carrySET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        imm: Option<u32>,
        carry: Option<Option<bool>>,
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > MovImmediateConsumer<false, rdCONSUMED, immCONSUMED, carryCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            MovImmediateConsumer<true, rdCONSUMED, immCONSUMED, carryCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                MovImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const immCONSUMED: bool,
        const carryCONSUMED: bool,
    > MovImmediateConsumer<sCONSUMED, false, immCONSUMED, carryCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            MovImmediateConsumer<sCONSUMED, true, immCONSUMED, carryCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MovImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const carryCONSUMED: bool,
    > MovImmediateConsumer<sCONSUMED, rdCONSUMED, false, carryCONSUMED> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, MovImmediateConsumer<sCONSUMED, rdCONSUMED, true, carryCONSUMED>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                MovImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > MovImmediateConsumer<sCONSUMED, rdCONSUMED, immCONSUMED, false> {
        pub fn consume_carry(
            mut self,
        ) -> (
            Option<bool>,
            MovImmediateConsumer<sCONSUMED, rdCONSUMED, immCONSUMED, true>,
        ) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                MovImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                    carry: self.carry,
                },
            )
        }
    }
    impl MovImmediate {
        pub fn consumer(self) -> MovImmediateConsumer<false, false, false, false> {
            MovImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                imm: Some(self.imm),
                carry: Some(self.carry),
            }
        }
    }
    impl MovImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MovImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "MovImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "imm",
                &self.imm,
                "carry",
                &&self.carry,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MovImmediate {
        #[inline]
        fn clone(&self) -> MovImmediate {
            MovImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                imm: ::core::clone::Clone::clone(&self.imm),
                carry: ::core::clone::Clone::clone(&self.carry),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MovImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MovImmediate {
        #[inline]
        fn eq(&self, other: &MovImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.imm == other.imm
                && self.carry == other.carry
        }
    }
    impl From<MovImmediate> for Operation {
        fn from(val: MovImmediate) -> Operation {
            Operation::MovImmediate(val)
        }
    }
    pub struct MovRegister {
        pub s: Option<bool>,
        pub rd: Register,
        pub rm: Register,
    }
    pub struct MovRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rdSET: bool, const rmSET: bool> MovRegisterBuilder<false, rdSET, rmSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> MovRegisterBuilder<true, rdSET, rmSET> {
            self.s = Some(s);
            MovRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl<const sSET: bool, const rmSET: bool> MovRegisterBuilder<sSET, false, rmSET> {
        pub fn set_rd(mut self, rd: Register) -> MovRegisterBuilder<sSET, true, rmSET> {
            self.rd = Some(rd);
            MovRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl<const sSET: bool, const rdSET: bool> MovRegisterBuilder<sSET, rdSET, false> {
        pub fn set_rm(mut self, rm: Register) -> MovRegisterBuilder<sSET, rdSET, true> {
            self.rm = Some(rm);
            MovRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl MovRegisterBuilder<false, false, false> {
        pub fn new() -> MovRegisterBuilder<false, false, false> {
            MovRegisterBuilder {
                s: None,
                rd: None,
                rm: None,
            }
        }
    }
    impl MovRegister {
        pub fn builder() -> MovRegisterBuilder<false, false, false> {
            MovRegisterBuilder {
                s: None,
                rd: None,
                rm: None,
            }
        }
    }
    impl MovRegisterBuilder<true, true, true> {
        pub fn complete(self) -> MovRegister {
            MovRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct MovRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > MovRegisterConsumer<false, rdCONSUMED, rmCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (Option<bool>, MovRegisterConsumer<true, rdCONSUMED, rmCONSUMED>) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                MovRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
    > MovRegisterConsumer<sCONSUMED, false, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, MovRegisterConsumer<sCONSUMED, true, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MovRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
    > MovRegisterConsumer<sCONSUMED, rdCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, MovRegisterConsumer<sCONSUMED, rdCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                MovRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl MovRegister {
        pub fn consumer(self) -> MovRegisterConsumer<false, false, false> {
            MovRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
            }
        }
    }
    impl MovRegisterConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MovRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "MovRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MovRegister {
        #[inline]
        fn clone(&self) -> MovRegister {
            MovRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MovRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MovRegister {
        #[inline]
        fn eq(&self, other: &MovRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
        }
    }
    impl From<MovRegister> for Operation {
        fn from(val: MovRegister) -> Operation {
            Operation::MovRegister(val)
        }
    }
    pub struct Movt {
        pub rd: Register,
        pub imm: u16,
    }
    pub struct MovtBuilder<const rdSET: bool, const immSET: bool> {
        rd: Option<Register>,
        imm: Option<u16>,
    }
    impl<const immSET: bool> MovtBuilder<false, immSET> {
        pub fn set_rd(mut self, rd: Register) -> MovtBuilder<true, immSET> {
            self.rd = Some(rd);
            MovtBuilder {
                rd: self.rd,
                imm: self.imm,
            }
        }
    }
    impl<const rdSET: bool> MovtBuilder<rdSET, false> {
        pub fn set_imm(mut self, imm: u16) -> MovtBuilder<rdSET, true> {
            self.imm = Some(imm);
            MovtBuilder {
                rd: self.rd,
                imm: self.imm,
            }
        }
    }
    impl MovtBuilder<false, false> {
        pub fn new() -> MovtBuilder<false, false> {
            MovtBuilder { rd: None, imm: None }
        }
    }
    impl Movt {
        pub fn builder() -> MovtBuilder<false, false> {
            MovtBuilder { rd: None, imm: None }
        }
    }
    impl MovtBuilder<true, true> {
        pub fn complete(self) -> Movt {
            Movt {
                rd: self.rd.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct MovtConsumer<const rdSET: bool, const immSET: bool> {
        rd: Option<Register>,
        imm: Option<u16>,
    }
    impl<const immCONSUMED: bool> MovtConsumer<false, immCONSUMED> {
        pub fn consume_rd(mut self) -> (Register, MovtConsumer<true, immCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MovtConsumer {
                    rd: self.rd,
                    imm: self.imm,
                },
            )
        }
    }
    impl<const rdCONSUMED: bool> MovtConsumer<rdCONSUMED, false> {
        pub fn consume_imm(mut self) -> (u16, MovtConsumer<rdCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                MovtConsumer {
                    rd: self.rd,
                    imm: self.imm,
                },
            )
        }
    }
    impl Movt {
        pub fn consumer(self) -> MovtConsumer<false, false> {
            MovtConsumer {
                rd: Some(self.rd),
                imm: Some(self.imm),
            }
        }
    }
    impl MovtConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Movt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Movt",
                "rd",
                &self.rd,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Movt {
        #[inline]
        fn clone(&self) -> Movt {
            Movt {
                rd: ::core::clone::Clone::clone(&self.rd),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Movt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Movt {
        #[inline]
        fn eq(&self, other: &Movt) -> bool {
            self.rd == other.rd && self.imm == other.imm
        }
    }
    impl From<Movt> for Operation {
        fn from(val: Movt) -> Operation {
            Operation::Movt(val)
        }
    }
    pub struct Mrrc {
        pub coproc: CoProcessor,
        pub opc1: u8,
        pub rt: Register,
        pub rt2: Register,
        pub crm: u8,
    }
    pub struct MrrcBuilder<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        rt: Option<Register>,
        rt2: Option<Register>,
        crm: Option<u8>,
    }
    impl<
        const opc1SET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > MrrcBuilder<false, opc1SET, rtSET, rt2SET, crmSET> {
        pub fn set_coproc(
            mut self,
            coproc: CoProcessor,
        ) -> MrrcBuilder<true, opc1SET, rtSET, rt2SET, crmSET> {
            self.coproc = Some(coproc);
            MrrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > MrrcBuilder<coprocSET, false, rtSET, rt2SET, crmSET> {
        pub fn set_opc1(
            mut self,
            opc1: u8,
        ) -> MrrcBuilder<coprocSET, true, rtSET, rt2SET, crmSET> {
            self.opc1 = Some(opc1);
            MrrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > MrrcBuilder<coprocSET, opc1SET, false, rt2SET, crmSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> MrrcBuilder<coprocSET, opc1SET, true, rt2SET, crmSET> {
            self.rt = Some(rt);
            MrrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const crmSET: bool,
    > MrrcBuilder<coprocSET, opc1SET, rtSET, false, crmSET> {
        pub fn set_rt2(
            mut self,
            rt2: Register,
        ) -> MrrcBuilder<coprocSET, opc1SET, rtSET, true, crmSET> {
            self.rt2 = Some(rt2);
            MrrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const rt2SET: bool,
    > MrrcBuilder<coprocSET, opc1SET, rtSET, rt2SET, false> {
        pub fn set_crm(
            mut self,
            crm: u8,
        ) -> MrrcBuilder<coprocSET, opc1SET, rtSET, rt2SET, true> {
            self.crm = Some(crm);
            MrrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                rt: self.rt,
                rt2: self.rt2,
                crm: self.crm,
            }
        }
    }
    impl MrrcBuilder<false, false, false, false, false> {
        pub fn new() -> MrrcBuilder<false, false, false, false, false> {
            MrrcBuilder {
                coproc: None,
                opc1: None,
                rt: None,
                rt2: None,
                crm: None,
            }
        }
    }
    impl Mrrc {
        pub fn builder() -> MrrcBuilder<false, false, false, false, false> {
            MrrcBuilder {
                coproc: None,
                opc1: None,
                rt: None,
                rt2: None,
                crm: None,
            }
        }
    }
    impl MrrcBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Mrrc {
            Mrrc {
                coproc: self.coproc.unwrap(),
                opc1: self.opc1.unwrap(),
                rt: self.rt.unwrap(),
                rt2: self.rt2.unwrap(),
                crm: self.crm.unwrap(),
            }
        }
    }
    pub struct MrrcConsumer<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const crmSET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        rt: Option<Register>,
        rt2: Option<Register>,
        crm: Option<u8>,
    }
    impl<
        const opc1CONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const crmCONSUMED: bool,
    > MrrcConsumer<false, opc1CONSUMED, rtCONSUMED, rt2CONSUMED, crmCONSUMED> {
        pub fn consume_coproc(
            mut self,
        ) -> (
            CoProcessor,
            MrrcConsumer<true, opc1CONSUMED, rtCONSUMED, rt2CONSUMED, crmCONSUMED>,
        ) {
            let ret = self.coproc.unwrap();
            self.coproc = None;
            (
                ret,
                MrrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const crmCONSUMED: bool,
    > MrrcConsumer<coprocCONSUMED, false, rtCONSUMED, rt2CONSUMED, crmCONSUMED> {
        pub fn consume_opc1(
            mut self,
        ) -> (
            u8,
            MrrcConsumer<coprocCONSUMED, true, rtCONSUMED, rt2CONSUMED, crmCONSUMED>,
        ) {
            let ret = self.opc1.unwrap();
            self.opc1 = None;
            (
                ret,
                MrrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const rt2CONSUMED: bool,
        const crmCONSUMED: bool,
    > MrrcConsumer<coprocCONSUMED, opc1CONSUMED, false, rt2CONSUMED, crmCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            MrrcConsumer<coprocCONSUMED, opc1CONSUMED, true, rt2CONSUMED, crmCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                MrrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
    > MrrcConsumer<coprocCONSUMED, opc1CONSUMED, rtCONSUMED, false, crmCONSUMED> {
        pub fn consume_rt2(
            mut self,
        ) -> (
            Register,
            MrrcConsumer<coprocCONSUMED, opc1CONSUMED, rtCONSUMED, true, crmCONSUMED>,
        ) {
            let ret = self.rt2.unwrap();
            self.rt2 = None;
            (
                ret,
                MrrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
    > MrrcConsumer<coprocCONSUMED, opc1CONSUMED, rtCONSUMED, rt2CONSUMED, false> {
        pub fn consume_crm(
            mut self,
        ) -> (
            u8,
            MrrcConsumer<coprocCONSUMED, opc1CONSUMED, rtCONSUMED, rt2CONSUMED, true>,
        ) {
            let ret = self.crm.unwrap();
            self.crm = None;
            (
                ret,
                MrrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    rt: self.rt,
                    rt2: self.rt2,
                    crm: self.crm,
                },
            )
        }
    }
    impl Mrrc {
        pub fn consumer(self) -> MrrcConsumer<false, false, false, false, false> {
            MrrcConsumer {
                coproc: Some(self.coproc),
                opc1: Some(self.opc1),
                rt: Some(self.rt),
                rt2: Some(self.rt2),
                crm: Some(self.crm),
            }
        }
    }
    impl MrrcConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mrrc {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Mrrc",
                "coproc",
                &self.coproc,
                "opc1",
                &self.opc1,
                "rt",
                &self.rt,
                "rt2",
                &self.rt2,
                "crm",
                &&self.crm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mrrc {
        #[inline]
        fn clone(&self) -> Mrrc {
            Mrrc {
                coproc: ::core::clone::Clone::clone(&self.coproc),
                opc1: ::core::clone::Clone::clone(&self.opc1),
                rt: ::core::clone::Clone::clone(&self.rt),
                rt2: ::core::clone::Clone::clone(&self.rt2),
                crm: ::core::clone::Clone::clone(&self.crm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mrrc {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mrrc {
        #[inline]
        fn eq(&self, other: &Mrrc) -> bool {
            self.coproc == other.coproc && self.opc1 == other.opc1 && self.rt == other.rt
                && self.rt2 == other.rt2 && self.crm == other.crm
        }
    }
    impl From<Mrrc> for Operation {
        fn from(val: Mrrc) -> Operation {
            Operation::Mrrc(val)
        }
    }
    pub struct Mrc {
        pub coproc: CoProcessor,
        pub opc1: u8,
        pub opc2: Option<u8>,
        pub rt: Register,
        pub crm: u8,
        pub crn: u8,
    }
    pub struct MrcBuilder<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        opc2: Option<Option<u8>>,
        rt: Option<Register>,
        crm: Option<u8>,
        crn: Option<u8>,
    }
    impl<
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > MrcBuilder<false, opc1SET, opc2SET, rtSET, crmSET, crnSET> {
        pub fn set_coproc(
            mut self,
            coproc: CoProcessor,
        ) -> MrcBuilder<true, opc1SET, opc2SET, rtSET, crmSET, crnSET> {
            self.coproc = Some(coproc);
            MrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > MrcBuilder<coprocSET, false, opc2SET, rtSET, crmSET, crnSET> {
        pub fn set_opc1(
            mut self,
            opc1: u8,
        ) -> MrcBuilder<coprocSET, true, opc2SET, rtSET, crmSET, crnSET> {
            self.opc1 = Some(opc1);
            MrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > MrcBuilder<coprocSET, opc1SET, false, rtSET, crmSET, crnSET> {
        pub fn set_opc2(
            mut self,
            opc2: Option<u8>,
        ) -> MrcBuilder<coprocSET, opc1SET, true, rtSET, crmSET, crnSET> {
            self.opc2 = Some(opc2);
            MrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > MrcBuilder<coprocSET, opc1SET, opc2SET, false, crmSET, crnSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> MrcBuilder<coprocSET, opc1SET, opc2SET, true, crmSET, crnSET> {
            self.rt = Some(rt);
            MrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crnSET: bool,
    > MrcBuilder<coprocSET, opc1SET, opc2SET, rtSET, false, crnSET> {
        pub fn set_crm(
            mut self,
            crm: u8,
        ) -> MrcBuilder<coprocSET, opc1SET, opc2SET, rtSET, true, crnSET> {
            self.crm = Some(crm);
            MrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
    > MrcBuilder<coprocSET, opc1SET, opc2SET, rtSET, crmSET, false> {
        pub fn set_crn(
            mut self,
            crn: u8,
        ) -> MrcBuilder<coprocSET, opc1SET, opc2SET, rtSET, crmSET, true> {
            self.crn = Some(crn);
            MrcBuilder {
                coproc: self.coproc,
                opc1: self.opc1,
                opc2: self.opc2,
                rt: self.rt,
                crm: self.crm,
                crn: self.crn,
            }
        }
    }
    impl MrcBuilder<false, false, false, false, false, false> {
        pub fn new() -> MrcBuilder<false, false, false, false, false, false> {
            MrcBuilder {
                coproc: None,
                opc1: None,
                opc2: None,
                rt: None,
                crm: None,
                crn: None,
            }
        }
    }
    impl Mrc {
        pub fn builder() -> MrcBuilder<false, false, false, false, false, false> {
            MrcBuilder {
                coproc: None,
                opc1: None,
                opc2: None,
                rt: None,
                crm: None,
                crn: None,
            }
        }
    }
    impl MrcBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> Mrc {
            Mrc {
                coproc: self.coproc.unwrap(),
                opc1: self.opc1.unwrap(),
                opc2: self.opc2.unwrap(),
                rt: self.rt.unwrap(),
                crm: self.crm.unwrap(),
                crn: self.crn.unwrap(),
            }
        }
    }
    pub struct MrcConsumer<
        const coprocSET: bool,
        const opc1SET: bool,
        const opc2SET: bool,
        const rtSET: bool,
        const crmSET: bool,
        const crnSET: bool,
    > {
        coproc: Option<CoProcessor>,
        opc1: Option<u8>,
        opc2: Option<Option<u8>>,
        rt: Option<Register>,
        crm: Option<u8>,
        crn: Option<u8>,
    }
    impl<
        const opc1CONSUMED: bool,
        const opc2CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
        const crnCONSUMED: bool,
    > MrcConsumer<
        false,
        opc1CONSUMED,
        opc2CONSUMED,
        rtCONSUMED,
        crmCONSUMED,
        crnCONSUMED,
    > {
        pub fn consume_coproc(
            mut self,
        ) -> (
            CoProcessor,
            MrcConsumer<
                true,
                opc1CONSUMED,
                opc2CONSUMED,
                rtCONSUMED,
                crmCONSUMED,
                crnCONSUMED,
            >,
        ) {
            let ret = self.coproc.unwrap();
            self.coproc = None;
            (
                ret,
                MrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc2CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
        const crnCONSUMED: bool,
    > MrcConsumer<
        coprocCONSUMED,
        false,
        opc2CONSUMED,
        rtCONSUMED,
        crmCONSUMED,
        crnCONSUMED,
    > {
        pub fn consume_opc1(
            mut self,
        ) -> (
            u8,
            MrcConsumer<
                coprocCONSUMED,
                true,
                opc2CONSUMED,
                rtCONSUMED,
                crmCONSUMED,
                crnCONSUMED,
            >,
        ) {
            let ret = self.opc1.unwrap();
            self.opc1 = None;
            (
                ret,
                MrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
        const crnCONSUMED: bool,
    > MrcConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        false,
        rtCONSUMED,
        crmCONSUMED,
        crnCONSUMED,
    > {
        pub fn consume_opc2(
            mut self,
        ) -> (
            Option<u8>,
            MrcConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                true,
                rtCONSUMED,
                crmCONSUMED,
                crnCONSUMED,
            >,
        ) {
            let ret = self.opc2.unwrap();
            self.opc2 = None;
            (
                ret,
                MrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const opc2CONSUMED: bool,
        const crmCONSUMED: bool,
        const crnCONSUMED: bool,
    > MrcConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        opc2CONSUMED,
        false,
        crmCONSUMED,
        crnCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            MrcConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                opc2CONSUMED,
                true,
                crmCONSUMED,
                crnCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                MrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const opc2CONSUMED: bool,
        const rtCONSUMED: bool,
        const crnCONSUMED: bool,
    > MrcConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        opc2CONSUMED,
        rtCONSUMED,
        false,
        crnCONSUMED,
    > {
        pub fn consume_crm(
            mut self,
        ) -> (
            u8,
            MrcConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                opc2CONSUMED,
                rtCONSUMED,
                true,
                crnCONSUMED,
            >,
        ) {
            let ret = self.crm.unwrap();
            self.crm = None;
            (
                ret,
                MrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const opc1CONSUMED: bool,
        const opc2CONSUMED: bool,
        const rtCONSUMED: bool,
        const crmCONSUMED: bool,
    > MrcConsumer<
        coprocCONSUMED,
        opc1CONSUMED,
        opc2CONSUMED,
        rtCONSUMED,
        crmCONSUMED,
        false,
    > {
        pub fn consume_crn(
            mut self,
        ) -> (
            u8,
            MrcConsumer<
                coprocCONSUMED,
                opc1CONSUMED,
                opc2CONSUMED,
                rtCONSUMED,
                crmCONSUMED,
                true,
            >,
        ) {
            let ret = self.crn.unwrap();
            self.crn = None;
            (
                ret,
                MrcConsumer {
                    coproc: self.coproc,
                    opc1: self.opc1,
                    opc2: self.opc2,
                    rt: self.rt,
                    crm: self.crm,
                    crn: self.crn,
                },
            )
        }
    }
    impl Mrc {
        pub fn consumer(self) -> MrcConsumer<false, false, false, false, false, false> {
            MrcConsumer {
                coproc: Some(self.coproc),
                opc1: Some(self.opc1),
                opc2: Some(self.opc2),
                rt: Some(self.rt),
                crm: Some(self.crm),
                crn: Some(self.crn),
            }
        }
    }
    impl MrcConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mrc {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["coproc", "opc1", "opc2", "rt", "crm", "crn"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.coproc,
                &self.opc1,
                &self.opc2,
                &self.rt,
                &self.crm,
                &&self.crn,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Mrc", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mrc {
        #[inline]
        fn clone(&self) -> Mrc {
            Mrc {
                coproc: ::core::clone::Clone::clone(&self.coproc),
                opc1: ::core::clone::Clone::clone(&self.opc1),
                opc2: ::core::clone::Clone::clone(&self.opc2),
                rt: ::core::clone::Clone::clone(&self.rt),
                crm: ::core::clone::Clone::clone(&self.crm),
                crn: ::core::clone::Clone::clone(&self.crn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mrc {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mrc {
        #[inline]
        fn eq(&self, other: &Mrc) -> bool {
            self.coproc == other.coproc && self.opc1 == other.opc1
                && self.opc2 == other.opc2 && self.rt == other.rt
                && self.crm == other.crm && self.crn == other.crn
        }
    }
    impl From<Mrc> for Operation {
        fn from(val: Mrc) -> Operation {
            Operation::Mrc(val)
        }
    }
    pub struct Mrs {
        pub rd: Register,
        pub sysm: u8,
    }
    pub struct MrsBuilder<const rdSET: bool, const sysmSET: bool> {
        rd: Option<Register>,
        sysm: Option<u8>,
    }
    impl<const sysmSET: bool> MrsBuilder<false, sysmSET> {
        pub fn set_rd(mut self, rd: Register) -> MrsBuilder<true, sysmSET> {
            self.rd = Some(rd);
            MrsBuilder {
                rd: self.rd,
                sysm: self.sysm,
            }
        }
    }
    impl<const rdSET: bool> MrsBuilder<rdSET, false> {
        pub fn set_sysm(mut self, sysm: u8) -> MrsBuilder<rdSET, true> {
            self.sysm = Some(sysm);
            MrsBuilder {
                rd: self.rd,
                sysm: self.sysm,
            }
        }
    }
    impl MrsBuilder<false, false> {
        pub fn new() -> MrsBuilder<false, false> {
            MrsBuilder { rd: None, sysm: None }
        }
    }
    impl Mrs {
        pub fn builder() -> MrsBuilder<false, false> {
            MrsBuilder { rd: None, sysm: None }
        }
    }
    impl MrsBuilder<true, true> {
        pub fn complete(self) -> Mrs {
            Mrs {
                rd: self.rd.unwrap(),
                sysm: self.sysm.unwrap(),
            }
        }
    }
    pub struct MrsConsumer<const rdSET: bool, const sysmSET: bool> {
        rd: Option<Register>,
        sysm: Option<u8>,
    }
    impl<const sysmCONSUMED: bool> MrsConsumer<false, sysmCONSUMED> {
        pub fn consume_rd(mut self) -> (Register, MrsConsumer<true, sysmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MrsConsumer {
                    rd: self.rd,
                    sysm: self.sysm,
                },
            )
        }
    }
    impl<const rdCONSUMED: bool> MrsConsumer<rdCONSUMED, false> {
        pub fn consume_sysm(mut self) -> (u8, MrsConsumer<rdCONSUMED, true>) {
            let ret = self.sysm.unwrap();
            self.sysm = None;
            (
                ret,
                MrsConsumer {
                    rd: self.rd,
                    sysm: self.sysm,
                },
            )
        }
    }
    impl Mrs {
        pub fn consumer(self) -> MrsConsumer<false, false> {
            MrsConsumer {
                rd: Some(self.rd),
                sysm: Some(self.sysm),
            }
        }
    }
    impl MrsConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mrs {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Mrs",
                "rd",
                &self.rd,
                "sysm",
                &&self.sysm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mrs {
        #[inline]
        fn clone(&self) -> Mrs {
            Mrs {
                rd: ::core::clone::Clone::clone(&self.rd),
                sysm: ::core::clone::Clone::clone(&self.sysm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mrs {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mrs {
        #[inline]
        fn eq(&self, other: &Mrs) -> bool {
            self.rd == other.rd && self.sysm == other.sysm
        }
    }
    impl From<Mrs> for Operation {
        fn from(val: Mrs) -> Operation {
            Operation::Mrs(val)
        }
    }
    pub struct Msr {
        pub rn: Register,
        pub mask: Imm2,
        pub sysm: u8,
    }
    pub struct MsrBuilder<const rnSET: bool, const maskSET: bool, const sysmSET: bool> {
        rn: Option<Register>,
        mask: Option<Imm2>,
        sysm: Option<u8>,
    }
    impl<const maskSET: bool, const sysmSET: bool> MsrBuilder<false, maskSET, sysmSET> {
        pub fn set_rn(mut self, rn: Register) -> MsrBuilder<true, maskSET, sysmSET> {
            self.rn = Some(rn);
            MsrBuilder {
                rn: self.rn,
                mask: self.mask,
                sysm: self.sysm,
            }
        }
    }
    impl<const rnSET: bool, const sysmSET: bool> MsrBuilder<rnSET, false, sysmSET> {
        pub fn set_mask(mut self, mask: Imm2) -> MsrBuilder<rnSET, true, sysmSET> {
            self.mask = Some(mask);
            MsrBuilder {
                rn: self.rn,
                mask: self.mask,
                sysm: self.sysm,
            }
        }
    }
    impl<const rnSET: bool, const maskSET: bool> MsrBuilder<rnSET, maskSET, false> {
        pub fn set_sysm(mut self, sysm: u8) -> MsrBuilder<rnSET, maskSET, true> {
            self.sysm = Some(sysm);
            MsrBuilder {
                rn: self.rn,
                mask: self.mask,
                sysm: self.sysm,
            }
        }
    }
    impl MsrBuilder<false, false, false> {
        pub fn new() -> MsrBuilder<false, false, false> {
            MsrBuilder {
                rn: None,
                mask: None,
                sysm: None,
            }
        }
    }
    impl Msr {
        pub fn builder() -> MsrBuilder<false, false, false> {
            MsrBuilder {
                rn: None,
                mask: None,
                sysm: None,
            }
        }
    }
    impl MsrBuilder<true, true, true> {
        pub fn complete(self) -> Msr {
            Msr {
                rn: self.rn.unwrap(),
                mask: self.mask.unwrap(),
                sysm: self.sysm.unwrap(),
            }
        }
    }
    pub struct MsrConsumer<const rnSET: bool, const maskSET: bool, const sysmSET: bool> {
        rn: Option<Register>,
        mask: Option<Imm2>,
        sysm: Option<u8>,
    }
    impl<
        const maskCONSUMED: bool,
        const sysmCONSUMED: bool,
    > MsrConsumer<false, maskCONSUMED, sysmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, MsrConsumer<true, maskCONSUMED, sysmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                MsrConsumer {
                    rn: self.rn,
                    mask: self.mask,
                    sysm: self.sysm,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const sysmCONSUMED: bool,
    > MsrConsumer<rnCONSUMED, false, sysmCONSUMED> {
        pub fn consume_mask(
            mut self,
        ) -> (Imm2, MsrConsumer<rnCONSUMED, true, sysmCONSUMED>) {
            let ret = self.mask.unwrap();
            self.mask = None;
            (
                ret,
                MsrConsumer {
                    rn: self.rn,
                    mask: self.mask,
                    sysm: self.sysm,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const maskCONSUMED: bool,
    > MsrConsumer<rnCONSUMED, maskCONSUMED, false> {
        pub fn consume_sysm(
            mut self,
        ) -> (u8, MsrConsumer<rnCONSUMED, maskCONSUMED, true>) {
            let ret = self.sysm.unwrap();
            self.sysm = None;
            (
                ret,
                MsrConsumer {
                    rn: self.rn,
                    mask: self.mask,
                    sysm: self.sysm,
                },
            )
        }
    }
    impl Msr {
        pub fn consumer(self) -> MsrConsumer<false, false, false> {
            MsrConsumer {
                rn: Some(self.rn),
                mask: Some(self.mask),
                sysm: Some(self.sysm),
            }
        }
    }
    impl MsrConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Msr {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Msr",
                "rn",
                &self.rn,
                "mask",
                &self.mask,
                "sysm",
                &&self.sysm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Msr {
        #[inline]
        fn clone(&self) -> Msr {
            Msr {
                rn: ::core::clone::Clone::clone(&self.rn),
                mask: ::core::clone::Clone::clone(&self.mask),
                sysm: ::core::clone::Clone::clone(&self.sysm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Msr {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Msr {
        #[inline]
        fn eq(&self, other: &Msr) -> bool {
            self.rn == other.rn && self.mask == other.mask && self.sysm == other.sysm
        }
    }
    impl From<Msr> for Operation {
        fn from(val: Msr) -> Operation {
            Operation::Msr(val)
        }
    }
    pub struct Mul {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct MulBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > MulBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> MulBuilder<true, rdSET, rnSET, rmSET> {
            self.s = Some(s);
            MulBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > MulBuilder<sSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> MulBuilder<sSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            MulBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > MulBuilder<sSET, rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> MulBuilder<sSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            MulBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > MulBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> MulBuilder<sSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            MulBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl MulBuilder<false, false, false, false> {
        pub fn new() -> MulBuilder<false, false, false, false> {
            MulBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Mul {
        pub fn builder() -> MulBuilder<false, false, false, false> {
            MulBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl MulBuilder<true, true, true, true> {
        pub fn complete(self) -> Mul {
            Mul {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct MulConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > MulConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (Option<SetFlags>, MulConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                MulConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > MulConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, MulConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MulConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > MulConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, MulConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                MulConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > MulConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, MulConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                MulConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Mul {
        pub fn consumer(self) -> MulConsumer<false, false, false, false> {
            MulConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl MulConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mul {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Mul",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mul {
        #[inline]
        fn clone(&self) -> Mul {
            Mul {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mul {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mul {
        #[inline]
        fn eq(&self, other: &Mul) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Mul> for Operation {
        fn from(val: Mul) -> Operation {
            Operation::Mul(val)
        }
    }
    pub struct MvnImmediate {
        pub s: Option<bool>,
        pub rd: Register,
        pub carry: Option<bool>,
        pub imm: u32,
    }
    pub struct MvnImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > MvnImmediateBuilder<false, rdSET, carrySET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> MvnImmediateBuilder<true, rdSET, carrySET, immSET> {
            self.s = Some(s);
            MvnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > MvnImmediateBuilder<sSET, false, carrySET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> MvnImmediateBuilder<sSET, true, carrySET, immSET> {
            self.rd = Some(rd);
            MvnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > MvnImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> MvnImmediateBuilder<sSET, rdSET, true, immSET> {
            self.carry = Some(carry);
            MvnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const carrySET: bool,
    > MvnImmediateBuilder<sSET, rdSET, carrySET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> MvnImmediateBuilder<sSET, rdSET, carrySET, true> {
            self.imm = Some(imm);
            MvnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl MvnImmediateBuilder<false, false, false, false> {
        pub fn new() -> MvnImmediateBuilder<false, false, false, false> {
            MvnImmediateBuilder {
                s: None,
                rd: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl MvnImmediate {
        pub fn builder() -> MvnImmediateBuilder<false, false, false, false> {
            MvnImmediateBuilder {
                s: None,
                rd: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl MvnImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> MvnImmediate {
            MvnImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                carry: self.carry.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct MvnImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > MvnImmediateConsumer<false, rdCONSUMED, carryCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            MvnImmediateConsumer<true, rdCONSUMED, carryCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                MvnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > MvnImmediateConsumer<sCONSUMED, false, carryCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            MvnImmediateConsumer<sCONSUMED, true, carryCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MvnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > MvnImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_carry(
            mut self,
        ) -> (
            Option<bool>,
            MvnImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>,
        ) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                MvnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const carryCONSUMED: bool,
    > MvnImmediateConsumer<sCONSUMED, rdCONSUMED, carryCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, MvnImmediateConsumer<sCONSUMED, rdCONSUMED, carryCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                MvnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl MvnImmediate {
        pub fn consumer(self) -> MvnImmediateConsumer<false, false, false, false> {
            MvnImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                carry: Some(self.carry),
                imm: Some(self.imm),
            }
        }
    }
    impl MvnImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MvnImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "MvnImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "carry",
                &self.carry,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MvnImmediate {
        #[inline]
        fn clone(&self) -> MvnImmediate {
            MvnImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                carry: ::core::clone::Clone::clone(&self.carry),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MvnImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MvnImmediate {
        #[inline]
        fn eq(&self, other: &MvnImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.carry == other.carry
                && self.imm == other.imm
        }
    }
    impl From<MvnImmediate> for Operation {
        fn from(val: MvnImmediate) -> Operation {
            Operation::MvnImmediate(val)
        }
    }
    pub struct MvnRegister {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct MvnRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > MvnRegisterBuilder<false, rdSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> MvnRegisterBuilder<true, rdSET, rmSET, shiftSET> {
            self.s = Some(s);
            MvnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > MvnRegisterBuilder<sSET, false, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> MvnRegisterBuilder<sSET, true, rmSET, shiftSET> {
            self.rd = Some(rd);
            MvnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const shiftSET: bool,
    > MvnRegisterBuilder<sSET, rdSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> MvnRegisterBuilder<sSET, rdSET, true, shiftSET> {
            self.rm = Some(rm);
            MvnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > MvnRegisterBuilder<sSET, rdSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> MvnRegisterBuilder<sSET, rdSET, rmSET, true> {
            self.shift = Some(shift);
            MvnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl MvnRegisterBuilder<false, false, false, false> {
        pub fn new() -> MvnRegisterBuilder<false, false, false, false> {
            MvnRegisterBuilder {
                s: None,
                rd: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl MvnRegister {
        pub fn builder() -> MvnRegisterBuilder<false, false, false, false> {
            MvnRegisterBuilder {
                s: None,
                rd: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl MvnRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> MvnRegister {
            MvnRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct MvnRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > MvnRegisterConsumer<false, rdCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            MvnRegisterConsumer<true, rdCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                MvnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > MvnRegisterConsumer<sCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            MvnRegisterConsumer<sCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                MvnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const shiftCONSUMED: bool,
    > MvnRegisterConsumer<sCONSUMED, rdCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            MvnRegisterConsumer<sCONSUMED, rdCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                MvnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > MvnRegisterConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            MvnRegisterConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                MvnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl MvnRegister {
        pub fn consumer(self) -> MvnRegisterConsumer<false, false, false, false> {
            MvnRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl MvnRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MvnRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "MvnRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MvnRegister {
        #[inline]
        fn clone(&self) -> MvnRegister {
            MvnRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MvnRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MvnRegister {
        #[inline]
        fn eq(&self, other: &MvnRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<MvnRegister> for Operation {
        fn from(val: MvnRegister) -> Operation {
            Operation::MvnRegister(val)
        }
    }
    pub struct Nop {}
    pub struct NopBuilder {}
    impl NopBuilder {
        pub fn new() -> NopBuilder {
            NopBuilder {}
        }
    }
    impl Nop {
        pub fn builder() -> NopBuilder {
            NopBuilder {}
        }
    }
    impl NopBuilder {
        pub fn complete(self) -> Nop {
            Nop {}
        }
    }
    pub struct NopConsumer {}
    impl Nop {
        pub fn consumer(self) -> NopConsumer {
            NopConsumer {}
        }
    }
    impl NopConsumer {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Nop {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Nop")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Nop {
        #[inline]
        fn clone(&self) -> Nop {
            Nop {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Nop {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Nop {
        #[inline]
        fn eq(&self, other: &Nop) -> bool {
            true
        }
    }
    impl From<Nop> for Operation {
        fn from(val: Nop) -> Operation {
            Operation::Nop(val)
        }
    }
    pub struct OrnImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub carry: Option<bool>,
        pub imm: u32,
    }
    pub struct OrnImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > OrnImmediateBuilder<false, rdSET, rnSET, carrySET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> OrnImmediateBuilder<true, rdSET, rnSET, carrySET, immSET> {
            self.s = Some(s);
            OrnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > OrnImmediateBuilder<sSET, false, rnSET, carrySET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> OrnImmediateBuilder<sSET, true, rnSET, carrySET, immSET> {
            self.rd = Some(rd);
            OrnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > OrnImmediateBuilder<sSET, rdSET, false, carrySET, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> OrnImmediateBuilder<sSET, rdSET, true, carrySET, immSET> {
            self.rn = Some(rn);
            OrnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > OrnImmediateBuilder<sSET, rdSET, rnSET, false, immSET> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> OrnImmediateBuilder<sSET, rdSET, rnSET, true, immSET> {
            self.carry = Some(carry);
            OrnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
    > OrnImmediateBuilder<sSET, rdSET, rnSET, carrySET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> OrnImmediateBuilder<sSET, rdSET, rnSET, carrySET, true> {
            self.imm = Some(imm);
            OrnImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl OrnImmediateBuilder<false, false, false, false, false> {
        pub fn new() -> OrnImmediateBuilder<false, false, false, false, false> {
            OrnImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl OrnImmediate {
        pub fn builder() -> OrnImmediateBuilder<false, false, false, false, false> {
            OrnImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl OrnImmediateBuilder<true, true, true, true, true> {
        pub fn complete(self) -> OrnImmediate {
            OrnImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                carry: self.carry.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct OrnImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > OrnImmediateConsumer<false, rdCONSUMED, rnCONSUMED, carryCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            OrnImmediateConsumer<
                true,
                rdCONSUMED,
                rnCONSUMED,
                carryCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                OrnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > OrnImmediateConsumer<sCONSUMED, false, rnCONSUMED, carryCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            OrnImmediateConsumer<sCONSUMED, true, rnCONSUMED, carryCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                OrnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > OrnImmediateConsumer<sCONSUMED, rdCONSUMED, false, carryCONSUMED, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            OrnImmediateConsumer<sCONSUMED, rdCONSUMED, true, carryCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                OrnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > OrnImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, immCONSUMED> {
        pub fn consume_carry(
            mut self,
        ) -> (
            Option<bool>,
            OrnImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, immCONSUMED>,
        ) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                OrnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
    > OrnImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, carryCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            OrnImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, carryCONSUMED, true>,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                OrnImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl OrnImmediate {
        pub fn consumer(
            self,
        ) -> OrnImmediateConsumer<false, false, false, false, false> {
            OrnImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                carry: Some(self.carry),
                imm: Some(self.imm),
            }
        }
    }
    impl OrnImmediateConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OrnImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "OrnImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "carry",
                &self.carry,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OrnImmediate {
        #[inline]
        fn clone(&self) -> OrnImmediate {
            OrnImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                carry: ::core::clone::Clone::clone(&self.carry),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OrnImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OrnImmediate {
        #[inline]
        fn eq(&self, other: &OrnImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.carry == other.carry && self.imm == other.imm
        }
    }
    impl From<OrnImmediate> for Operation {
        fn from(val: OrnImmediate) -> Operation {
            Operation::OrnImmediate(val)
        }
    }
    pub struct OrnRegister {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct OrnRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > OrnRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> OrnRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            OrnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > OrnRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> OrnRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            OrnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > OrnRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> OrnRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            OrnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > OrnRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> OrnRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            OrnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > OrnRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> OrnRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            OrnRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl OrnRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> OrnRegisterBuilder<false, false, false, false, false> {
            OrnRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl OrnRegister {
        pub fn builder() -> OrnRegisterBuilder<false, false, false, false, false> {
            OrnRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl OrnRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> OrnRegister {
            OrnRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct OrnRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > OrnRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            OrnRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                OrnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > OrnRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            OrnRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                OrnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > OrnRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            OrnRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                OrnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > OrnRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            OrnRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                OrnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > OrnRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            OrnRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                OrnRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl OrnRegister {
        pub fn consumer(self) -> OrnRegisterConsumer<false, false, false, false, false> {
            OrnRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl OrnRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OrnRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "OrnRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OrnRegister {
        #[inline]
        fn clone(&self) -> OrnRegister {
            OrnRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OrnRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OrnRegister {
        #[inline]
        fn eq(&self, other: &OrnRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<OrnRegister> for Operation {
        fn from(val: OrnRegister) -> Operation {
            Operation::OrnRegister(val)
        }
    }
    pub struct OrrImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub carry: Option<bool>,
        pub imm: u32,
    }
    pub struct OrrImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > OrrImmediateBuilder<false, rdSET, rnSET, carrySET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> OrrImmediateBuilder<true, rdSET, rnSET, carrySET, immSET> {
            self.s = Some(s);
            OrrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > OrrImmediateBuilder<sSET, false, rnSET, carrySET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> OrrImmediateBuilder<sSET, true, rnSET, carrySET, immSET> {
            self.rd = Some(rd);
            OrrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > OrrImmediateBuilder<sSET, rdSET, false, carrySET, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> OrrImmediateBuilder<sSET, rdSET, true, carrySET, immSET> {
            self.rn = Some(rn);
            OrrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > OrrImmediateBuilder<sSET, rdSET, rnSET, false, immSET> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> OrrImmediateBuilder<sSET, rdSET, rnSET, true, immSET> {
            self.carry = Some(carry);
            OrrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
    > OrrImmediateBuilder<sSET, rdSET, rnSET, carrySET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> OrrImmediateBuilder<sSET, rdSET, rnSET, carrySET, true> {
            self.imm = Some(imm);
            OrrImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl OrrImmediateBuilder<false, false, false, false, false> {
        pub fn new() -> OrrImmediateBuilder<false, false, false, false, false> {
            OrrImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl OrrImmediate {
        pub fn builder() -> OrrImmediateBuilder<false, false, false, false, false> {
            OrrImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl OrrImmediateBuilder<true, true, true, true, true> {
        pub fn complete(self) -> OrrImmediate {
            OrrImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                carry: self.carry.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct OrrImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > OrrImmediateConsumer<false, rdCONSUMED, rnCONSUMED, carryCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            OrrImmediateConsumer<
                true,
                rdCONSUMED,
                rnCONSUMED,
                carryCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                OrrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > OrrImmediateConsumer<sCONSUMED, false, rnCONSUMED, carryCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            OrrImmediateConsumer<sCONSUMED, true, rnCONSUMED, carryCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                OrrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > OrrImmediateConsumer<sCONSUMED, rdCONSUMED, false, carryCONSUMED, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            OrrImmediateConsumer<sCONSUMED, rdCONSUMED, true, carryCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                OrrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > OrrImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, immCONSUMED> {
        pub fn consume_carry(
            mut self,
        ) -> (
            Option<bool>,
            OrrImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, immCONSUMED>,
        ) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                OrrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
    > OrrImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, carryCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            OrrImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, carryCONSUMED, true>,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                OrrImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl OrrImmediate {
        pub fn consumer(
            self,
        ) -> OrrImmediateConsumer<false, false, false, false, false> {
            OrrImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                carry: Some(self.carry),
                imm: Some(self.imm),
            }
        }
    }
    impl OrrImmediateConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OrrImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "OrrImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "carry",
                &self.carry,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OrrImmediate {
        #[inline]
        fn clone(&self) -> OrrImmediate {
            OrrImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                carry: ::core::clone::Clone::clone(&self.carry),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OrrImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OrrImmediate {
        #[inline]
        fn eq(&self, other: &OrrImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.carry == other.carry && self.imm == other.imm
        }
    }
    impl From<OrrImmediate> for Operation {
        fn from(val: OrrImmediate) -> Operation {
            Operation::OrrImmediate(val)
        }
    }
    pub struct OrrRegister {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct OrrRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > OrrRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> OrrRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            OrrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > OrrRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> OrrRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            OrrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > OrrRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> OrrRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            OrrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > OrrRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> OrrRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            OrrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > OrrRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> OrrRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            OrrRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl OrrRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> OrrRegisterBuilder<false, false, false, false, false> {
            OrrRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl OrrRegister {
        pub fn builder() -> OrrRegisterBuilder<false, false, false, false, false> {
            OrrRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl OrrRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> OrrRegister {
            OrrRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct OrrRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > OrrRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            OrrRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                OrrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > OrrRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            OrrRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                OrrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > OrrRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            OrrRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                OrrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > OrrRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            OrrRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                OrrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > OrrRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            OrrRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                OrrRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl OrrRegister {
        pub fn consumer(self) -> OrrRegisterConsumer<false, false, false, false, false> {
            OrrRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl OrrRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OrrRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "OrrRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OrrRegister {
        #[inline]
        fn clone(&self) -> OrrRegister {
            OrrRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OrrRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OrrRegister {
        #[inline]
        fn eq(&self, other: &OrrRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<OrrRegister> for Operation {
        fn from(val: OrrRegister) -> Operation {
            Operation::OrrRegister(val)
        }
    }
    pub struct Pkh {
        pub tb: bool,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct PkhBuilder<
        const tbSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        tb: Option<bool>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > PkhBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_tb(
            mut self,
            tb: bool,
        ) -> PkhBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.tb = Some(tb);
            PkhBuilder {
                tb: self.tb,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const tbSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > PkhBuilder<tbSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> PkhBuilder<tbSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            PkhBuilder {
                tb: self.tb,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const tbSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > PkhBuilder<tbSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> PkhBuilder<tbSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            PkhBuilder {
                tb: self.tb,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const tbSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > PkhBuilder<tbSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> PkhBuilder<tbSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            PkhBuilder {
                tb: self.tb,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const tbSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > PkhBuilder<tbSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> PkhBuilder<tbSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            PkhBuilder {
                tb: self.tb,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl PkhBuilder<false, false, false, false, false> {
        pub fn new() -> PkhBuilder<false, false, false, false, false> {
            PkhBuilder {
                tb: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl Pkh {
        pub fn builder() -> PkhBuilder<false, false, false, false, false> {
            PkhBuilder {
                tb: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl PkhBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Pkh {
            Pkh {
                tb: self.tb.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct PkhConsumer<
        const tbSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        tb: Option<bool>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > PkhConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_tb(
            mut self,
        ) -> (
            bool,
            PkhConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.tb.unwrap();
            self.tb = None;
            (
                ret,
                PkhConsumer {
                    tb: self.tb,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const tbCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > PkhConsumer<tbCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            PkhConsumer<tbCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                PkhConsumer {
                    tb: self.tb,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const tbCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > PkhConsumer<tbCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            PkhConsumer<tbCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                PkhConsumer {
                    tb: self.tb,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const tbCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > PkhConsumer<tbCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            PkhConsumer<tbCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                PkhConsumer {
                    tb: self.tb,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const tbCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > PkhConsumer<tbCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            PkhConsumer<tbCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                PkhConsumer {
                    tb: self.tb,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl Pkh {
        pub fn consumer(self) -> PkhConsumer<false, false, false, false, false> {
            PkhConsumer {
                tb: Some(self.tb),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl PkhConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Pkh {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Pkh",
                "tb",
                &self.tb,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Pkh {
        #[inline]
        fn clone(&self) -> Pkh {
            Pkh {
                tb: ::core::clone::Clone::clone(&self.tb),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Pkh {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Pkh {
        #[inline]
        fn eq(&self, other: &Pkh) -> bool {
            self.tb == other.tb && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<Pkh> for Operation {
        fn from(val: Pkh) -> Operation {
            Operation::Pkh(val)
        }
    }
    pub struct PldImmediate {
        pub add: Option<bool>,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct PldImmediateBuilder<
        const addSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        add: Option<Option<bool>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rnSET: bool,
        const immSET: bool,
    > PldImmediateBuilder<false, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> PldImmediateBuilder<true, rnSET, immSET> {
            self.add = Some(add);
            PldImmediateBuilder {
                add: self.add,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const immSET: bool,
    > PldImmediateBuilder<addSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> PldImmediateBuilder<addSET, true, immSET> {
            self.rn = Some(rn);
            PldImmediateBuilder {
                add: self.add,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const rnSET: bool,
    > PldImmediateBuilder<addSET, rnSET, false> {
        pub fn set_imm(mut self, imm: u32) -> PldImmediateBuilder<addSET, rnSET, true> {
            self.imm = Some(imm);
            PldImmediateBuilder {
                add: self.add,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl PldImmediateBuilder<false, false, false> {
        pub fn new() -> PldImmediateBuilder<false, false, false> {
            PldImmediateBuilder {
                add: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl PldImmediate {
        pub fn builder() -> PldImmediateBuilder<false, false, false> {
            PldImmediateBuilder {
                add: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl PldImmediateBuilder<true, true, true> {
        pub fn complete(self) -> PldImmediate {
            PldImmediate {
                add: self.add.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct PldImmediateConsumer<
        const addSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        add: Option<Option<bool>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > PldImmediateConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (Option<bool>, PldImmediateConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                PldImmediateConsumer {
                    add: self.add,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const immCONSUMED: bool,
    > PldImmediateConsumer<addCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, PldImmediateConsumer<addCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                PldImmediateConsumer {
                    add: self.add,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rnCONSUMED: bool,
    > PldImmediateConsumer<addCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, PldImmediateConsumer<addCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                PldImmediateConsumer {
                    add: self.add,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl PldImmediate {
        pub fn consumer(self) -> PldImmediateConsumer<false, false, false> {
            PldImmediateConsumer {
                add: Some(self.add),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl PldImmediateConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PldImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PldImmediate",
                "add",
                &self.add,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PldImmediate {
        #[inline]
        fn clone(&self) -> PldImmediate {
            PldImmediate {
                add: ::core::clone::Clone::clone(&self.add),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PldImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PldImmediate {
        #[inline]
        fn eq(&self, other: &PldImmediate) -> bool {
            self.add == other.add && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<PldImmediate> for Operation {
        fn from(val: PldImmediate) -> Operation {
            Operation::PldImmediate(val)
        }
    }
    pub struct PldLiteral {
        pub add: Option<bool>,
        pub imm: u32,
    }
    pub struct PldLiteralBuilder<const addSET: bool, const immSET: bool> {
        add: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<const immSET: bool> PldLiteralBuilder<false, immSET> {
        pub fn set_add(mut self, add: Option<bool>) -> PldLiteralBuilder<true, immSET> {
            self.add = Some(add);
            PldLiteralBuilder {
                add: self.add,
                imm: self.imm,
            }
        }
    }
    impl<const addSET: bool> PldLiteralBuilder<addSET, false> {
        pub fn set_imm(mut self, imm: u32) -> PldLiteralBuilder<addSET, true> {
            self.imm = Some(imm);
            PldLiteralBuilder {
                add: self.add,
                imm: self.imm,
            }
        }
    }
    impl PldLiteralBuilder<false, false> {
        pub fn new() -> PldLiteralBuilder<false, false> {
            PldLiteralBuilder {
                add: None,
                imm: None,
            }
        }
    }
    impl PldLiteral {
        pub fn builder() -> PldLiteralBuilder<false, false> {
            PldLiteralBuilder {
                add: None,
                imm: None,
            }
        }
    }
    impl PldLiteralBuilder<true, true> {
        pub fn complete(self) -> PldLiteral {
            PldLiteral {
                add: self.add.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct PldLiteralConsumer<const addSET: bool, const immSET: bool> {
        add: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<const immCONSUMED: bool> PldLiteralConsumer<false, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (Option<bool>, PldLiteralConsumer<true, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                PldLiteralConsumer {
                    add: self.add,
                    imm: self.imm,
                },
            )
        }
    }
    impl<const addCONSUMED: bool> PldLiteralConsumer<addCONSUMED, false> {
        pub fn consume_imm(mut self) -> (u32, PldLiteralConsumer<addCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                PldLiteralConsumer {
                    add: self.add,
                    imm: self.imm,
                },
            )
        }
    }
    impl PldLiteral {
        pub fn consumer(self) -> PldLiteralConsumer<false, false> {
            PldLiteralConsumer {
                add: Some(self.add),
                imm: Some(self.imm),
            }
        }
    }
    impl PldLiteralConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PldLiteral {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "PldLiteral",
                "add",
                &self.add,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PldLiteral {
        #[inline]
        fn clone(&self) -> PldLiteral {
            PldLiteral {
                add: ::core::clone::Clone::clone(&self.add),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PldLiteral {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PldLiteral {
        #[inline]
        fn eq(&self, other: &PldLiteral) -> bool {
            self.add == other.add && self.imm == other.imm
        }
    }
    impl From<PldLiteral> for Operation {
        fn from(val: PldLiteral) -> Operation {
            Operation::PldLiteral(val)
        }
    }
    pub struct PldRegister {
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct PldRegisterBuilder<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmSET: bool,
        const shiftSET: bool,
    > PldRegisterBuilder<false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> PldRegisterBuilder<true, rmSET, shiftSET> {
            self.rn = Some(rn);
            PldRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rnSET: bool,
        const shiftSET: bool,
    > PldRegisterBuilder<rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> PldRegisterBuilder<rnSET, true, shiftSET> {
            self.rm = Some(rm);
            PldRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<const rnSET: bool, const rmSET: bool> PldRegisterBuilder<rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> PldRegisterBuilder<rnSET, rmSET, true> {
            self.shift = Some(shift);
            PldRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl PldRegisterBuilder<false, false, false> {
        pub fn new() -> PldRegisterBuilder<false, false, false> {
            PldRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl PldRegister {
        pub fn builder() -> PldRegisterBuilder<false, false, false> {
            PldRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl PldRegisterBuilder<true, true, true> {
        pub fn complete(self) -> PldRegister {
            PldRegister {
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct PldRegisterConsumer<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > PldRegisterConsumer<false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, PldRegisterConsumer<true, rmCONSUMED, shiftCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                PldRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > PldRegisterConsumer<rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, PldRegisterConsumer<rnCONSUMED, true, shiftCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                PldRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > PldRegisterConsumer<rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (Option<ImmShift>, PldRegisterConsumer<rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                PldRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl PldRegister {
        pub fn consumer(self) -> PldRegisterConsumer<false, false, false> {
            PldRegisterConsumer {
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl PldRegisterConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PldRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PldRegister",
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PldRegister {
        #[inline]
        fn clone(&self) -> PldRegister {
            PldRegister {
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PldRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PldRegister {
        #[inline]
        fn eq(&self, other: &PldRegister) -> bool {
            self.rn == other.rn && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<PldRegister> for Operation {
        fn from(val: PldRegister) -> Operation {
            Operation::PldRegister(val)
        }
    }
    pub struct PliImmediate {
        pub add: Option<bool>,
        pub rn: Option<Register>,
        pub imm: u32,
    }
    pub struct PliImmediateBuilder<
        const addSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        add: Option<Option<bool>>,
        rn: Option<Option<Register>>,
        imm: Option<u32>,
    }
    impl<
        const rnSET: bool,
        const immSET: bool,
    > PliImmediateBuilder<false, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: Option<bool>,
        ) -> PliImmediateBuilder<true, rnSET, immSET> {
            self.add = Some(add);
            PliImmediateBuilder {
                add: self.add,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const immSET: bool,
    > PliImmediateBuilder<addSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Option<Register>,
        ) -> PliImmediateBuilder<addSET, true, immSET> {
            self.rn = Some(rn);
            PliImmediateBuilder {
                add: self.add,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const addSET: bool,
        const rnSET: bool,
    > PliImmediateBuilder<addSET, rnSET, false> {
        pub fn set_imm(mut self, imm: u32) -> PliImmediateBuilder<addSET, rnSET, true> {
            self.imm = Some(imm);
            PliImmediateBuilder {
                add: self.add,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl PliImmediateBuilder<false, false, false> {
        pub fn new() -> PliImmediateBuilder<false, false, false> {
            PliImmediateBuilder {
                add: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl PliImmediate {
        pub fn builder() -> PliImmediateBuilder<false, false, false> {
            PliImmediateBuilder {
                add: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl PliImmediateBuilder<true, true, true> {
        pub fn complete(self) -> PliImmediate {
            PliImmediate {
                add: self.add.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct PliImmediateConsumer<
        const addSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        add: Option<Option<bool>>,
        rn: Option<Option<Register>>,
        imm: Option<u32>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > PliImmediateConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_add(
            mut self,
        ) -> (Option<bool>, PliImmediateConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                PliImmediateConsumer {
                    add: self.add,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const immCONSUMED: bool,
    > PliImmediateConsumer<addCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Option<Register>, PliImmediateConsumer<addCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                PliImmediateConsumer {
                    add: self.add,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const addCONSUMED: bool,
        const rnCONSUMED: bool,
    > PliImmediateConsumer<addCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, PliImmediateConsumer<addCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                PliImmediateConsumer {
                    add: self.add,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl PliImmediate {
        pub fn consumer(self) -> PliImmediateConsumer<false, false, false> {
            PliImmediateConsumer {
                add: Some(self.add),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl PliImmediateConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PliImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PliImmediate",
                "add",
                &self.add,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PliImmediate {
        #[inline]
        fn clone(&self) -> PliImmediate {
            PliImmediate {
                add: ::core::clone::Clone::clone(&self.add),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PliImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PliImmediate {
        #[inline]
        fn eq(&self, other: &PliImmediate) -> bool {
            self.add == other.add && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<PliImmediate> for Operation {
        fn from(val: PliImmediate) -> Operation {
            Operation::PliImmediate(val)
        }
    }
    pub struct PliRegister {
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct PliRegisterBuilder<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmSET: bool,
        const shiftSET: bool,
    > PliRegisterBuilder<false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> PliRegisterBuilder<true, rmSET, shiftSET> {
            self.rn = Some(rn);
            PliRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rnSET: bool,
        const shiftSET: bool,
    > PliRegisterBuilder<rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> PliRegisterBuilder<rnSET, true, shiftSET> {
            self.rm = Some(rm);
            PliRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<const rnSET: bool, const rmSET: bool> PliRegisterBuilder<rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> PliRegisterBuilder<rnSET, rmSET, true> {
            self.shift = Some(shift);
            PliRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl PliRegisterBuilder<false, false, false> {
        pub fn new() -> PliRegisterBuilder<false, false, false> {
            PliRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl PliRegister {
        pub fn builder() -> PliRegisterBuilder<false, false, false> {
            PliRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl PliRegisterBuilder<true, true, true> {
        pub fn complete(self) -> PliRegister {
            PliRegister {
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct PliRegisterConsumer<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > PliRegisterConsumer<false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, PliRegisterConsumer<true, rmCONSUMED, shiftCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                PliRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > PliRegisterConsumer<rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, PliRegisterConsumer<rnCONSUMED, true, shiftCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                PliRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > PliRegisterConsumer<rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (Option<ImmShift>, PliRegisterConsumer<rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                PliRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl PliRegister {
        pub fn consumer(self) -> PliRegisterConsumer<false, false, false> {
            PliRegisterConsumer {
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl PliRegisterConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PliRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "PliRegister",
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PliRegister {
        #[inline]
        fn clone(&self) -> PliRegister {
            PliRegister {
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PliRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PliRegister {
        #[inline]
        fn eq(&self, other: &PliRegister) -> bool {
            self.rn == other.rn && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<PliRegister> for Operation {
        fn from(val: PliRegister) -> Operation {
            Operation::PliRegister(val)
        }
    }
    pub struct Pop {
        pub registers: RegisterList,
    }
    pub struct PopBuilder<const registersSET: bool> {
        registers: Option<RegisterList>,
    }
    impl PopBuilder<false> {
        pub fn set_registers(mut self, registers: RegisterList) -> PopBuilder<true> {
            self.registers = Some(registers);
            PopBuilder {
                registers: self.registers,
            }
        }
    }
    impl PopBuilder<false> {
        pub fn new() -> PopBuilder<false> {
            PopBuilder { registers: None }
        }
    }
    impl Pop {
        pub fn builder() -> PopBuilder<false> {
            PopBuilder { registers: None }
        }
    }
    impl PopBuilder<true> {
        pub fn complete(self) -> Pop {
            Pop {
                registers: self.registers.unwrap(),
            }
        }
    }
    pub struct PopConsumer<const registersSET: bool> {
        registers: Option<RegisterList>,
    }
    impl PopConsumer<false> {
        pub fn consume_registers(mut self) -> (RegisterList, PopConsumer<true>) {
            let ret = self.registers.unwrap();
            self.registers = None;
            (
                ret,
                PopConsumer {
                    registers: self.registers,
                },
            )
        }
    }
    impl Pop {
        pub fn consumer(self) -> PopConsumer<false> {
            PopConsumer {
                registers: Some(self.registers),
            }
        }
    }
    impl PopConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Pop {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Pop",
                "registers",
                &&self.registers,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Pop {
        #[inline]
        fn clone(&self) -> Pop {
            Pop {
                registers: ::core::clone::Clone::clone(&self.registers),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Pop {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Pop {
        #[inline]
        fn eq(&self, other: &Pop) -> bool {
            self.registers == other.registers
        }
    }
    impl From<Pop> for Operation {
        fn from(val: Pop) -> Operation {
            Operation::Pop(val)
        }
    }
    pub struct Push {
        pub registers: RegisterList,
    }
    pub struct PushBuilder<const registersSET: bool> {
        registers: Option<RegisterList>,
    }
    impl PushBuilder<false> {
        pub fn set_registers(mut self, registers: RegisterList) -> PushBuilder<true> {
            self.registers = Some(registers);
            PushBuilder {
                registers: self.registers,
            }
        }
    }
    impl PushBuilder<false> {
        pub fn new() -> PushBuilder<false> {
            PushBuilder { registers: None }
        }
    }
    impl Push {
        pub fn builder() -> PushBuilder<false> {
            PushBuilder { registers: None }
        }
    }
    impl PushBuilder<true> {
        pub fn complete(self) -> Push {
            Push {
                registers: self.registers.unwrap(),
            }
        }
    }
    pub struct PushConsumer<const registersSET: bool> {
        registers: Option<RegisterList>,
    }
    impl PushConsumer<false> {
        pub fn consume_registers(mut self) -> (RegisterList, PushConsumer<true>) {
            let ret = self.registers.unwrap();
            self.registers = None;
            (
                ret,
                PushConsumer {
                    registers: self.registers,
                },
            )
        }
    }
    impl Push {
        pub fn consumer(self) -> PushConsumer<false> {
            PushConsumer {
                registers: Some(self.registers),
            }
        }
    }
    impl PushConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Push {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Push",
                "registers",
                &&self.registers,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Push {
        #[inline]
        fn clone(&self) -> Push {
            Push {
                registers: ::core::clone::Clone::clone(&self.registers),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Push {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Push {
        #[inline]
        fn eq(&self, other: &Push) -> bool {
            self.registers == other.registers
        }
    }
    impl From<Push> for Operation {
        fn from(val: Push) -> Operation {
            Operation::Push(val)
        }
    }
    pub struct Qadd {
        pub rd: Option<Register>,
        pub rm: Register,
        pub rn: Register,
    }
    pub struct QaddBuilder<const rdSET: bool, const rmSET: bool, const rnSET: bool> {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rmSET: bool, const rnSET: bool> QaddBuilder<false, rmSET, rnSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> QaddBuilder<true, rmSET, rnSET> {
            self.rd = Some(rd);
            QaddBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> QaddBuilder<rdSET, false, rnSET> {
        pub fn set_rm(mut self, rm: Register) -> QaddBuilder<rdSET, true, rnSET> {
            self.rm = Some(rm);
            QaddBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> QaddBuilder<rdSET, rmSET, false> {
        pub fn set_rn(mut self, rn: Register) -> QaddBuilder<rdSET, rmSET, true> {
            self.rn = Some(rn);
            QaddBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl QaddBuilder<false, false, false> {
        pub fn new() -> QaddBuilder<false, false, false> {
            QaddBuilder {
                rd: None,
                rm: None,
                rn: None,
            }
        }
    }
    impl Qadd {
        pub fn builder() -> QaddBuilder<false, false, false> {
            QaddBuilder {
                rd: None,
                rm: None,
                rn: None,
            }
        }
    }
    impl QaddBuilder<true, true, true> {
        pub fn complete(self) -> Qadd {
            Qadd {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct QaddConsumer<const rdSET: bool, const rmSET: bool, const rnSET: bool> {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rn: Option<Register>,
    }
    impl<
        const rmCONSUMED: bool,
        const rnCONSUMED: bool,
    > QaddConsumer<false, rmCONSUMED, rnCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, QaddConsumer<true, rmCONSUMED, rnCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                QaddConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > QaddConsumer<rdCONSUMED, false, rnCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, QaddConsumer<rdCONSUMED, true, rnCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                QaddConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > QaddConsumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, QaddConsumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                QaddConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl Qadd {
        pub fn consumer(self) -> QaddConsumer<false, false, false> {
            QaddConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rn: Some(self.rn),
            }
        }
    }
    impl QaddConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qadd {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qadd",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qadd {
        #[inline]
        fn clone(&self) -> Qadd {
            Qadd {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qadd {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qadd {
        #[inline]
        fn eq(&self, other: &Qadd) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rn == other.rn
        }
    }
    impl From<Qadd> for Operation {
        fn from(val: Qadd) -> Operation {
            Operation::Qadd(val)
        }
    }
    pub struct Qadd16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Qadd16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Qadd16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Qadd16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Qadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Qadd16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Qadd16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Qadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Qadd16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Qadd16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Qadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Qadd16Builder<false, false, false> {
        pub fn new() -> Qadd16Builder<false, false, false> {
            Qadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qadd16 {
        pub fn builder() -> Qadd16Builder<false, false, false> {
            Qadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qadd16Builder<true, true, true> {
        pub fn complete(self) -> Qadd16 {
            Qadd16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Qadd16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Qadd16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Qadd16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Qadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Qadd16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Qadd16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Qadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Qadd16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Qadd16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Qadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Qadd16 {
        pub fn consumer(self) -> Qadd16Consumer<false, false, false> {
            Qadd16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Qadd16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qadd16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qadd16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qadd16 {
        #[inline]
        fn clone(&self) -> Qadd16 {
            Qadd16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qadd16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qadd16 {
        #[inline]
        fn eq(&self, other: &Qadd16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Qadd16> for Operation {
        fn from(val: Qadd16) -> Operation {
            Operation::Qadd16(val)
        }
    }
    pub struct Qadd8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Qadd8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Qadd8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Qadd8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Qadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Qadd8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Qadd8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Qadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Qadd8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Qadd8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Qadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Qadd8Builder<false, false, false> {
        pub fn new() -> Qadd8Builder<false, false, false> {
            Qadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qadd8 {
        pub fn builder() -> Qadd8Builder<false, false, false> {
            Qadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qadd8Builder<true, true, true> {
        pub fn complete(self) -> Qadd8 {
            Qadd8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Qadd8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Qadd8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Qadd8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Qadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Qadd8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Qadd8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Qadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Qadd8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Qadd8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Qadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Qadd8 {
        pub fn consumer(self) -> Qadd8Consumer<false, false, false> {
            Qadd8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Qadd8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qadd8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qadd8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qadd8 {
        #[inline]
        fn clone(&self) -> Qadd8 {
            Qadd8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qadd8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qadd8 {
        #[inline]
        fn eq(&self, other: &Qadd8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Qadd8> for Operation {
        fn from(val: Qadd8) -> Operation {
            Operation::Qadd8(val)
        }
    }
    pub struct Qasx {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct QasxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> QasxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> QasxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            QasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> QasxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> QasxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            QasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> QasxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> QasxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            QasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl QasxBuilder<false, false, false> {
        pub fn new() -> QasxBuilder<false, false, false> {
            QasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qasx {
        pub fn builder() -> QasxBuilder<false, false, false> {
            QasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl QasxBuilder<true, true, true> {
        pub fn complete(self) -> Qasx {
            Qasx {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct QasxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > QasxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, QasxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                QasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > QasxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, QasxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                QasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > QasxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, QasxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                QasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Qasx {
        pub fn consumer(self) -> QasxConsumer<false, false, false> {
            QasxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl QasxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qasx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qasx",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qasx {
        #[inline]
        fn clone(&self) -> Qasx {
            Qasx {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qasx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qasx {
        #[inline]
        fn eq(&self, other: &Qasx) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Qasx> for Operation {
        fn from(val: Qasx) -> Operation {
            Operation::Qasx(val)
        }
    }
    pub struct Qdadd {
        pub rd: Option<Register>,
        pub rm: Register,
        pub rn: Register,
    }
    pub struct QdaddBuilder<const rdSET: bool, const rmSET: bool, const rnSET: bool> {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rmSET: bool, const rnSET: bool> QdaddBuilder<false, rmSET, rnSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> QdaddBuilder<true, rmSET, rnSET> {
            self.rd = Some(rd);
            QdaddBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> QdaddBuilder<rdSET, false, rnSET> {
        pub fn set_rm(mut self, rm: Register) -> QdaddBuilder<rdSET, true, rnSET> {
            self.rm = Some(rm);
            QdaddBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> QdaddBuilder<rdSET, rmSET, false> {
        pub fn set_rn(mut self, rn: Register) -> QdaddBuilder<rdSET, rmSET, true> {
            self.rn = Some(rn);
            QdaddBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl QdaddBuilder<false, false, false> {
        pub fn new() -> QdaddBuilder<false, false, false> {
            QdaddBuilder {
                rd: None,
                rm: None,
                rn: None,
            }
        }
    }
    impl Qdadd {
        pub fn builder() -> QdaddBuilder<false, false, false> {
            QdaddBuilder {
                rd: None,
                rm: None,
                rn: None,
            }
        }
    }
    impl QdaddBuilder<true, true, true> {
        pub fn complete(self) -> Qdadd {
            Qdadd {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct QdaddConsumer<const rdSET: bool, const rmSET: bool, const rnSET: bool> {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rn: Option<Register>,
    }
    impl<
        const rmCONSUMED: bool,
        const rnCONSUMED: bool,
    > QdaddConsumer<false, rmCONSUMED, rnCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, QdaddConsumer<true, rmCONSUMED, rnCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                QdaddConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > QdaddConsumer<rdCONSUMED, false, rnCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, QdaddConsumer<rdCONSUMED, true, rnCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                QdaddConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > QdaddConsumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, QdaddConsumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                QdaddConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl Qdadd {
        pub fn consumer(self) -> QdaddConsumer<false, false, false> {
            QdaddConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rn: Some(self.rn),
            }
        }
    }
    impl QdaddConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qdadd {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qdadd",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qdadd {
        #[inline]
        fn clone(&self) -> Qdadd {
            Qdadd {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qdadd {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qdadd {
        #[inline]
        fn eq(&self, other: &Qdadd) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rn == other.rn
        }
    }
    impl From<Qdadd> for Operation {
        fn from(val: Qdadd) -> Operation {
            Operation::Qdadd(val)
        }
    }
    pub struct Qdsub {
        pub rd: Option<Register>,
        pub rm: Register,
        pub rn: Register,
    }
    pub struct QdsubBuilder<const rdSET: bool, const rmSET: bool, const rnSET: bool> {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rmSET: bool, const rnSET: bool> QdsubBuilder<false, rmSET, rnSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> QdsubBuilder<true, rmSET, rnSET> {
            self.rd = Some(rd);
            QdsubBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> QdsubBuilder<rdSET, false, rnSET> {
        pub fn set_rm(mut self, rm: Register) -> QdsubBuilder<rdSET, true, rnSET> {
            self.rm = Some(rm);
            QdsubBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> QdsubBuilder<rdSET, rmSET, false> {
        pub fn set_rn(mut self, rn: Register) -> QdsubBuilder<rdSET, rmSET, true> {
            self.rn = Some(rn);
            QdsubBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl QdsubBuilder<false, false, false> {
        pub fn new() -> QdsubBuilder<false, false, false> {
            QdsubBuilder {
                rd: None,
                rm: None,
                rn: None,
            }
        }
    }
    impl Qdsub {
        pub fn builder() -> QdsubBuilder<false, false, false> {
            QdsubBuilder {
                rd: None,
                rm: None,
                rn: None,
            }
        }
    }
    impl QdsubBuilder<true, true, true> {
        pub fn complete(self) -> Qdsub {
            Qdsub {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct QdsubConsumer<const rdSET: bool, const rmSET: bool, const rnSET: bool> {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rn: Option<Register>,
    }
    impl<
        const rmCONSUMED: bool,
        const rnCONSUMED: bool,
    > QdsubConsumer<false, rmCONSUMED, rnCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, QdsubConsumer<true, rmCONSUMED, rnCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                QdsubConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > QdsubConsumer<rdCONSUMED, false, rnCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, QdsubConsumer<rdCONSUMED, true, rnCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                QdsubConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > QdsubConsumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, QdsubConsumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                QdsubConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl Qdsub {
        pub fn consumer(self) -> QdsubConsumer<false, false, false> {
            QdsubConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rn: Some(self.rn),
            }
        }
    }
    impl QdsubConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qdsub {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qdsub",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qdsub {
        #[inline]
        fn clone(&self) -> Qdsub {
            Qdsub {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qdsub {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qdsub {
        #[inline]
        fn eq(&self, other: &Qdsub) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rn == other.rn
        }
    }
    impl From<Qdsub> for Operation {
        fn from(val: Qdsub) -> Operation {
            Operation::Qdsub(val)
        }
    }
    pub struct Qsax {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct QsaxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> QsaxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> QsaxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            QsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> QsaxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> QsaxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            QsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> QsaxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> QsaxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            QsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl QsaxBuilder<false, false, false> {
        pub fn new() -> QsaxBuilder<false, false, false> {
            QsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qsax {
        pub fn builder() -> QsaxBuilder<false, false, false> {
            QsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl QsaxBuilder<true, true, true> {
        pub fn complete(self) -> Qsax {
            Qsax {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct QsaxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > QsaxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, QsaxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                QsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > QsaxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, QsaxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                QsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > QsaxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, QsaxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                QsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Qsax {
        pub fn consumer(self) -> QsaxConsumer<false, false, false> {
            QsaxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl QsaxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qsax {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qsax",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qsax {
        #[inline]
        fn clone(&self) -> Qsax {
            Qsax {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qsax {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qsax {
        #[inline]
        fn eq(&self, other: &Qsax) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Qsax> for Operation {
        fn from(val: Qsax) -> Operation {
            Operation::Qsax(val)
        }
    }
    pub struct Qsub {
        pub rd: Option<Register>,
        pub rm: Register,
        pub rn: Register,
    }
    pub struct QsubBuilder<const rdSET: bool, const rmSET: bool, const rnSET: bool> {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rmSET: bool, const rnSET: bool> QsubBuilder<false, rmSET, rnSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> QsubBuilder<true, rmSET, rnSET> {
            self.rd = Some(rd);
            QsubBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> QsubBuilder<rdSET, false, rnSET> {
        pub fn set_rm(mut self, rm: Register) -> QsubBuilder<rdSET, true, rnSET> {
            self.rm = Some(rm);
            QsubBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> QsubBuilder<rdSET, rmSET, false> {
        pub fn set_rn(mut self, rn: Register) -> QsubBuilder<rdSET, rmSET, true> {
            self.rn = Some(rn);
            QsubBuilder {
                rd: self.rd,
                rm: self.rm,
                rn: self.rn,
            }
        }
    }
    impl QsubBuilder<false, false, false> {
        pub fn new() -> QsubBuilder<false, false, false> {
            QsubBuilder {
                rd: None,
                rm: None,
                rn: None,
            }
        }
    }
    impl Qsub {
        pub fn builder() -> QsubBuilder<false, false, false> {
            QsubBuilder {
                rd: None,
                rm: None,
                rn: None,
            }
        }
    }
    impl QsubBuilder<true, true, true> {
        pub fn complete(self) -> Qsub {
            Qsub {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct QsubConsumer<const rdSET: bool, const rmSET: bool, const rnSET: bool> {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rn: Option<Register>,
    }
    impl<
        const rmCONSUMED: bool,
        const rnCONSUMED: bool,
    > QsubConsumer<false, rmCONSUMED, rnCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, QsubConsumer<true, rmCONSUMED, rnCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                QsubConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > QsubConsumer<rdCONSUMED, false, rnCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, QsubConsumer<rdCONSUMED, true, rnCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                QsubConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > QsubConsumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, QsubConsumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                QsubConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rn: self.rn,
                },
            )
        }
    }
    impl Qsub {
        pub fn consumer(self) -> QsubConsumer<false, false, false> {
            QsubConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rn: Some(self.rn),
            }
        }
    }
    impl QsubConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qsub {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qsub",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qsub {
        #[inline]
        fn clone(&self) -> Qsub {
            Qsub {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qsub {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qsub {
        #[inline]
        fn eq(&self, other: &Qsub) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rn == other.rn
        }
    }
    impl From<Qsub> for Operation {
        fn from(val: Qsub) -> Operation {
            Operation::Qsub(val)
        }
    }
    pub struct Qsub16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Qsub16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Qsub16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Qsub16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Qsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Qsub16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Qsub16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Qsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Qsub16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Qsub16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Qsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Qsub16Builder<false, false, false> {
        pub fn new() -> Qsub16Builder<false, false, false> {
            Qsub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qsub16 {
        pub fn builder() -> Qsub16Builder<false, false, false> {
            Qsub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qsub16Builder<true, true, true> {
        pub fn complete(self) -> Qsub16 {
            Qsub16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Qsub16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Qsub16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Qsub16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Qsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Qsub16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Qsub16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Qsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Qsub16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Qsub16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Qsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Qsub16 {
        pub fn consumer(self) -> Qsub16Consumer<false, false, false> {
            Qsub16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Qsub16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qsub16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qsub16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qsub16 {
        #[inline]
        fn clone(&self) -> Qsub16 {
            Qsub16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qsub16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qsub16 {
        #[inline]
        fn eq(&self, other: &Qsub16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Qsub16> for Operation {
        fn from(val: Qsub16) -> Operation {
            Operation::Qsub16(val)
        }
    }
    pub struct Qsub8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Qsub8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Qsub8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Qsub8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Qsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Qsub8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Qsub8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Qsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Qsub8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Qsub8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Qsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Qsub8Builder<false, false, false> {
        pub fn new() -> Qsub8Builder<false, false, false> {
            Qsub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qsub8 {
        pub fn builder() -> Qsub8Builder<false, false, false> {
            Qsub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Qsub8Builder<true, true, true> {
        pub fn complete(self) -> Qsub8 {
            Qsub8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Qsub8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Qsub8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Qsub8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Qsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Qsub8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Qsub8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Qsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Qsub8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Qsub8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Qsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Qsub8 {
        pub fn consumer(self) -> Qsub8Consumer<false, false, false> {
            Qsub8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Qsub8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Qsub8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Qsub8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Qsub8 {
        #[inline]
        fn clone(&self) -> Qsub8 {
            Qsub8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Qsub8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Qsub8 {
        #[inline]
        fn eq(&self, other: &Qsub8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Qsub8> for Operation {
        fn from(val: Qsub8) -> Operation {
            Operation::Qsub8(val)
        }
    }
    pub struct Rbit {
        pub rm: Register,
        pub rd: Register,
    }
    pub struct RbitBuilder<const rmSET: bool, const rdSET: bool> {
        rm: Option<Register>,
        rd: Option<Register>,
    }
    impl<const rdSET: bool> RbitBuilder<false, rdSET> {
        pub fn set_rm(mut self, rm: Register) -> RbitBuilder<true, rdSET> {
            self.rm = Some(rm);
            RbitBuilder {
                rm: self.rm,
                rd: self.rd,
            }
        }
    }
    impl<const rmSET: bool> RbitBuilder<rmSET, false> {
        pub fn set_rd(mut self, rd: Register) -> RbitBuilder<rmSET, true> {
            self.rd = Some(rd);
            RbitBuilder {
                rm: self.rm,
                rd: self.rd,
            }
        }
    }
    impl RbitBuilder<false, false> {
        pub fn new() -> RbitBuilder<false, false> {
            RbitBuilder { rm: None, rd: None }
        }
    }
    impl Rbit {
        pub fn builder() -> RbitBuilder<false, false> {
            RbitBuilder { rm: None, rd: None }
        }
    }
    impl RbitBuilder<true, true> {
        pub fn complete(self) -> Rbit {
            Rbit {
                rm: self.rm.unwrap(),
                rd: self.rd.unwrap(),
            }
        }
    }
    pub struct RbitConsumer<const rmSET: bool, const rdSET: bool> {
        rm: Option<Register>,
        rd: Option<Register>,
    }
    impl<const rdCONSUMED: bool> RbitConsumer<false, rdCONSUMED> {
        pub fn consume_rm(mut self) -> (Register, RbitConsumer<true, rdCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                RbitConsumer {
                    rm: self.rm,
                    rd: self.rd,
                },
            )
        }
    }
    impl<const rmCONSUMED: bool> RbitConsumer<rmCONSUMED, false> {
        pub fn consume_rd(mut self) -> (Register, RbitConsumer<rmCONSUMED, true>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                RbitConsumer {
                    rm: self.rm,
                    rd: self.rd,
                },
            )
        }
    }
    impl Rbit {
        pub fn consumer(self) -> RbitConsumer<false, false> {
            RbitConsumer {
                rm: Some(self.rm),
                rd: Some(self.rd),
            }
        }
    }
    impl RbitConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Rbit {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Rbit",
                "rm",
                &self.rm,
                "rd",
                &&self.rd,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Rbit {
        #[inline]
        fn clone(&self) -> Rbit {
            Rbit {
                rm: ::core::clone::Clone::clone(&self.rm),
                rd: ::core::clone::Clone::clone(&self.rd),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Rbit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Rbit {
        #[inline]
        fn eq(&self, other: &Rbit) -> bool {
            self.rm == other.rm && self.rd == other.rd
        }
    }
    impl From<Rbit> for Operation {
        fn from(val: Rbit) -> Operation {
            Operation::Rbit(val)
        }
    }
    pub struct Rev {
        pub rd: Register,
        pub rm: Register,
    }
    pub struct RevBuilder<const rdSET: bool, const rmSET: bool> {
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rmSET: bool> RevBuilder<false, rmSET> {
        pub fn set_rd(mut self, rd: Register) -> RevBuilder<true, rmSET> {
            self.rd = Some(rd);
            RevBuilder {
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool> RevBuilder<rdSET, false> {
        pub fn set_rm(mut self, rm: Register) -> RevBuilder<rdSET, true> {
            self.rm = Some(rm);
            RevBuilder {
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl RevBuilder<false, false> {
        pub fn new() -> RevBuilder<false, false> {
            RevBuilder { rd: None, rm: None }
        }
    }
    impl Rev {
        pub fn builder() -> RevBuilder<false, false> {
            RevBuilder { rd: None, rm: None }
        }
    }
    impl RevBuilder<true, true> {
        pub fn complete(self) -> Rev {
            Rev {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct RevConsumer<const rdSET: bool, const rmSET: bool> {
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rmCONSUMED: bool> RevConsumer<false, rmCONSUMED> {
        pub fn consume_rd(mut self) -> (Register, RevConsumer<true, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                RevConsumer {
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl<const rdCONSUMED: bool> RevConsumer<rdCONSUMED, false> {
        pub fn consume_rm(mut self) -> (Register, RevConsumer<rdCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                RevConsumer {
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl Rev {
        pub fn consumer(self) -> RevConsumer<false, false> {
            RevConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
            }
        }
    }
    impl RevConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Rev {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Rev",
                "rd",
                &self.rd,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Rev {
        #[inline]
        fn clone(&self) -> Rev {
            Rev {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Rev {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Rev {
        #[inline]
        fn eq(&self, other: &Rev) -> bool {
            self.rd == other.rd && self.rm == other.rm
        }
    }
    impl From<Rev> for Operation {
        fn from(val: Rev) -> Operation {
            Operation::Rev(val)
        }
    }
    pub struct Rev16 {
        pub rd: Register,
        pub rm: Register,
    }
    pub struct Rev16Builder<const rdSET: bool, const rmSET: bool> {
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rmSET: bool> Rev16Builder<false, rmSET> {
        pub fn set_rd(mut self, rd: Register) -> Rev16Builder<true, rmSET> {
            self.rd = Some(rd);
            Rev16Builder {
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool> Rev16Builder<rdSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Rev16Builder<rdSET, true> {
            self.rm = Some(rm);
            Rev16Builder {
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl Rev16Builder<false, false> {
        pub fn new() -> Rev16Builder<false, false> {
            Rev16Builder { rd: None, rm: None }
        }
    }
    impl Rev16 {
        pub fn builder() -> Rev16Builder<false, false> {
            Rev16Builder { rd: None, rm: None }
        }
    }
    impl Rev16Builder<true, true> {
        pub fn complete(self) -> Rev16 {
            Rev16 {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Rev16Consumer<const rdSET: bool, const rmSET: bool> {
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rmCONSUMED: bool> Rev16Consumer<false, rmCONSUMED> {
        pub fn consume_rd(mut self) -> (Register, Rev16Consumer<true, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Rev16Consumer {
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl<const rdCONSUMED: bool> Rev16Consumer<rdCONSUMED, false> {
        pub fn consume_rm(mut self) -> (Register, Rev16Consumer<rdCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Rev16Consumer {
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl Rev16 {
        pub fn consumer(self) -> Rev16Consumer<false, false> {
            Rev16Consumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
            }
        }
    }
    impl Rev16Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Rev16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Rev16",
                "rd",
                &self.rd,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Rev16 {
        #[inline]
        fn clone(&self) -> Rev16 {
            Rev16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Rev16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Rev16 {
        #[inline]
        fn eq(&self, other: &Rev16) -> bool {
            self.rd == other.rd && self.rm == other.rm
        }
    }
    impl From<Rev16> for Operation {
        fn from(val: Rev16) -> Operation {
            Operation::Rev16(val)
        }
    }
    pub struct Revsh {
        pub rd: Register,
        pub rm: Register,
    }
    pub struct RevshBuilder<const rdSET: bool, const rmSET: bool> {
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rmSET: bool> RevshBuilder<false, rmSET> {
        pub fn set_rd(mut self, rd: Register) -> RevshBuilder<true, rmSET> {
            self.rd = Some(rd);
            RevshBuilder {
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool> RevshBuilder<rdSET, false> {
        pub fn set_rm(mut self, rm: Register) -> RevshBuilder<rdSET, true> {
            self.rm = Some(rm);
            RevshBuilder {
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl RevshBuilder<false, false> {
        pub fn new() -> RevshBuilder<false, false> {
            RevshBuilder { rd: None, rm: None }
        }
    }
    impl Revsh {
        pub fn builder() -> RevshBuilder<false, false> {
            RevshBuilder { rd: None, rm: None }
        }
    }
    impl RevshBuilder<true, true> {
        pub fn complete(self) -> Revsh {
            Revsh {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct RevshConsumer<const rdSET: bool, const rmSET: bool> {
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rmCONSUMED: bool> RevshConsumer<false, rmCONSUMED> {
        pub fn consume_rd(mut self) -> (Register, RevshConsumer<true, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                RevshConsumer {
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl<const rdCONSUMED: bool> RevshConsumer<rdCONSUMED, false> {
        pub fn consume_rm(mut self) -> (Register, RevshConsumer<rdCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                RevshConsumer {
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl Revsh {
        pub fn consumer(self) -> RevshConsumer<false, false> {
            RevshConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
            }
        }
    }
    impl RevshConsumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Revsh {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Revsh",
                "rd",
                &self.rd,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Revsh {
        #[inline]
        fn clone(&self) -> Revsh {
            Revsh {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Revsh {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Revsh {
        #[inline]
        fn eq(&self, other: &Revsh) -> bool {
            self.rd == other.rd && self.rm == other.rm
        }
    }
    impl From<Revsh> for Operation {
        fn from(val: Revsh) -> Operation {
            Operation::Revsh(val)
        }
    }
    pub struct RorImmediate {
        pub s: Option<bool>,
        pub rd: Register,
        pub rm: Register,
        pub imm: u32,
    }
    pub struct RorImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Register>,
        rm: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > RorImmediateBuilder<false, rdSET, rmSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> RorImmediateBuilder<true, rdSET, rmSET, immSET> {
            self.s = Some(s);
            RorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > RorImmediateBuilder<sSET, false, rmSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> RorImmediateBuilder<sSET, true, rmSET, immSET> {
            self.rd = Some(rd);
            RorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > RorImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> RorImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rm = Some(rm);
            RorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > RorImmediateBuilder<sSET, rdSET, rmSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> RorImmediateBuilder<sSET, rdSET, rmSET, true> {
            self.imm = Some(imm);
            RorImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                imm: self.imm,
            }
        }
    }
    impl RorImmediateBuilder<false, false, false, false> {
        pub fn new() -> RorImmediateBuilder<false, false, false, false> {
            RorImmediateBuilder {
                s: None,
                rd: None,
                rm: None,
                imm: None,
            }
        }
    }
    impl RorImmediate {
        pub fn builder() -> RorImmediateBuilder<false, false, false, false> {
            RorImmediateBuilder {
                s: None,
                rd: None,
                rm: None,
                imm: None,
            }
        }
    }
    impl RorImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> RorImmediate {
            RorImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct RorImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Register>,
        rm: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const immCONSUMED: bool,
    > RorImmediateConsumer<false, rdCONSUMED, rmCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            RorImmediateConsumer<true, rdCONSUMED, rmCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                RorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
        const immCONSUMED: bool,
    > RorImmediateConsumer<sCONSUMED, false, rmCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, RorImmediateConsumer<sCONSUMED, true, rmCONSUMED, immCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                RorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > RorImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, RorImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                RorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > RorImmediateConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, RorImmediateConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                RorImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    imm: self.imm,
                },
            )
        }
    }
    impl RorImmediate {
        pub fn consumer(self) -> RorImmediateConsumer<false, false, false, false> {
            RorImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
                imm: Some(self.imm),
            }
        }
    }
    impl RorImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RorImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "RorImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RorImmediate {
        #[inline]
        fn clone(&self) -> RorImmediate {
            RorImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RorImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RorImmediate {
        #[inline]
        fn eq(&self, other: &RorImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
                && self.imm == other.imm
        }
    }
    impl From<RorImmediate> for Operation {
        fn from(val: RorImmediate) -> Operation {
            Operation::RorImmediate(val)
        }
    }
    pub struct RorRegister {
        pub s: Option<SetFlags>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct RorRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > RorRegisterBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> RorRegisterBuilder<true, rdSET, rnSET, rmSET> {
            self.s = Some(s);
            RorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > RorRegisterBuilder<sSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> RorRegisterBuilder<sSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            RorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > RorRegisterBuilder<sSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> RorRegisterBuilder<sSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            RorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > RorRegisterBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> RorRegisterBuilder<sSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            RorRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl RorRegisterBuilder<false, false, false, false> {
        pub fn new() -> RorRegisterBuilder<false, false, false, false> {
            RorRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl RorRegister {
        pub fn builder() -> RorRegisterBuilder<false, false, false, false> {
            RorRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl RorRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> RorRegister {
            RorRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct RorRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > RorRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            RorRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                RorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > RorRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, RorRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                RorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > RorRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, RorRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                RorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > RorRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, RorRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                RorRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl RorRegister {
        pub fn consumer(self) -> RorRegisterConsumer<false, false, false, false> {
            RorRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl RorRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RorRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "RorRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RorRegister {
        #[inline]
        fn clone(&self) -> RorRegister {
            RorRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RorRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RorRegister {
        #[inline]
        fn eq(&self, other: &RorRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<RorRegister> for Operation {
        fn from(val: RorRegister) -> Operation {
            Operation::RorRegister(val)
        }
    }
    pub struct Rrx {
        pub s: Option<bool>,
        pub rd: Register,
        pub rm: Register,
    }
    pub struct RrxBuilder<const sSET: bool, const rdSET: bool, const rmSET: bool> {
        s: Option<Option<bool>>,
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rdSET: bool, const rmSET: bool> RrxBuilder<false, rdSET, rmSET> {
        pub fn set_s(mut self, s: Option<bool>) -> RrxBuilder<true, rdSET, rmSET> {
            self.s = Some(s);
            RrxBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl<const sSET: bool, const rmSET: bool> RrxBuilder<sSET, false, rmSET> {
        pub fn set_rd(mut self, rd: Register) -> RrxBuilder<sSET, true, rmSET> {
            self.rd = Some(rd);
            RrxBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl<const sSET: bool, const rdSET: bool> RrxBuilder<sSET, rdSET, false> {
        pub fn set_rm(mut self, rm: Register) -> RrxBuilder<sSET, rdSET, true> {
            self.rm = Some(rm);
            RrxBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
            }
        }
    }
    impl RrxBuilder<false, false, false> {
        pub fn new() -> RrxBuilder<false, false, false> {
            RrxBuilder {
                s: None,
                rd: None,
                rm: None,
            }
        }
    }
    impl Rrx {
        pub fn builder() -> RrxBuilder<false, false, false> {
            RrxBuilder {
                s: None,
                rd: None,
                rm: None,
            }
        }
    }
    impl RrxBuilder<true, true, true> {
        pub fn complete(self) -> Rrx {
            Rrx {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct RrxConsumer<const sSET: bool, const rdSET: bool, const rmSET: bool> {
        s: Option<Option<bool>>,
        rd: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > RrxConsumer<false, rdCONSUMED, rmCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (Option<bool>, RrxConsumer<true, rdCONSUMED, rmCONSUMED>) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                RrxConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
    > RrxConsumer<sCONSUMED, false, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, RrxConsumer<sCONSUMED, true, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                RrxConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
    > RrxConsumer<sCONSUMED, rdCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, RrxConsumer<sCONSUMED, rdCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                RrxConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                },
            )
        }
    }
    impl Rrx {
        pub fn consumer(self) -> RrxConsumer<false, false, false> {
            RrxConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
            }
        }
    }
    impl RrxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Rrx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Rrx",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Rrx {
        #[inline]
        fn clone(&self) -> Rrx {
            Rrx {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Rrx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Rrx {
        #[inline]
        fn eq(&self, other: &Rrx) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
        }
    }
    impl From<Rrx> for Operation {
        fn from(val: Rrx) -> Operation {
            Operation::Rrx(val)
        }
    }
    pub struct RsbImmediate {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct RsbImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > RsbImmediateBuilder<false, rdSET, rnSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> RsbImmediateBuilder<true, rdSET, rnSET, immSET> {
            self.s = Some(s);
            RsbImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > RsbImmediateBuilder<sSET, false, rnSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> RsbImmediateBuilder<sSET, true, rnSET, immSET> {
            self.rd = Some(rd);
            RsbImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > RsbImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> RsbImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rn = Some(rn);
            RsbImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > RsbImmediateBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> RsbImmediateBuilder<sSET, rdSET, rnSET, true> {
            self.imm = Some(imm);
            RsbImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl RsbImmediateBuilder<false, false, false, false> {
        pub fn new() -> RsbImmediateBuilder<false, false, false, false> {
            RsbImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl RsbImmediate {
        pub fn builder() -> RsbImmediateBuilder<false, false, false, false> {
            RsbImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl RsbImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> RsbImmediate {
            RsbImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct RsbImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > RsbImmediateConsumer<false, rdCONSUMED, rnCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            RsbImmediateConsumer<true, rdCONSUMED, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                RsbImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > RsbImmediateConsumer<sCONSUMED, false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            RsbImmediateConsumer<sCONSUMED, true, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                RsbImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > RsbImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, RsbImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                RsbImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > RsbImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, RsbImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                RsbImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl RsbImmediate {
        pub fn consumer(self) -> RsbImmediateConsumer<false, false, false, false> {
            RsbImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl RsbImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RsbImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "RsbImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RsbImmediate {
        #[inline]
        fn clone(&self) -> RsbImmediate {
            RsbImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RsbImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RsbImmediate {
        #[inline]
        fn eq(&self, other: &RsbImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.imm == other.imm
        }
    }
    impl From<RsbImmediate> for Operation {
        fn from(val: RsbImmediate) -> Operation {
            Operation::RsbImmediate(val)
        }
    }
    pub struct RsbRegister {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct RsbRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > RsbRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> RsbRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            RsbRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > RsbRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> RsbRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            RsbRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > RsbRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> RsbRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            RsbRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > RsbRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> RsbRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            RsbRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > RsbRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> RsbRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            RsbRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl RsbRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> RsbRegisterBuilder<false, false, false, false, false> {
            RsbRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl RsbRegister {
        pub fn builder() -> RsbRegisterBuilder<false, false, false, false, false> {
            RsbRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl RsbRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> RsbRegister {
            RsbRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct RsbRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > RsbRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            RsbRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                RsbRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > RsbRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            RsbRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                RsbRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > RsbRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            RsbRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                RsbRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > RsbRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            RsbRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                RsbRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > RsbRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            RsbRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                RsbRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl RsbRegister {
        pub fn consumer(self) -> RsbRegisterConsumer<false, false, false, false, false> {
            RsbRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl RsbRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RsbRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "RsbRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RsbRegister {
        #[inline]
        fn clone(&self) -> RsbRegister {
            RsbRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RsbRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RsbRegister {
        #[inline]
        fn eq(&self, other: &RsbRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<RsbRegister> for Operation {
        fn from(val: RsbRegister) -> Operation {
            Operation::RsbRegister(val)
        }
    }
    pub struct Sadd16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Sadd16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Sadd16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Sadd16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Sadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Sadd16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Sadd16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Sadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Sadd16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Sadd16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Sadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Sadd16Builder<false, false, false> {
        pub fn new() -> Sadd16Builder<false, false, false> {
            Sadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Sadd16 {
        pub fn builder() -> Sadd16Builder<false, false, false> {
            Sadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Sadd16Builder<true, true, true> {
        pub fn complete(self) -> Sadd16 {
            Sadd16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Sadd16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Sadd16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Sadd16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Sadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Sadd16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Sadd16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Sadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Sadd16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Sadd16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Sadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Sadd16 {
        pub fn consumer(self) -> Sadd16Consumer<false, false, false> {
            Sadd16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Sadd16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sadd16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Sadd16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sadd16 {
        #[inline]
        fn clone(&self) -> Sadd16 {
            Sadd16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sadd16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sadd16 {
        #[inline]
        fn eq(&self, other: &Sadd16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Sadd16> for Operation {
        fn from(val: Sadd16) -> Operation {
            Operation::Sadd16(val)
        }
    }
    pub struct Sadd8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Sadd8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Sadd8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Sadd8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Sadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Sadd8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Sadd8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Sadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Sadd8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Sadd8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Sadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Sadd8Builder<false, false, false> {
        pub fn new() -> Sadd8Builder<false, false, false> {
            Sadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Sadd8 {
        pub fn builder() -> Sadd8Builder<false, false, false> {
            Sadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Sadd8Builder<true, true, true> {
        pub fn complete(self) -> Sadd8 {
            Sadd8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Sadd8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Sadd8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Sadd8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Sadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Sadd8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Sadd8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Sadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Sadd8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Sadd8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Sadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Sadd8 {
        pub fn consumer(self) -> Sadd8Consumer<false, false, false> {
            Sadd8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Sadd8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sadd8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Sadd8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sadd8 {
        #[inline]
        fn clone(&self) -> Sadd8 {
            Sadd8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sadd8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sadd8 {
        #[inline]
        fn eq(&self, other: &Sadd8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Sadd8> for Operation {
        fn from(val: Sadd8) -> Operation {
            Operation::Sadd8(val)
        }
    }
    pub struct Sasx {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SasxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> SasxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SasxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            SasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> SasxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> SasxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            SasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> SasxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> SasxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            SasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SasxBuilder<false, false, false> {
        pub fn new() -> SasxBuilder<false, false, false> {
            SasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Sasx {
        pub fn builder() -> SasxBuilder<false, false, false> {
            SasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SasxBuilder<true, true, true> {
        pub fn complete(self) -> Sasx {
            Sasx {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SasxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SasxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, SasxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SasxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SasxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SasxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SasxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Sasx {
        pub fn consumer(self) -> SasxConsumer<false, false, false> {
            SasxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SasxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sasx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Sasx",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sasx {
        #[inline]
        fn clone(&self) -> Sasx {
            Sasx {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sasx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sasx {
        #[inline]
        fn eq(&self, other: &Sasx) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Sasx> for Operation {
        fn from(val: Sasx) -> Operation {
            Operation::Sasx(val)
        }
    }
    pub struct SbcImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct SbcImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > SbcImmediateBuilder<false, rdSET, rnSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> SbcImmediateBuilder<true, rdSET, rnSET, immSET> {
            self.s = Some(s);
            SbcImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > SbcImmediateBuilder<sSET, false, rnSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SbcImmediateBuilder<sSET, true, rnSET, immSET> {
            self.rd = Some(rd);
            SbcImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > SbcImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SbcImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rn = Some(rn);
            SbcImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > SbcImmediateBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> SbcImmediateBuilder<sSET, rdSET, rnSET, true> {
            self.imm = Some(imm);
            SbcImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl SbcImmediateBuilder<false, false, false, false> {
        pub fn new() -> SbcImmediateBuilder<false, false, false, false> {
            SbcImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl SbcImmediate {
        pub fn builder() -> SbcImmediateBuilder<false, false, false, false> {
            SbcImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl SbcImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> SbcImmediate {
            SbcImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct SbcImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > SbcImmediateConsumer<false, rdCONSUMED, rnCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            SbcImmediateConsumer<true, rdCONSUMED, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                SbcImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > SbcImmediateConsumer<sCONSUMED, false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SbcImmediateConsumer<sCONSUMED, true, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SbcImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > SbcImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SbcImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SbcImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SbcImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, SbcImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                SbcImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl SbcImmediate {
        pub fn consumer(self) -> SbcImmediateConsumer<false, false, false, false> {
            SbcImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl SbcImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SbcImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "SbcImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SbcImmediate {
        #[inline]
        fn clone(&self) -> SbcImmediate {
            SbcImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SbcImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SbcImmediate {
        #[inline]
        fn eq(&self, other: &SbcImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.imm == other.imm
        }
    }
    impl From<SbcImmediate> for Operation {
        fn from(val: SbcImmediate) -> Operation {
            Operation::SbcImmediate(val)
        }
    }
    pub struct SbcRegister {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct SbcRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > SbcRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> SbcRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            SbcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > SbcRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SbcRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            SbcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > SbcRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SbcRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            SbcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > SbcRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SbcRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            SbcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SbcRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> SbcRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            SbcRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl SbcRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> SbcRegisterBuilder<false, false, false, false, false> {
            SbcRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl SbcRegister {
        pub fn builder() -> SbcRegisterBuilder<false, false, false, false, false> {
            SbcRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl SbcRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> SbcRegister {
            SbcRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct SbcRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SbcRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            SbcRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                SbcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SbcRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SbcRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SbcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SbcRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SbcRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SbcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SbcRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SbcRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SbcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SbcRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            SbcRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                SbcRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl SbcRegister {
        pub fn consumer(self) -> SbcRegisterConsumer<false, false, false, false, false> {
            SbcRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl SbcRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SbcRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SbcRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SbcRegister {
        #[inline]
        fn clone(&self) -> SbcRegister {
            SbcRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SbcRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SbcRegister {
        #[inline]
        fn eq(&self, other: &SbcRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<SbcRegister> for Operation {
        fn from(val: SbcRegister) -> Operation {
            Operation::SbcRegister(val)
        }
    }
    pub struct Sbfx {
        pub rd: Register,
        pub rn: Register,
        pub lsb: u32,
        pub width: u32,
    }
    pub struct SbfxBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
        const widthSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        lsb: Option<u32>,
        width: Option<u32>,
    }
    impl<
        const rnSET: bool,
        const lsbSET: bool,
        const widthSET: bool,
    > SbfxBuilder<false, rnSET, lsbSET, widthSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SbfxBuilder<true, rnSET, lsbSET, widthSET> {
            self.rd = Some(rd);
            SbfxBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                width: self.width,
            }
        }
    }
    impl<
        const rdSET: bool,
        const lsbSET: bool,
        const widthSET: bool,
    > SbfxBuilder<rdSET, false, lsbSET, widthSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SbfxBuilder<rdSET, true, lsbSET, widthSET> {
            self.rn = Some(rn);
            SbfxBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                width: self.width,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const widthSET: bool,
    > SbfxBuilder<rdSET, rnSET, false, widthSET> {
        pub fn set_lsb(mut self, lsb: u32) -> SbfxBuilder<rdSET, rnSET, true, widthSET> {
            self.lsb = Some(lsb);
            SbfxBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                width: self.width,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
    > SbfxBuilder<rdSET, rnSET, lsbSET, false> {
        pub fn set_width(
            mut self,
            width: u32,
        ) -> SbfxBuilder<rdSET, rnSET, lsbSET, true> {
            self.width = Some(width);
            SbfxBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                width: self.width,
            }
        }
    }
    impl SbfxBuilder<false, false, false, false> {
        pub fn new() -> SbfxBuilder<false, false, false, false> {
            SbfxBuilder {
                rd: None,
                rn: None,
                lsb: None,
                width: None,
            }
        }
    }
    impl Sbfx {
        pub fn builder() -> SbfxBuilder<false, false, false, false> {
            SbfxBuilder {
                rd: None,
                rn: None,
                lsb: None,
                width: None,
            }
        }
    }
    impl SbfxBuilder<true, true, true, true> {
        pub fn complete(self) -> Sbfx {
            Sbfx {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                lsb: self.lsb.unwrap(),
                width: self.width.unwrap(),
            }
        }
    }
    pub struct SbfxConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
        const widthSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        lsb: Option<u32>,
        width: Option<u32>,
    }
    impl<
        const rnCONSUMED: bool,
        const lsbCONSUMED: bool,
        const widthCONSUMED: bool,
    > SbfxConsumer<false, rnCONSUMED, lsbCONSUMED, widthCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, SbfxConsumer<true, rnCONSUMED, lsbCONSUMED, widthCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SbfxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    width: self.width,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const lsbCONSUMED: bool,
        const widthCONSUMED: bool,
    > SbfxConsumer<rdCONSUMED, false, lsbCONSUMED, widthCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SbfxConsumer<rdCONSUMED, true, lsbCONSUMED, widthCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SbfxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    width: self.width,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const widthCONSUMED: bool,
    > SbfxConsumer<rdCONSUMED, rnCONSUMED, false, widthCONSUMED> {
        pub fn consume_lsb(
            mut self,
        ) -> (u32, SbfxConsumer<rdCONSUMED, rnCONSUMED, true, widthCONSUMED>) {
            let ret = self.lsb.unwrap();
            self.lsb = None;
            (
                ret,
                SbfxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    width: self.width,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const lsbCONSUMED: bool,
    > SbfxConsumer<rdCONSUMED, rnCONSUMED, lsbCONSUMED, false> {
        pub fn consume_width(
            mut self,
        ) -> (u32, SbfxConsumer<rdCONSUMED, rnCONSUMED, lsbCONSUMED, true>) {
            let ret = self.width.unwrap();
            self.width = None;
            (
                ret,
                SbfxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    width: self.width,
                },
            )
        }
    }
    impl Sbfx {
        pub fn consumer(self) -> SbfxConsumer<false, false, false, false> {
            SbfxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                lsb: Some(self.lsb),
                width: Some(self.width),
            }
        }
    }
    impl SbfxConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sbfx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Sbfx",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "lsb",
                &self.lsb,
                "width",
                &&self.width,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sbfx {
        #[inline]
        fn clone(&self) -> Sbfx {
            Sbfx {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                lsb: ::core::clone::Clone::clone(&self.lsb),
                width: ::core::clone::Clone::clone(&self.width),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sbfx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sbfx {
        #[inline]
        fn eq(&self, other: &Sbfx) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.lsb == other.lsb
                && self.width == other.width
        }
    }
    impl From<Sbfx> for Operation {
        fn from(val: Sbfx) -> Operation {
            Operation::Sbfx(val)
        }
    }
    pub struct Sdiv {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SdivBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> SdivBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SdivBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            SdivBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> SdivBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> SdivBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            SdivBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> SdivBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> SdivBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            SdivBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SdivBuilder<false, false, false> {
        pub fn new() -> SdivBuilder<false, false, false> {
            SdivBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Sdiv {
        pub fn builder() -> SdivBuilder<false, false, false> {
            SdivBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SdivBuilder<true, true, true> {
        pub fn complete(self) -> Sdiv {
            Sdiv {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SdivConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SdivConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, SdivConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SdivConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SdivConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SdivConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SdivConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SdivConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SdivConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SdivConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Sdiv {
        pub fn consumer(self) -> SdivConsumer<false, false, false> {
            SdivConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SdivConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sdiv {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Sdiv",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sdiv {
        #[inline]
        fn clone(&self) -> Sdiv {
            Sdiv {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sdiv {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sdiv {
        #[inline]
        fn eq(&self, other: &Sdiv) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Sdiv> for Operation {
        fn from(val: Sdiv) -> Operation {
            Operation::Sdiv(val)
        }
    }
    pub struct Sel {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SelBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> SelBuilder<false, rnSET, rmSET> {
        pub fn set_rd(mut self, rd: Option<Register>) -> SelBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            SelBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> SelBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> SelBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            SelBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> SelBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> SelBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            SelBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SelBuilder<false, false, false> {
        pub fn new() -> SelBuilder<false, false, false> {
            SelBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Sel {
        pub fn builder() -> SelBuilder<false, false, false> {
            SelBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SelBuilder<true, true, true> {
        pub fn complete(self) -> Sel {
            Sel {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SelConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SelConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, SelConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SelConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SelConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SelConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SelConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SelConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SelConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SelConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Sel {
        pub fn consumer(self) -> SelConsumer<false, false, false> {
            SelConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SelConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sel {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Sel",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sel {
        #[inline]
        fn clone(&self) -> Sel {
            Sel {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sel {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sel {
        #[inline]
        fn eq(&self, other: &Sel) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Sel> for Operation {
        fn from(val: Sel) -> Operation {
            Operation::Sel(val)
        }
    }
    pub struct Sev {}
    pub struct SevBuilder {}
    impl SevBuilder {
        pub fn new() -> SevBuilder {
            SevBuilder {}
        }
    }
    impl Sev {
        pub fn builder() -> SevBuilder {
            SevBuilder {}
        }
    }
    impl SevBuilder {
        pub fn complete(self) -> Sev {
            Sev {}
        }
    }
    pub struct SevConsumer {}
    impl Sev {
        pub fn consumer(self) -> SevConsumer {
            SevConsumer {}
        }
    }
    impl SevConsumer {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sev {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Sev")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sev {
        #[inline]
        fn clone(&self) -> Sev {
            Sev {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sev {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sev {
        #[inline]
        fn eq(&self, other: &Sev) -> bool {
            true
        }
    }
    impl From<Sev> for Operation {
        fn from(val: Sev) -> Operation {
            Operation::Sev(val)
        }
    }
    pub struct Svc {
        pub imm: u8,
    }
    pub struct SvcBuilder<const immSET: bool> {
        imm: Option<u8>,
    }
    impl SvcBuilder<false> {
        pub fn set_imm(mut self, imm: u8) -> SvcBuilder<true> {
            self.imm = Some(imm);
            SvcBuilder { imm: self.imm }
        }
    }
    impl SvcBuilder<false> {
        pub fn new() -> SvcBuilder<false> {
            SvcBuilder { imm: None }
        }
    }
    impl Svc {
        pub fn builder() -> SvcBuilder<false> {
            SvcBuilder { imm: None }
        }
    }
    impl SvcBuilder<true> {
        pub fn complete(self) -> Svc {
            Svc { imm: self.imm.unwrap() }
        }
    }
    pub struct SvcConsumer<const immSET: bool> {
        imm: Option<u8>,
    }
    impl SvcConsumer<false> {
        pub fn consume_imm(mut self) -> (u8, SvcConsumer<true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (ret, SvcConsumer { imm: self.imm })
        }
    }
    impl Svc {
        pub fn consumer(self) -> SvcConsumer<false> {
            SvcConsumer { imm: Some(self.imm) }
        }
    }
    impl SvcConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Svc {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Svc",
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Svc {
        #[inline]
        fn clone(&self) -> Svc {
            Svc {
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Svc {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Svc {
        #[inline]
        fn eq(&self, other: &Svc) -> bool {
            self.imm == other.imm
        }
    }
    impl From<Svc> for Operation {
        fn from(val: Svc) -> Operation {
            Operation::Svc(val)
        }
    }
    pub struct Shadd16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Shadd16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Shadd16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Shadd16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Shadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Shadd16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Shadd16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Shadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Shadd16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Shadd16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Shadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Shadd16Builder<false, false, false> {
        pub fn new() -> Shadd16Builder<false, false, false> {
            Shadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shadd16 {
        pub fn builder() -> Shadd16Builder<false, false, false> {
            Shadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shadd16Builder<true, true, true> {
        pub fn complete(self) -> Shadd16 {
            Shadd16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Shadd16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Shadd16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Shadd16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Shadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Shadd16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Shadd16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Shadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Shadd16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Shadd16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Shadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Shadd16 {
        pub fn consumer(self) -> Shadd16Consumer<false, false, false> {
            Shadd16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Shadd16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Shadd16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Shadd16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Shadd16 {
        #[inline]
        fn clone(&self) -> Shadd16 {
            Shadd16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Shadd16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Shadd16 {
        #[inline]
        fn eq(&self, other: &Shadd16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Shadd16> for Operation {
        fn from(val: Shadd16) -> Operation {
            Operation::Shadd16(val)
        }
    }
    pub struct Shadd8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Shadd8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Shadd8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Shadd8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Shadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Shadd8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Shadd8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Shadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Shadd8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Shadd8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Shadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Shadd8Builder<false, false, false> {
        pub fn new() -> Shadd8Builder<false, false, false> {
            Shadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shadd8 {
        pub fn builder() -> Shadd8Builder<false, false, false> {
            Shadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shadd8Builder<true, true, true> {
        pub fn complete(self) -> Shadd8 {
            Shadd8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Shadd8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Shadd8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Shadd8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Shadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Shadd8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Shadd8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Shadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Shadd8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Shadd8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Shadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Shadd8 {
        pub fn consumer(self) -> Shadd8Consumer<false, false, false> {
            Shadd8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Shadd8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Shadd8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Shadd8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Shadd8 {
        #[inline]
        fn clone(&self) -> Shadd8 {
            Shadd8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Shadd8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Shadd8 {
        #[inline]
        fn eq(&self, other: &Shadd8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Shadd8> for Operation {
        fn from(val: Shadd8) -> Operation {
            Operation::Shadd8(val)
        }
    }
    pub struct Shasx {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct ShasxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> ShasxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> ShasxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            ShasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> ShasxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> ShasxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            ShasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> ShasxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> ShasxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            ShasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl ShasxBuilder<false, false, false> {
        pub fn new() -> ShasxBuilder<false, false, false> {
            ShasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shasx {
        pub fn builder() -> ShasxBuilder<false, false, false> {
            ShasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl ShasxBuilder<true, true, true> {
        pub fn complete(self) -> Shasx {
            Shasx {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct ShasxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > ShasxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, ShasxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                ShasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > ShasxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, ShasxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                ShasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > ShasxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, ShasxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                ShasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Shasx {
        pub fn consumer(self) -> ShasxConsumer<false, false, false> {
            ShasxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl ShasxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Shasx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Shasx",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Shasx {
        #[inline]
        fn clone(&self) -> Shasx {
            Shasx {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Shasx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Shasx {
        #[inline]
        fn eq(&self, other: &Shasx) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Shasx> for Operation {
        fn from(val: Shasx) -> Operation {
            Operation::Shasx(val)
        }
    }
    pub struct Shsax {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct ShsaxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> ShsaxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> ShsaxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            ShsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> ShsaxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> ShsaxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            ShsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> ShsaxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> ShsaxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            ShsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl ShsaxBuilder<false, false, false> {
        pub fn new() -> ShsaxBuilder<false, false, false> {
            ShsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shsax {
        pub fn builder() -> ShsaxBuilder<false, false, false> {
            ShsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl ShsaxBuilder<true, true, true> {
        pub fn complete(self) -> Shsax {
            Shsax {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct ShsaxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > ShsaxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, ShsaxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                ShsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > ShsaxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, ShsaxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                ShsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > ShsaxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, ShsaxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                ShsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Shsax {
        pub fn consumer(self) -> ShsaxConsumer<false, false, false> {
            ShsaxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl ShsaxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Shsax {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Shsax",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Shsax {
        #[inline]
        fn clone(&self) -> Shsax {
            Shsax {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Shsax {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Shsax {
        #[inline]
        fn eq(&self, other: &Shsax) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Shsax> for Operation {
        fn from(val: Shsax) -> Operation {
            Operation::Shsax(val)
        }
    }
    pub struct Shsub16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Shsub16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Shsub16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Shsub16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Shsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Shsub16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Shsub16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Shsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Shsub16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Shsub16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Shsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Shsub16Builder<false, false, false> {
        pub fn new() -> Shsub16Builder<false, false, false> {
            Shsub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shsub16 {
        pub fn builder() -> Shsub16Builder<false, false, false> {
            Shsub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shsub16Builder<true, true, true> {
        pub fn complete(self) -> Shsub16 {
            Shsub16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Shsub16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Shsub16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Shsub16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Shsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Shsub16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Shsub16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Shsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Shsub16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Shsub16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Shsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Shsub16 {
        pub fn consumer(self) -> Shsub16Consumer<false, false, false> {
            Shsub16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Shsub16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Shsub16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Shsub16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Shsub16 {
        #[inline]
        fn clone(&self) -> Shsub16 {
            Shsub16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Shsub16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Shsub16 {
        #[inline]
        fn eq(&self, other: &Shsub16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Shsub16> for Operation {
        fn from(val: Shsub16) -> Operation {
            Operation::Shsub16(val)
        }
    }
    pub struct Shsub8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Shsub8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Shsub8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Shsub8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Shsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Shsub8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Shsub8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Shsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Shsub8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Shsub8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Shsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Shsub8Builder<false, false, false> {
        pub fn new() -> Shsub8Builder<false, false, false> {
            Shsub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shsub8 {
        pub fn builder() -> Shsub8Builder<false, false, false> {
            Shsub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Shsub8Builder<true, true, true> {
        pub fn complete(self) -> Shsub8 {
            Shsub8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Shsub8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Shsub8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Shsub8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Shsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Shsub8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Shsub8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Shsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Shsub8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Shsub8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Shsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Shsub8 {
        pub fn consumer(self) -> Shsub8Consumer<false, false, false> {
            Shsub8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Shsub8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Shsub8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Shsub8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Shsub8 {
        #[inline]
        fn clone(&self) -> Shsub8 {
            Shsub8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Shsub8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Shsub8 {
        #[inline]
        fn eq(&self, other: &Shsub8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Shsub8> for Operation {
        fn from(val: Shsub8) -> Operation {
            Operation::Shsub8(val)
        }
    }
    pub struct Smla {
        pub n_high: bool,
        pub m_high: bool,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct SmlaBuilder<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        n_high: Option<bool>,
        m_high: Option<bool>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlaBuilder<false, m_highSET, rdSET, rnSET, rmSET, raSET> {
        pub fn set_n_high(
            mut self,
            n_high: bool,
        ) -> SmlaBuilder<true, m_highSET, rdSET, rnSET, rmSET, raSET> {
            self.n_high = Some(n_high);
            SmlaBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlaBuilder<n_highSET, false, rdSET, rnSET, rmSET, raSET> {
        pub fn set_m_high(
            mut self,
            m_high: bool,
        ) -> SmlaBuilder<n_highSET, true, rdSET, rnSET, rmSET, raSET> {
            self.m_high = Some(m_high);
            SmlaBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlaBuilder<n_highSET, m_highSET, false, rnSET, rmSET, raSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SmlaBuilder<n_highSET, m_highSET, true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            SmlaBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlaBuilder<n_highSET, m_highSET, rdSET, false, rmSET, raSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmlaBuilder<n_highSET, m_highSET, rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            SmlaBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > SmlaBuilder<n_highSET, m_highSET, rdSET, rnSET, false, raSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmlaBuilder<n_highSET, m_highSET, rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            SmlaBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlaBuilder<n_highSET, m_highSET, rdSET, rnSET, rmSET, false> {
        pub fn set_ra(
            mut self,
            ra: Register,
        ) -> SmlaBuilder<n_highSET, m_highSET, rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            SmlaBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl SmlaBuilder<false, false, false, false, false, false> {
        pub fn new() -> SmlaBuilder<false, false, false, false, false, false> {
            SmlaBuilder {
                n_high: None,
                m_high: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Smla {
        pub fn builder() -> SmlaBuilder<false, false, false, false, false, false> {
            SmlaBuilder {
                n_high: None,
                m_high: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl SmlaBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> Smla {
            Smla {
                n_high: self.n_high.unwrap(),
                m_high: self.m_high.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct SmlaConsumer<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        n_high: Option<bool>,
        m_high: Option<bool>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlaConsumer<
        false,
        m_highCONSUMED,
        rdCONSUMED,
        rnCONSUMED,
        rmCONSUMED,
        raCONSUMED,
    > {
        pub fn consume_n_high(
            mut self,
        ) -> (
            bool,
            SmlaConsumer<
                true,
                m_highCONSUMED,
                rdCONSUMED,
                rnCONSUMED,
                rmCONSUMED,
                raCONSUMED,
            >,
        ) {
            let ret = self.n_high.unwrap();
            self.n_high = None;
            (
                ret,
                SmlaConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlaConsumer<
        n_highCONSUMED,
        false,
        rdCONSUMED,
        rnCONSUMED,
        rmCONSUMED,
        raCONSUMED,
    > {
        pub fn consume_m_high(
            mut self,
        ) -> (
            bool,
            SmlaConsumer<
                n_highCONSUMED,
                true,
                rdCONSUMED,
                rnCONSUMED,
                rmCONSUMED,
                raCONSUMED,
            >,
        ) {
            let ret = self.m_high.unwrap();
            self.m_high = None;
            (
                ret,
                SmlaConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlaConsumer<
        n_highCONSUMED,
        m_highCONSUMED,
        false,
        rnCONSUMED,
        rmCONSUMED,
        raCONSUMED,
    > {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            SmlaConsumer<
                n_highCONSUMED,
                m_highCONSUMED,
                true,
                rnCONSUMED,
                rmCONSUMED,
                raCONSUMED,
            >,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmlaConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlaConsumer<
        n_highCONSUMED,
        m_highCONSUMED,
        rdCONSUMED,
        false,
        rmCONSUMED,
        raCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmlaConsumer<
                n_highCONSUMED,
                m_highCONSUMED,
                rdCONSUMED,
                true,
                rmCONSUMED,
                raCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmlaConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlaConsumer<
        n_highCONSUMED,
        m_highCONSUMED,
        rdCONSUMED,
        rnCONSUMED,
        false,
        raCONSUMED,
    > {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmlaConsumer<
                n_highCONSUMED,
                m_highCONSUMED,
                rdCONSUMED,
                rnCONSUMED,
                true,
                raCONSUMED,
            >,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmlaConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlaConsumer<
        n_highCONSUMED,
        m_highCONSUMED,
        rdCONSUMED,
        rnCONSUMED,
        rmCONSUMED,
        false,
    > {
        pub fn consume_ra(
            mut self,
        ) -> (
            Register,
            SmlaConsumer<
                n_highCONSUMED,
                m_highCONSUMED,
                rdCONSUMED,
                rnCONSUMED,
                rmCONSUMED,
                true,
            >,
        ) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                SmlaConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Smla {
        pub fn consumer(self) -> SmlaConsumer<false, false, false, false, false, false> {
            SmlaConsumer {
                n_high: Some(self.n_high),
                m_high: Some(self.m_high),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl SmlaConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smla {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["n_high", "m_high", "rd", "rn", "rm", "ra"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.n_high,
                &self.m_high,
                &self.rd,
                &self.rn,
                &self.rm,
                &&self.ra,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Smla", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smla {
        #[inline]
        fn clone(&self) -> Smla {
            Smla {
                n_high: ::core::clone::Clone::clone(&self.n_high),
                m_high: ::core::clone::Clone::clone(&self.m_high),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smla {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smla {
        #[inline]
        fn eq(&self, other: &Smla) -> bool {
            self.n_high == other.n_high && self.m_high == other.m_high
                && self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.ra == other.ra
        }
    }
    impl From<Smla> for Operation {
        fn from(val: Smla) -> Operation {
            Operation::Smla(val)
        }
    }
    pub struct Smlad {
        pub x: Option<bool>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct SmladBuilder<
        const xSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        x: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmladBuilder<false, rdSET, rnSET, rmSET, raSET> {
        pub fn set_x(
            mut self,
            x: Option<bool>,
        ) -> SmladBuilder<true, rdSET, rnSET, rmSET, raSET> {
            self.x = Some(x);
            SmladBuilder {
                x: self.x,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const xSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmladBuilder<xSET, false, rnSET, rmSET, raSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SmladBuilder<xSET, true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            SmladBuilder {
                x: self.x,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const xSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmladBuilder<xSET, rdSET, false, rmSET, raSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmladBuilder<xSET, rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            SmladBuilder {
                x: self.x,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const xSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > SmladBuilder<xSET, rdSET, rnSET, false, raSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmladBuilder<xSET, rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            SmladBuilder {
                x: self.x,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const xSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmladBuilder<xSET, rdSET, rnSET, rmSET, false> {
        pub fn set_ra(
            mut self,
            ra: Register,
        ) -> SmladBuilder<xSET, rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            SmladBuilder {
                x: self.x,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl SmladBuilder<false, false, false, false, false> {
        pub fn new() -> SmladBuilder<false, false, false, false, false> {
            SmladBuilder {
                x: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Smlad {
        pub fn builder() -> SmladBuilder<false, false, false, false, false> {
            SmladBuilder {
                x: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl SmladBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Smlad {
            Smlad {
                x: self.x.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct SmladConsumer<
        const xSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        x: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmladConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_x(
            mut self,
        ) -> (
            Option<bool>,
            SmladConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.x.unwrap();
            self.x = None;
            (
                ret,
                SmladConsumer {
                    x: self.x,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const xCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmladConsumer<xCONSUMED, false, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            SmladConsumer<xCONSUMED, true, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmladConsumer {
                    x: self.x,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const xCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmladConsumer<xCONSUMED, rdCONSUMED, false, rmCONSUMED, raCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmladConsumer<xCONSUMED, rdCONSUMED, true, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmladConsumer {
                    x: self.x,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const xCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > SmladConsumer<xCONSUMED, rdCONSUMED, rnCONSUMED, false, raCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmladConsumer<xCONSUMED, rdCONSUMED, rnCONSUMED, true, raCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmladConsumer {
                    x: self.x,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const xCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmladConsumer<xCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_ra(
            mut self,
        ) -> (
            Register,
            SmladConsumer<xCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                SmladConsumer {
                    x: self.x,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Smlad {
        pub fn consumer(self) -> SmladConsumer<false, false, false, false, false> {
            SmladConsumer {
                x: Some(self.x),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl SmladConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smlad {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Smlad",
                "x",
                &self.x,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "ra",
                &&self.ra,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smlad {
        #[inline]
        fn clone(&self) -> Smlad {
            Smlad {
                x: ::core::clone::Clone::clone(&self.x),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smlad {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smlad {
        #[inline]
        fn eq(&self, other: &Smlad) -> bool {
            self.x == other.x && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.ra == other.ra
        }
    }
    impl From<Smlad> for Operation {
        fn from(val: Smlad) -> Operation {
            Operation::Smlad(val)
        }
    }
    pub struct Smlal {
        pub rdlo: Register,
        pub rdhi: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmlalBuilder<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlalBuilder<false, rdhiSET, rnSET, rmSET> {
        pub fn set_rdlo(
            mut self,
            rdlo: Register,
        ) -> SmlalBuilder<true, rdhiSET, rnSET, rmSET> {
            self.rdlo = Some(rdlo);
            SmlalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlalBuilder<rdloSET, false, rnSET, rmSET> {
        pub fn set_rdhi(
            mut self,
            rdhi: Register,
        ) -> SmlalBuilder<rdloSET, true, rnSET, rmSET> {
            self.rdhi = Some(rdhi);
            SmlalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rmSET: bool,
    > SmlalBuilder<rdloSET, rdhiSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmlalBuilder<rdloSET, rdhiSET, true, rmSET> {
            self.rn = Some(rn);
            SmlalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
    > SmlalBuilder<rdloSET, rdhiSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmlalBuilder<rdloSET, rdhiSET, rnSET, true> {
            self.rm = Some(rm);
            SmlalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmlalBuilder<false, false, false, false> {
        pub fn new() -> SmlalBuilder<false, false, false, false> {
            SmlalBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smlal {
        pub fn builder() -> SmlalBuilder<false, false, false, false> {
            SmlalBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmlalBuilder<true, true, true, true> {
        pub fn complete(self) -> Smlal {
            Smlal {
                rdlo: self.rdlo.unwrap(),
                rdhi: self.rdhi.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmlalConsumer<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlalConsumer<false, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdlo(
            mut self,
        ) -> (Register, SmlalConsumer<true, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdlo.unwrap();
            self.rdlo = None;
            (
                ret,
                SmlalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlalConsumer<rdloCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdhi(
            mut self,
        ) -> (Register, SmlalConsumer<rdloCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdhi.unwrap();
            self.rdhi = None;
            (
                ret,
                SmlalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlalConsumer<rdloCONSUMED, rdhiCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SmlalConsumer<rdloCONSUMED, rdhiCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmlalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmlalConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SmlalConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmlalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smlal {
        pub fn consumer(self) -> SmlalConsumer<false, false, false, false> {
            SmlalConsumer {
                rdlo: Some(self.rdlo),
                rdhi: Some(self.rdhi),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmlalConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smlal {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Smlal",
                "rdlo",
                &self.rdlo,
                "rdhi",
                &self.rdhi,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smlal {
        #[inline]
        fn clone(&self) -> Smlal {
            Smlal {
                rdlo: ::core::clone::Clone::clone(&self.rdlo),
                rdhi: ::core::clone::Clone::clone(&self.rdhi),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smlal {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smlal {
        #[inline]
        fn eq(&self, other: &Smlal) -> bool {
            self.rdlo == other.rdlo && self.rdhi == other.rdhi && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Smlal> for Operation {
        fn from(val: Smlal) -> Operation {
            Operation::Smlal(val)
        }
    }
    pub struct SmlalSelective {
        pub n_high: bool,
        pub m_high: bool,
        pub rdlo: Register,
        pub rdhi: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmlalSelectiveBuilder<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        n_high: Option<bool>,
        m_high: Option<bool>,
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const m_highSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlalSelectiveBuilder<false, m_highSET, rdloSET, rdhiSET, rnSET, rmSET> {
        pub fn set_n_high(
            mut self,
            n_high: bool,
        ) -> SmlalSelectiveBuilder<true, m_highSET, rdloSET, rdhiSET, rnSET, rmSET> {
            self.n_high = Some(n_high);
            SmlalSelectiveBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlalSelectiveBuilder<n_highSET, false, rdloSET, rdhiSET, rnSET, rmSET> {
        pub fn set_m_high(
            mut self,
            m_high: bool,
        ) -> SmlalSelectiveBuilder<n_highSET, true, rdloSET, rdhiSET, rnSET, rmSET> {
            self.m_high = Some(m_high);
            SmlalSelectiveBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlalSelectiveBuilder<n_highSET, m_highSET, false, rdhiSET, rnSET, rmSET> {
        pub fn set_rdlo(
            mut self,
            rdlo: Register,
        ) -> SmlalSelectiveBuilder<n_highSET, m_highSET, true, rdhiSET, rnSET, rmSET> {
            self.rdlo = Some(rdlo);
            SmlalSelectiveBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdloSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlalSelectiveBuilder<n_highSET, m_highSET, rdloSET, false, rnSET, rmSET> {
        pub fn set_rdhi(
            mut self,
            rdhi: Register,
        ) -> SmlalSelectiveBuilder<n_highSET, m_highSET, rdloSET, true, rnSET, rmSET> {
            self.rdhi = Some(rdhi);
            SmlalSelectiveBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rmSET: bool,
    > SmlalSelectiveBuilder<n_highSET, m_highSET, rdloSET, rdhiSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmlalSelectiveBuilder<n_highSET, m_highSET, rdloSET, rdhiSET, true, rmSET> {
            self.rn = Some(rn);
            SmlalSelectiveBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
    > SmlalSelectiveBuilder<n_highSET, m_highSET, rdloSET, rdhiSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmlalSelectiveBuilder<n_highSET, m_highSET, rdloSET, rdhiSET, rnSET, true> {
            self.rm = Some(rm);
            SmlalSelectiveBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmlalSelectiveBuilder<false, false, false, false, false, false> {
        pub fn new() -> SmlalSelectiveBuilder<false, false, false, false, false, false> {
            SmlalSelectiveBuilder {
                n_high: None,
                m_high: None,
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmlalSelective {
        pub fn builder() -> SmlalSelectiveBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            SmlalSelectiveBuilder {
                n_high: None,
                m_high: None,
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmlalSelectiveBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> SmlalSelective {
            SmlalSelective {
                n_high: self.n_high.unwrap(),
                m_high: self.m_high.unwrap(),
                rdlo: self.rdlo.unwrap(),
                rdhi: self.rdhi.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmlalSelectiveConsumer<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        n_high: Option<bool>,
        m_high: Option<bool>,
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const m_highCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlalSelectiveConsumer<
        false,
        m_highCONSUMED,
        rdloCONSUMED,
        rdhiCONSUMED,
        rnCONSUMED,
        rmCONSUMED,
    > {
        pub fn consume_n_high(
            mut self,
        ) -> (
            bool,
            SmlalSelectiveConsumer<
                true,
                m_highCONSUMED,
                rdloCONSUMED,
                rdhiCONSUMED,
                rnCONSUMED,
                rmCONSUMED,
            >,
        ) {
            let ret = self.n_high.unwrap();
            self.n_high = None;
            (
                ret,
                SmlalSelectiveConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlalSelectiveConsumer<
        n_highCONSUMED,
        false,
        rdloCONSUMED,
        rdhiCONSUMED,
        rnCONSUMED,
        rmCONSUMED,
    > {
        pub fn consume_m_high(
            mut self,
        ) -> (
            bool,
            SmlalSelectiveConsumer<
                n_highCONSUMED,
                true,
                rdloCONSUMED,
                rdhiCONSUMED,
                rnCONSUMED,
                rmCONSUMED,
            >,
        ) {
            let ret = self.m_high.unwrap();
            self.m_high = None;
            (
                ret,
                SmlalSelectiveConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlalSelectiveConsumer<
        n_highCONSUMED,
        m_highCONSUMED,
        false,
        rdhiCONSUMED,
        rnCONSUMED,
        rmCONSUMED,
    > {
        pub fn consume_rdlo(
            mut self,
        ) -> (
            Register,
            SmlalSelectiveConsumer<
                n_highCONSUMED,
                m_highCONSUMED,
                true,
                rdhiCONSUMED,
                rnCONSUMED,
                rmCONSUMED,
            >,
        ) {
            let ret = self.rdlo.unwrap();
            self.rdlo = None;
            (
                ret,
                SmlalSelectiveConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlalSelectiveConsumer<
        n_highCONSUMED,
        m_highCONSUMED,
        rdloCONSUMED,
        false,
        rnCONSUMED,
        rmCONSUMED,
    > {
        pub fn consume_rdhi(
            mut self,
        ) -> (
            Register,
            SmlalSelectiveConsumer<
                n_highCONSUMED,
                m_highCONSUMED,
                rdloCONSUMED,
                true,
                rnCONSUMED,
                rmCONSUMED,
            >,
        ) {
            let ret = self.rdhi.unwrap();
            self.rdhi = None;
            (
                ret,
                SmlalSelectiveConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlalSelectiveConsumer<
        n_highCONSUMED,
        m_highCONSUMED,
        rdloCONSUMED,
        rdhiCONSUMED,
        false,
        rmCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmlalSelectiveConsumer<
                n_highCONSUMED,
                m_highCONSUMED,
                rdloCONSUMED,
                rdhiCONSUMED,
                true,
                rmCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmlalSelectiveConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmlalSelectiveConsumer<
        n_highCONSUMED,
        m_highCONSUMED,
        rdloCONSUMED,
        rdhiCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmlalSelectiveConsumer<
                n_highCONSUMED,
                m_highCONSUMED,
                rdloCONSUMED,
                rdhiCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmlalSelectiveConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl SmlalSelective {
        pub fn consumer(
            self,
        ) -> SmlalSelectiveConsumer<false, false, false, false, false, false> {
            SmlalSelectiveConsumer {
                n_high: Some(self.n_high),
                m_high: Some(self.m_high),
                rdlo: Some(self.rdlo),
                rdhi: Some(self.rdhi),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmlalSelectiveConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SmlalSelective {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["n_high", "m_high", "rdlo", "rdhi", "rn", "rm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.n_high,
                &self.m_high,
                &self.rdlo,
                &self.rdhi,
                &self.rn,
                &&self.rm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "SmlalSelective",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SmlalSelective {
        #[inline]
        fn clone(&self) -> SmlalSelective {
            SmlalSelective {
                n_high: ::core::clone::Clone::clone(&self.n_high),
                m_high: ::core::clone::Clone::clone(&self.m_high),
                rdlo: ::core::clone::Clone::clone(&self.rdlo),
                rdhi: ::core::clone::Clone::clone(&self.rdhi),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SmlalSelective {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SmlalSelective {
        #[inline]
        fn eq(&self, other: &SmlalSelective) -> bool {
            self.n_high == other.n_high && self.m_high == other.m_high
                && self.rdlo == other.rdlo && self.rdhi == other.rdhi
                && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<SmlalSelective> for Operation {
        fn from(val: SmlalSelective) -> Operation {
            Operation::SmlalSelective(val)
        }
    }
    pub struct Smlald {
        pub x: Option<bool>,
        pub rdlo: Register,
        pub rdhi: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmlaldBuilder<
        const xSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        x: Option<Option<bool>>,
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlaldBuilder<false, rdloSET, rdhiSET, rnSET, rmSET> {
        pub fn set_x(
            mut self,
            x: Option<bool>,
        ) -> SmlaldBuilder<true, rdloSET, rdhiSET, rnSET, rmSET> {
            self.x = Some(x);
            SmlaldBuilder {
                x: self.x,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const xSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlaldBuilder<xSET, false, rdhiSET, rnSET, rmSET> {
        pub fn set_rdlo(
            mut self,
            rdlo: Register,
        ) -> SmlaldBuilder<xSET, true, rdhiSET, rnSET, rmSET> {
            self.rdlo = Some(rdlo);
            SmlaldBuilder {
                x: self.x,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const xSET: bool,
        const rdloSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlaldBuilder<xSET, rdloSET, false, rnSET, rmSET> {
        pub fn set_rdhi(
            mut self,
            rdhi: Register,
        ) -> SmlaldBuilder<xSET, rdloSET, true, rnSET, rmSET> {
            self.rdhi = Some(rdhi);
            SmlaldBuilder {
                x: self.x,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const xSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rmSET: bool,
    > SmlaldBuilder<xSET, rdloSET, rdhiSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmlaldBuilder<xSET, rdloSET, rdhiSET, true, rmSET> {
            self.rn = Some(rn);
            SmlaldBuilder {
                x: self.x,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const xSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
    > SmlaldBuilder<xSET, rdloSET, rdhiSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmlaldBuilder<xSET, rdloSET, rdhiSET, rnSET, true> {
            self.rm = Some(rm);
            SmlaldBuilder {
                x: self.x,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmlaldBuilder<false, false, false, false, false> {
        pub fn new() -> SmlaldBuilder<false, false, false, false, false> {
            SmlaldBuilder {
                x: None,
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smlald {
        pub fn builder() -> SmlaldBuilder<false, false, false, false, false> {
            SmlaldBuilder {
                x: None,
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmlaldBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Smlald {
            Smlald {
                x: self.x.unwrap(),
                rdlo: self.rdlo.unwrap(),
                rdhi: self.rdhi.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmlaldConsumer<
        const xSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        x: Option<Option<bool>>,
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlaldConsumer<false, rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_x(
            mut self,
        ) -> (
            Option<bool>,
            SmlaldConsumer<true, rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.x.unwrap();
            self.x = None;
            (
                ret,
                SmlaldConsumer {
                    x: self.x,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const xCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlaldConsumer<xCONSUMED, false, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdlo(
            mut self,
        ) -> (
            Register,
            SmlaldConsumer<xCONSUMED, true, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.rdlo.unwrap();
            self.rdlo = None;
            (
                ret,
                SmlaldConsumer {
                    x: self.x,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const xCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlaldConsumer<xCONSUMED, rdloCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdhi(
            mut self,
        ) -> (
            Register,
            SmlaldConsumer<xCONSUMED, rdloCONSUMED, true, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.rdhi.unwrap();
            self.rdhi = None;
            (
                ret,
                SmlaldConsumer {
                    x: self.x,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const xCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlaldConsumer<xCONSUMED, rdloCONSUMED, rdhiCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmlaldConsumer<xCONSUMED, rdloCONSUMED, rdhiCONSUMED, true, rmCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmlaldConsumer {
                    x: self.x,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const xCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmlaldConsumer<xCONSUMED, rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmlaldConsumer<xCONSUMED, rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, true>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmlaldConsumer {
                    x: self.x,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smlald {
        pub fn consumer(self) -> SmlaldConsumer<false, false, false, false, false> {
            SmlaldConsumer {
                x: Some(self.x),
                rdlo: Some(self.rdlo),
                rdhi: Some(self.rdhi),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmlaldConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smlald {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Smlald",
                "x",
                &self.x,
                "rdlo",
                &self.rdlo,
                "rdhi",
                &self.rdhi,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smlald {
        #[inline]
        fn clone(&self) -> Smlald {
            Smlald {
                x: ::core::clone::Clone::clone(&self.x),
                rdlo: ::core::clone::Clone::clone(&self.rdlo),
                rdhi: ::core::clone::Clone::clone(&self.rdhi),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smlald {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smlald {
        #[inline]
        fn eq(&self, other: &Smlald) -> bool {
            self.x == other.x && self.rdlo == other.rdlo && self.rdhi == other.rdhi
                && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Smlald> for Operation {
        fn from(val: Smlald) -> Operation {
            Operation::Smlald(val)
        }
    }
    pub struct Smlaw {
        pub m_high: bool,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct SmlawBuilder<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        m_high: Option<bool>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlawBuilder<false, rdSET, rnSET, rmSET, raSET> {
        pub fn set_m_high(
            mut self,
            m_high: bool,
        ) -> SmlawBuilder<true, rdSET, rnSET, rmSET, raSET> {
            self.m_high = Some(m_high);
            SmlawBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const m_highSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlawBuilder<m_highSET, false, rnSET, rmSET, raSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SmlawBuilder<m_highSET, true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            SmlawBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const m_highSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlawBuilder<m_highSET, rdSET, false, rmSET, raSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmlawBuilder<m_highSET, rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            SmlawBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > SmlawBuilder<m_highSET, rdSET, rnSET, false, raSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmlawBuilder<m_highSET, rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            SmlawBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlawBuilder<m_highSET, rdSET, rnSET, rmSET, false> {
        pub fn set_ra(
            mut self,
            ra: Register,
        ) -> SmlawBuilder<m_highSET, rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            SmlawBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl SmlawBuilder<false, false, false, false, false> {
        pub fn new() -> SmlawBuilder<false, false, false, false, false> {
            SmlawBuilder {
                m_high: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Smlaw {
        pub fn builder() -> SmlawBuilder<false, false, false, false, false> {
            SmlawBuilder {
                m_high: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl SmlawBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Smlaw {
            Smlaw {
                m_high: self.m_high.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct SmlawConsumer<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        m_high: Option<bool>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlawConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_m_high(
            mut self,
        ) -> (
            bool,
            SmlawConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.m_high.unwrap();
            self.m_high = None;
            (
                ret,
                SmlawConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const m_highCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlawConsumer<m_highCONSUMED, false, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            SmlawConsumer<m_highCONSUMED, true, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmlawConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlawConsumer<m_highCONSUMED, rdCONSUMED, false, rmCONSUMED, raCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmlawConsumer<m_highCONSUMED, rdCONSUMED, true, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmlawConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlawConsumer<m_highCONSUMED, rdCONSUMED, rnCONSUMED, false, raCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmlawConsumer<m_highCONSUMED, rdCONSUMED, rnCONSUMED, true, raCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmlawConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlawConsumer<m_highCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_ra(
            mut self,
        ) -> (
            Register,
            SmlawConsumer<m_highCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                SmlawConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Smlaw {
        pub fn consumer(self) -> SmlawConsumer<false, false, false, false, false> {
            SmlawConsumer {
                m_high: Some(self.m_high),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl SmlawConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smlaw {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Smlaw",
                "m_high",
                &self.m_high,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "ra",
                &&self.ra,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smlaw {
        #[inline]
        fn clone(&self) -> Smlaw {
            Smlaw {
                m_high: ::core::clone::Clone::clone(&self.m_high),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smlaw {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smlaw {
        #[inline]
        fn eq(&self, other: &Smlaw) -> bool {
            self.m_high == other.m_high && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.ra == other.ra
        }
    }
    impl From<Smlaw> for Operation {
        fn from(val: Smlaw) -> Operation {
            Operation::Smlaw(val)
        }
    }
    pub struct Smlsd {
        pub m_swap: Option<bool>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct SmlsdBuilder<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        m_swap: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlsdBuilder<false, rdSET, rnSET, rmSET, raSET> {
        pub fn set_m_swap(
            mut self,
            m_swap: Option<bool>,
        ) -> SmlsdBuilder<true, rdSET, rnSET, rmSET, raSET> {
            self.m_swap = Some(m_swap);
            SmlsdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlsdBuilder<m_swapSET, false, rnSET, rmSET, raSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SmlsdBuilder<m_swapSET, true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            SmlsdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmlsdBuilder<m_swapSET, rdSET, false, rmSET, raSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmlsdBuilder<m_swapSET, rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            SmlsdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > SmlsdBuilder<m_swapSET, rdSET, rnSET, false, raSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmlsdBuilder<m_swapSET, rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            SmlsdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlsdBuilder<m_swapSET, rdSET, rnSET, rmSET, false> {
        pub fn set_ra(
            mut self,
            ra: Register,
        ) -> SmlsdBuilder<m_swapSET, rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            SmlsdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl SmlsdBuilder<false, false, false, false, false> {
        pub fn new() -> SmlsdBuilder<false, false, false, false, false> {
            SmlsdBuilder {
                m_swap: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Smlsd {
        pub fn builder() -> SmlsdBuilder<false, false, false, false, false> {
            SmlsdBuilder {
                m_swap: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl SmlsdBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Smlsd {
            Smlsd {
                m_swap: self.m_swap.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct SmlsdConsumer<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        m_swap: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlsdConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_m_swap(
            mut self,
        ) -> (
            Option<bool>,
            SmlsdConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.m_swap.unwrap();
            self.m_swap = None;
            (
                ret,
                SmlsdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlsdConsumer<m_swapCONSUMED, false, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            SmlsdConsumer<m_swapCONSUMED, true, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmlsdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlsdConsumer<m_swapCONSUMED, rdCONSUMED, false, rmCONSUMED, raCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmlsdConsumer<m_swapCONSUMED, rdCONSUMED, true, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmlsdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > SmlsdConsumer<m_swapCONSUMED, rdCONSUMED, rnCONSUMED, false, raCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmlsdConsumer<m_swapCONSUMED, rdCONSUMED, rnCONSUMED, true, raCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmlsdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlsdConsumer<m_swapCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_ra(
            mut self,
        ) -> (
            Register,
            SmlsdConsumer<m_swapCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                SmlsdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Smlsd {
        pub fn consumer(self) -> SmlsdConsumer<false, false, false, false, false> {
            SmlsdConsumer {
                m_swap: Some(self.m_swap),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl SmlsdConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smlsd {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Smlsd",
                "m_swap",
                &self.m_swap,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "ra",
                &&self.ra,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smlsd {
        #[inline]
        fn clone(&self) -> Smlsd {
            Smlsd {
                m_swap: ::core::clone::Clone::clone(&self.m_swap),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smlsd {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smlsd {
        #[inline]
        fn eq(&self, other: &Smlsd) -> bool {
            self.m_swap == other.m_swap && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.ra == other.ra
        }
    }
    impl From<Smlsd> for Operation {
        fn from(val: Smlsd) -> Operation {
            Operation::Smlsd(val)
        }
    }
    pub struct Smlsld {
        pub m_swap: Option<bool>,
        pub rdlo: Register,
        pub rdhi: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmlsldBuilder<
        const m_swapSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        m_swap: Option<Option<bool>>,
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlsldBuilder<false, rdloSET, rdhiSET, rnSET, rmSET> {
        pub fn set_m_swap(
            mut self,
            m_swap: Option<bool>,
        ) -> SmlsldBuilder<true, rdloSET, rdhiSET, rnSET, rmSET> {
            self.m_swap = Some(m_swap);
            SmlsldBuilder {
                m_swap: self.m_swap,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlsldBuilder<m_swapSET, false, rdhiSET, rnSET, rmSET> {
        pub fn set_rdlo(
            mut self,
            rdlo: Register,
        ) -> SmlsldBuilder<m_swapSET, true, rdhiSET, rnSET, rmSET> {
            self.rdlo = Some(rdlo);
            SmlsldBuilder {
                m_swap: self.m_swap,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdloSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmlsldBuilder<m_swapSET, rdloSET, false, rnSET, rmSET> {
        pub fn set_rdhi(
            mut self,
            rdhi: Register,
        ) -> SmlsldBuilder<m_swapSET, rdloSET, true, rnSET, rmSET> {
            self.rdhi = Some(rdhi);
            SmlsldBuilder {
                m_swap: self.m_swap,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rmSET: bool,
    > SmlsldBuilder<m_swapSET, rdloSET, rdhiSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmlsldBuilder<m_swapSET, rdloSET, rdhiSET, true, rmSET> {
            self.rn = Some(rn);
            SmlsldBuilder {
                m_swap: self.m_swap,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
    > SmlsldBuilder<m_swapSET, rdloSET, rdhiSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmlsldBuilder<m_swapSET, rdloSET, rdhiSET, rnSET, true> {
            self.rm = Some(rm);
            SmlsldBuilder {
                m_swap: self.m_swap,
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmlsldBuilder<false, false, false, false, false> {
        pub fn new() -> SmlsldBuilder<false, false, false, false, false> {
            SmlsldBuilder {
                m_swap: None,
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smlsld {
        pub fn builder() -> SmlsldBuilder<false, false, false, false, false> {
            SmlsldBuilder {
                m_swap: None,
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmlsldBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Smlsld {
            Smlsld {
                m_swap: self.m_swap.unwrap(),
                rdlo: self.rdlo.unwrap(),
                rdhi: self.rdhi.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmlsldConsumer<
        const m_swapSET: bool,
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        m_swap: Option<Option<bool>>,
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlsldConsumer<false, rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_m_swap(
            mut self,
        ) -> (
            Option<bool>,
            SmlsldConsumer<true, rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.m_swap.unwrap();
            self.m_swap = None;
            (
                ret,
                SmlsldConsumer {
                    m_swap: self.m_swap,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlsldConsumer<m_swapCONSUMED, false, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdlo(
            mut self,
        ) -> (
            Register,
            SmlsldConsumer<m_swapCONSUMED, true, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.rdlo.unwrap();
            self.rdlo = None;
            (
                ret,
                SmlsldConsumer {
                    m_swap: self.m_swap,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlsldConsumer<m_swapCONSUMED, rdloCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdhi(
            mut self,
        ) -> (
            Register,
            SmlsldConsumer<m_swapCONSUMED, rdloCONSUMED, true, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.rdhi.unwrap();
            self.rdhi = None;
            (
                ret,
                SmlsldConsumer {
                    m_swap: self.m_swap,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmlsldConsumer<m_swapCONSUMED, rdloCONSUMED, rdhiCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmlsldConsumer<m_swapCONSUMED, rdloCONSUMED, rdhiCONSUMED, true, rmCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmlsldConsumer {
                    m_swap: self.m_swap,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmlsldConsumer<m_swapCONSUMED, rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmlsldConsumer<m_swapCONSUMED, rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, true>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmlsldConsumer {
                    m_swap: self.m_swap,
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smlsld {
        pub fn consumer(self) -> SmlsldConsumer<false, false, false, false, false> {
            SmlsldConsumer {
                m_swap: Some(self.m_swap),
                rdlo: Some(self.rdlo),
                rdhi: Some(self.rdhi),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmlsldConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smlsld {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Smlsld",
                "m_swap",
                &self.m_swap,
                "rdlo",
                &self.rdlo,
                "rdhi",
                &self.rdhi,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smlsld {
        #[inline]
        fn clone(&self) -> Smlsld {
            Smlsld {
                m_swap: ::core::clone::Clone::clone(&self.m_swap),
                rdlo: ::core::clone::Clone::clone(&self.rdlo),
                rdhi: ::core::clone::Clone::clone(&self.rdhi),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smlsld {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smlsld {
        #[inline]
        fn eq(&self, other: &Smlsld) -> bool {
            self.m_swap == other.m_swap && self.rdlo == other.rdlo
                && self.rdhi == other.rdhi && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Smlsld> for Operation {
        fn from(val: Smlsld) -> Operation {
            Operation::Smlsld(val)
        }
    }
    pub struct Smmla {
        pub round: Option<bool>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct SmmlaBuilder<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        round: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmmlaBuilder<false, rdSET, rnSET, rmSET, raSET> {
        pub fn set_round(
            mut self,
            round: Option<bool>,
        ) -> SmmlaBuilder<true, rdSET, rnSET, rmSET, raSET> {
            self.round = Some(round);
            SmmlaBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmmlaBuilder<roundSET, false, rnSET, rmSET, raSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SmmlaBuilder<roundSET, true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            SmmlaBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmmlaBuilder<roundSET, rdSET, false, rmSET, raSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmmlaBuilder<roundSET, rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            SmmlaBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > SmmlaBuilder<roundSET, rdSET, rnSET, false, raSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmmlaBuilder<roundSET, rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            SmmlaBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmmlaBuilder<roundSET, rdSET, rnSET, rmSET, false> {
        pub fn set_ra(
            mut self,
            ra: Register,
        ) -> SmmlaBuilder<roundSET, rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            SmmlaBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl SmmlaBuilder<false, false, false, false, false> {
        pub fn new() -> SmmlaBuilder<false, false, false, false, false> {
            SmmlaBuilder {
                round: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Smmla {
        pub fn builder() -> SmmlaBuilder<false, false, false, false, false> {
            SmmlaBuilder {
                round: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl SmmlaBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Smmla {
            Smmla {
                round: self.round.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct SmmlaConsumer<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        round: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmmlaConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_round(
            mut self,
        ) -> (
            Option<bool>,
            SmmlaConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.round.unwrap();
            self.round = None;
            (
                ret,
                SmmlaConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmmlaConsumer<roundCONSUMED, false, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            SmmlaConsumer<roundCONSUMED, true, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmmlaConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmmlaConsumer<roundCONSUMED, rdCONSUMED, false, rmCONSUMED, raCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmmlaConsumer<roundCONSUMED, rdCONSUMED, true, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmmlaConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > SmmlaConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, false, raCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmmlaConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, true, raCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmmlaConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmmlaConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_ra(
            mut self,
        ) -> (
            Register,
            SmmlaConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                SmmlaConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Smmla {
        pub fn consumer(self) -> SmmlaConsumer<false, false, false, false, false> {
            SmmlaConsumer {
                round: Some(self.round),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl SmmlaConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smmla {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Smmla",
                "round",
                &self.round,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "ra",
                &&self.ra,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smmla {
        #[inline]
        fn clone(&self) -> Smmla {
            Smmla {
                round: ::core::clone::Clone::clone(&self.round),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smmla {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smmla {
        #[inline]
        fn eq(&self, other: &Smmla) -> bool {
            self.round == other.round && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.ra == other.ra
        }
    }
    impl From<Smmla> for Operation {
        fn from(val: Smmla) -> Operation {
            Operation::Smmla(val)
        }
    }
    pub struct Smmls {
        pub round: Option<bool>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct SmmlsBuilder<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        round: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmmlsBuilder<false, rdSET, rnSET, rmSET, raSET> {
        pub fn set_round(
            mut self,
            round: Option<bool>,
        ) -> SmmlsBuilder<true, rdSET, rnSET, rmSET, raSET> {
            self.round = Some(round);
            SmmlsBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmmlsBuilder<roundSET, false, rnSET, rmSET, raSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SmmlsBuilder<roundSET, true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            SmmlsBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > SmmlsBuilder<roundSET, rdSET, false, rmSET, raSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmmlsBuilder<roundSET, rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            SmmlsBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > SmmlsBuilder<roundSET, rdSET, rnSET, false, raSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmmlsBuilder<roundSET, rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            SmmlsBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmmlsBuilder<roundSET, rdSET, rnSET, rmSET, false> {
        pub fn set_ra(
            mut self,
            ra: Register,
        ) -> SmmlsBuilder<roundSET, rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            SmmlsBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl SmmlsBuilder<false, false, false, false, false> {
        pub fn new() -> SmmlsBuilder<false, false, false, false, false> {
            SmmlsBuilder {
                round: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Smmls {
        pub fn builder() -> SmmlsBuilder<false, false, false, false, false> {
            SmmlsBuilder {
                round: None,
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl SmmlsBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Smmls {
            Smmls {
                round: self.round.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct SmmlsConsumer<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        round: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmmlsConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_round(
            mut self,
        ) -> (
            Option<bool>,
            SmmlsConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.round.unwrap();
            self.round = None;
            (
                ret,
                SmmlsConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmmlsConsumer<roundCONSUMED, false, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Register,
            SmmlsConsumer<roundCONSUMED, true, rnCONSUMED, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmmlsConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > SmmlsConsumer<roundCONSUMED, rdCONSUMED, false, rmCONSUMED, raCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmmlsConsumer<roundCONSUMED, rdCONSUMED, true, rmCONSUMED, raCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmmlsConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > SmmlsConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, false, raCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmmlsConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, true, raCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmmlsConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmmlsConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_ra(
            mut self,
        ) -> (
            Register,
            SmmlsConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                SmmlsConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Smmls {
        pub fn consumer(self) -> SmmlsConsumer<false, false, false, false, false> {
            SmmlsConsumer {
                round: Some(self.round),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl SmmlsConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smmls {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Smmls",
                "round",
                &self.round,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "ra",
                &&self.ra,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smmls {
        #[inline]
        fn clone(&self) -> Smmls {
            Smmls {
                round: ::core::clone::Clone::clone(&self.round),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smmls {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smmls {
        #[inline]
        fn eq(&self, other: &Smmls) -> bool {
            self.round == other.round && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.ra == other.ra
        }
    }
    impl From<Smmls> for Operation {
        fn from(val: Smmls) -> Operation {
            Operation::Smmls(val)
        }
    }
    pub struct Smmul {
        pub round: Option<bool>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmmulBuilder<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        round: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmmulBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_round(
            mut self,
            round: Option<bool>,
        ) -> SmmulBuilder<true, rdSET, rnSET, rmSET> {
            self.round = Some(round);
            SmmulBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmmulBuilder<roundSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SmmulBuilder<roundSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            SmmulBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > SmmulBuilder<roundSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmmulBuilder<roundSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            SmmulBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > SmmulBuilder<roundSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmmulBuilder<roundSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            SmmulBuilder {
                round: self.round,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmmulBuilder<false, false, false, false> {
        pub fn new() -> SmmulBuilder<false, false, false, false> {
            SmmulBuilder {
                round: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smmul {
        pub fn builder() -> SmmulBuilder<false, false, false, false> {
            SmmulBuilder {
                round: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmmulBuilder<true, true, true, true> {
        pub fn complete(self) -> Smmul {
            Smmul {
                round: self.round.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmmulConsumer<
        const roundSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        round: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmmulConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_round(
            mut self,
        ) -> (Option<bool>, SmmulConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.round.unwrap();
            self.round = None;
            (
                ret,
                SmmulConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmmulConsumer<roundCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, SmmulConsumer<roundCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmmulConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmmulConsumer<roundCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SmmulConsumer<roundCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmmulConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const roundCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmmulConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SmmulConsumer<roundCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmmulConsumer {
                    round: self.round,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smmul {
        pub fn consumer(self) -> SmmulConsumer<false, false, false, false> {
            SmmulConsumer {
                round: Some(self.round),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmmulConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smmul {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Smmul",
                "round",
                &self.round,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smmul {
        #[inline]
        fn clone(&self) -> Smmul {
            Smmul {
                round: ::core::clone::Clone::clone(&self.round),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smmul {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smmul {
        #[inline]
        fn eq(&self, other: &Smmul) -> bool {
            self.round == other.round && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Smmul> for Operation {
        fn from(val: Smmul) -> Operation {
            Operation::Smmul(val)
        }
    }
    pub struct Smuad {
        pub m_swap: Option<bool>,
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmuadBuilder<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        m_swap: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmuadBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_m_swap(
            mut self,
            m_swap: Option<bool>,
        ) -> SmuadBuilder<true, rdSET, rnSET, rmSET> {
            self.m_swap = Some(m_swap);
            SmuadBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmuadBuilder<m_swapSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SmuadBuilder<m_swapSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            SmuadBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > SmuadBuilder<m_swapSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmuadBuilder<m_swapSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            SmuadBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > SmuadBuilder<m_swapSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmuadBuilder<m_swapSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            SmuadBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmuadBuilder<false, false, false, false> {
        pub fn new() -> SmuadBuilder<false, false, false, false> {
            SmuadBuilder {
                m_swap: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smuad {
        pub fn builder() -> SmuadBuilder<false, false, false, false> {
            SmuadBuilder {
                m_swap: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmuadBuilder<true, true, true, true> {
        pub fn complete(self) -> Smuad {
            Smuad {
                m_swap: self.m_swap.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmuadConsumer<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        m_swap: Option<Option<bool>>,
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmuadConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_m_swap(
            mut self,
        ) -> (Option<bool>, SmuadConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.m_swap.unwrap();
            self.m_swap = None;
            (
                ret,
                SmuadConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmuadConsumer<m_swapCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, SmuadConsumer<m_swapCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmuadConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmuadConsumer<m_swapCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SmuadConsumer<m_swapCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmuadConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmuadConsumer<m_swapCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SmuadConsumer<m_swapCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmuadConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smuad {
        pub fn consumer(self) -> SmuadConsumer<false, false, false, false> {
            SmuadConsumer {
                m_swap: Some(self.m_swap),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmuadConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smuad {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Smuad",
                "m_swap",
                &self.m_swap,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smuad {
        #[inline]
        fn clone(&self) -> Smuad {
            Smuad {
                m_swap: ::core::clone::Clone::clone(&self.m_swap),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smuad {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smuad {
        #[inline]
        fn eq(&self, other: &Smuad) -> bool {
            self.m_swap == other.m_swap && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Smuad> for Operation {
        fn from(val: Smuad) -> Operation {
            Operation::Smuad(val)
        }
    }
    pub struct Smul {
        pub n_high: bool,
        pub m_high: bool,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmulBuilder<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        n_high: Option<bool>,
        m_high: Option<bool>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmulBuilder<false, m_highSET, rdSET, rnSET, rmSET> {
        pub fn set_n_high(
            mut self,
            n_high: bool,
        ) -> SmulBuilder<true, m_highSET, rdSET, rnSET, rmSET> {
            self.n_high = Some(n_high);
            SmulBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmulBuilder<n_highSET, false, rdSET, rnSET, rmSET> {
        pub fn set_m_high(
            mut self,
            m_high: bool,
        ) -> SmulBuilder<n_highSET, true, rdSET, rnSET, rmSET> {
            self.m_high = Some(m_high);
            SmulBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmulBuilder<n_highSET, m_highSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SmulBuilder<n_highSET, m_highSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            SmulBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > SmulBuilder<n_highSET, m_highSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmulBuilder<n_highSET, m_highSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            SmulBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > SmulBuilder<n_highSET, m_highSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmulBuilder<n_highSET, m_highSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            SmulBuilder {
                n_high: self.n_high,
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmulBuilder<false, false, false, false, false> {
        pub fn new() -> SmulBuilder<false, false, false, false, false> {
            SmulBuilder {
                n_high: None,
                m_high: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smul {
        pub fn builder() -> SmulBuilder<false, false, false, false, false> {
            SmulBuilder {
                n_high: None,
                m_high: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmulBuilder<true, true, true, true, true> {
        pub fn complete(self) -> Smul {
            Smul {
                n_high: self.n_high.unwrap(),
                m_high: self.m_high.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmulConsumer<
        const n_highSET: bool,
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        n_high: Option<bool>,
        m_high: Option<bool>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmulConsumer<false, m_highCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_n_high(
            mut self,
        ) -> (
            bool,
            SmulConsumer<true, m_highCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.n_high.unwrap();
            self.n_high = None;
            (
                ret,
                SmulConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmulConsumer<n_highCONSUMED, false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_m_high(
            mut self,
        ) -> (
            bool,
            SmulConsumer<n_highCONSUMED, true, rdCONSUMED, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.m_high.unwrap();
            self.m_high = None;
            (
                ret,
                SmulConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmulConsumer<n_highCONSUMED, m_highCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SmulConsumer<n_highCONSUMED, m_highCONSUMED, true, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmulConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmulConsumer<n_highCONSUMED, m_highCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SmulConsumer<n_highCONSUMED, m_highCONSUMED, rdCONSUMED, true, rmCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmulConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const n_highCONSUMED: bool,
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmulConsumer<n_highCONSUMED, m_highCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SmulConsumer<n_highCONSUMED, m_highCONSUMED, rdCONSUMED, rnCONSUMED, true>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmulConsumer {
                    n_high: self.n_high,
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smul {
        pub fn consumer(self) -> SmulConsumer<false, false, false, false, false> {
            SmulConsumer {
                n_high: Some(self.n_high),
                m_high: Some(self.m_high),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmulConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smul {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Smul",
                "n_high",
                &self.n_high,
                "m_high",
                &self.m_high,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smul {
        #[inline]
        fn clone(&self) -> Smul {
            Smul {
                n_high: ::core::clone::Clone::clone(&self.n_high),
                m_high: ::core::clone::Clone::clone(&self.m_high),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smul {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smul {
        #[inline]
        fn eq(&self, other: &Smul) -> bool {
            self.n_high == other.n_high && self.m_high == other.m_high
                && self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Smul> for Operation {
        fn from(val: Smul) -> Operation {
            Operation::Smul(val)
        }
    }
    pub struct Smull {
        pub rdlo: Register,
        pub rdhi: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmullBuilder<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmullBuilder<false, rdhiSET, rnSET, rmSET> {
        pub fn set_rdlo(
            mut self,
            rdlo: Register,
        ) -> SmullBuilder<true, rdhiSET, rnSET, rmSET> {
            self.rdlo = Some(rdlo);
            SmullBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmullBuilder<rdloSET, false, rnSET, rmSET> {
        pub fn set_rdhi(
            mut self,
            rdhi: Register,
        ) -> SmullBuilder<rdloSET, true, rnSET, rmSET> {
            self.rdhi = Some(rdhi);
            SmullBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rmSET: bool,
    > SmullBuilder<rdloSET, rdhiSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmullBuilder<rdloSET, rdhiSET, true, rmSET> {
            self.rn = Some(rn);
            SmullBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
    > SmullBuilder<rdloSET, rdhiSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmullBuilder<rdloSET, rdhiSET, rnSET, true> {
            self.rm = Some(rm);
            SmullBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmullBuilder<false, false, false, false> {
        pub fn new() -> SmullBuilder<false, false, false, false> {
            SmullBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smull {
        pub fn builder() -> SmullBuilder<false, false, false, false> {
            SmullBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmullBuilder<true, true, true, true> {
        pub fn complete(self) -> Smull {
            Smull {
                rdlo: self.rdlo.unwrap(),
                rdhi: self.rdhi.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmullConsumer<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmullConsumer<false, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdlo(
            mut self,
        ) -> (Register, SmullConsumer<true, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdlo.unwrap();
            self.rdlo = None;
            (
                ret,
                SmullConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmullConsumer<rdloCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdhi(
            mut self,
        ) -> (Register, SmullConsumer<rdloCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdhi.unwrap();
            self.rdhi = None;
            (
                ret,
                SmullConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmullConsumer<rdloCONSUMED, rdhiCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SmullConsumer<rdloCONSUMED, rdhiCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmullConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmullConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SmullConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmullConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smull {
        pub fn consumer(self) -> SmullConsumer<false, false, false, false> {
            SmullConsumer {
                rdlo: Some(self.rdlo),
                rdhi: Some(self.rdhi),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmullConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smull {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Smull",
                "rdlo",
                &self.rdlo,
                "rdhi",
                &self.rdhi,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smull {
        #[inline]
        fn clone(&self) -> Smull {
            Smull {
                rdlo: ::core::clone::Clone::clone(&self.rdlo),
                rdhi: ::core::clone::Clone::clone(&self.rdhi),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smull {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smull {
        #[inline]
        fn eq(&self, other: &Smull) -> bool {
            self.rdlo == other.rdlo && self.rdhi == other.rdhi && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Smull> for Operation {
        fn from(val: Smull) -> Operation {
            Operation::Smull(val)
        }
    }
    pub struct Smulw {
        pub m_high: bool,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmulwBuilder<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        m_high: Option<bool>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmulwBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_m_high(
            mut self,
            m_high: bool,
        ) -> SmulwBuilder<true, rdSET, rnSET, rmSET> {
            self.m_high = Some(m_high);
            SmulwBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_highSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmulwBuilder<m_highSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SmulwBuilder<m_highSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            SmulwBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_highSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > SmulwBuilder<m_highSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmulwBuilder<m_highSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            SmulwBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > SmulwBuilder<m_highSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmulwBuilder<m_highSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            SmulwBuilder {
                m_high: self.m_high,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmulwBuilder<false, false, false, false> {
        pub fn new() -> SmulwBuilder<false, false, false, false> {
            SmulwBuilder {
                m_high: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smulw {
        pub fn builder() -> SmulwBuilder<false, false, false, false> {
            SmulwBuilder {
                m_high: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmulwBuilder<true, true, true, true> {
        pub fn complete(self) -> Smulw {
            Smulw {
                m_high: self.m_high.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmulwConsumer<
        const m_highSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        m_high: Option<bool>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmulwConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_m_high(
            mut self,
        ) -> (bool, SmulwConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.m_high.unwrap();
            self.m_high = None;
            (
                ret,
                SmulwConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_highCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmulwConsumer<m_highCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SmulwConsumer<m_highCONSUMED, true, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmulwConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmulwConsumer<m_highCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SmulwConsumer<m_highCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmulwConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_highCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmulwConsumer<m_highCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SmulwConsumer<m_highCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmulwConsumer {
                    m_high: self.m_high,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smulw {
        pub fn consumer(self) -> SmulwConsumer<false, false, false, false> {
            SmulwConsumer {
                m_high: Some(self.m_high),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmulwConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smulw {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Smulw",
                "m_high",
                &self.m_high,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smulw {
        #[inline]
        fn clone(&self) -> Smulw {
            Smulw {
                m_high: ::core::clone::Clone::clone(&self.m_high),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smulw {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smulw {
        #[inline]
        fn eq(&self, other: &Smulw) -> bool {
            self.m_high == other.m_high && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Smulw> for Operation {
        fn from(val: Smulw) -> Operation {
            Operation::Smulw(val)
        }
    }
    pub struct Smusd {
        pub m_swap: Option<bool>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SmusdBuilder<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        m_swap: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmusdBuilder<false, rdSET, rnSET, rmSET> {
        pub fn set_m_swap(
            mut self,
            m_swap: Option<bool>,
        ) -> SmusdBuilder<true, rdSET, rnSET, rmSET> {
            self.m_swap = Some(m_swap);
            SmusdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SmusdBuilder<m_swapSET, false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SmusdBuilder<m_swapSET, true, rnSET, rmSET> {
            self.rd = Some(rd);
            SmusdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > SmusdBuilder<m_swapSET, rdSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SmusdBuilder<m_swapSET, rdSET, true, rmSET> {
            self.rn = Some(rn);
            SmusdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > SmusdBuilder<m_swapSET, rdSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SmusdBuilder<m_swapSET, rdSET, rnSET, true> {
            self.rm = Some(rm);
            SmusdBuilder {
                m_swap: self.m_swap,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SmusdBuilder<false, false, false, false> {
        pub fn new() -> SmusdBuilder<false, false, false, false> {
            SmusdBuilder {
                m_swap: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Smusd {
        pub fn builder() -> SmusdBuilder<false, false, false, false> {
            SmusdBuilder {
                m_swap: None,
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SmusdBuilder<true, true, true, true> {
        pub fn complete(self) -> Smusd {
            Smusd {
                m_swap: self.m_swap.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SmusdConsumer<
        const m_swapSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        m_swap: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmusdConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_m_swap(
            mut self,
        ) -> (Option<bool>, SmusdConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.m_swap.unwrap();
            self.m_swap = None;
            (
                ret,
                SmusdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmusdConsumer<m_swapCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SmusdConsumer<m_swapCONSUMED, true, rnCONSUMED, rmCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SmusdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SmusdConsumer<m_swapCONSUMED, rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SmusdConsumer<m_swapCONSUMED, rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SmusdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const m_swapCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SmusdConsumer<m_swapCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SmusdConsumer<m_swapCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SmusdConsumer {
                    m_swap: self.m_swap,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Smusd {
        pub fn consumer(self) -> SmusdConsumer<false, false, false, false> {
            SmusdConsumer {
                m_swap: Some(self.m_swap),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SmusdConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Smusd {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Smusd",
                "m_swap",
                &self.m_swap,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Smusd {
        #[inline]
        fn clone(&self) -> Smusd {
            Smusd {
                m_swap: ::core::clone::Clone::clone(&self.m_swap),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Smusd {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Smusd {
        #[inline]
        fn eq(&self, other: &Smusd) -> bool {
            self.m_swap == other.m_swap && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Smusd> for Operation {
        fn from(val: Smusd) -> Operation {
            Operation::Smusd(val)
        }
    }
    pub struct Ssat {
        pub rd: Register,
        pub imm: u32,
        pub rn: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct SsatBuilder<
        const rdSET: bool,
        const immSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > {
        rd: Option<Register>,
        imm: Option<u32>,
        rn: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const immSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > SsatBuilder<false, immSET, rnSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> SsatBuilder<true, immSET, rnSET, shiftSET> {
            self.rd = Some(rd);
            SsatBuilder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
                shift: self.shift,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > SsatBuilder<rdSET, false, rnSET, shiftSET> {
        pub fn set_imm(mut self, imm: u32) -> SsatBuilder<rdSET, true, rnSET, shiftSET> {
            self.imm = Some(imm);
            SsatBuilder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
                shift: self.shift,
            }
        }
    }
    impl<
        const rdSET: bool,
        const immSET: bool,
        const shiftSET: bool,
    > SsatBuilder<rdSET, immSET, false, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SsatBuilder<rdSET, immSET, true, shiftSET> {
            self.rn = Some(rn);
            SsatBuilder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
                shift: self.shift,
            }
        }
    }
    impl<
        const rdSET: bool,
        const immSET: bool,
        const rnSET: bool,
    > SsatBuilder<rdSET, immSET, rnSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> SsatBuilder<rdSET, immSET, rnSET, true> {
            self.shift = Some(shift);
            SsatBuilder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
                shift: self.shift,
            }
        }
    }
    impl SsatBuilder<false, false, false, false> {
        pub fn new() -> SsatBuilder<false, false, false, false> {
            SsatBuilder {
                rd: None,
                imm: None,
                rn: None,
                shift: None,
            }
        }
    }
    impl Ssat {
        pub fn builder() -> SsatBuilder<false, false, false, false> {
            SsatBuilder {
                rd: None,
                imm: None,
                rn: None,
                shift: None,
            }
        }
    }
    impl SsatBuilder<true, true, true, true> {
        pub fn complete(self) -> Ssat {
            Ssat {
                rd: self.rd.unwrap(),
                imm: self.imm.unwrap(),
                rn: self.rn.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct SsatConsumer<
        const rdSET: bool,
        const immSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > {
        rd: Option<Register>,
        imm: Option<u32>,
        rn: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const immCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SsatConsumer<false, immCONSUMED, rnCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, SsatConsumer<true, immCONSUMED, rnCONSUMED, shiftCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SsatConsumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SsatConsumer<rdCONSUMED, false, rnCONSUMED, shiftCONSUMED> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, SsatConsumer<rdCONSUMED, true, rnCONSUMED, shiftCONSUMED>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                SsatConsumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SsatConsumer<rdCONSUMED, immCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SsatConsumer<rdCONSUMED, immCONSUMED, true, shiftCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SsatConsumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
        const rnCONSUMED: bool,
    > SsatConsumer<rdCONSUMED, immCONSUMED, rnCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            SsatConsumer<rdCONSUMED, immCONSUMED, rnCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                SsatConsumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                    shift: self.shift,
                },
            )
        }
    }
    impl Ssat {
        pub fn consumer(self) -> SsatConsumer<false, false, false, false> {
            SsatConsumer {
                rd: Some(self.rd),
                imm: Some(self.imm),
                rn: Some(self.rn),
                shift: Some(self.shift),
            }
        }
    }
    impl SsatConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ssat {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Ssat",
                "rd",
                &self.rd,
                "imm",
                &self.imm,
                "rn",
                &self.rn,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ssat {
        #[inline]
        fn clone(&self) -> Ssat {
            Ssat {
                rd: ::core::clone::Clone::clone(&self.rd),
                imm: ::core::clone::Clone::clone(&self.imm),
                rn: ::core::clone::Clone::clone(&self.rn),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ssat {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ssat {
        #[inline]
        fn eq(&self, other: &Ssat) -> bool {
            self.rd == other.rd && self.imm == other.imm && self.rn == other.rn
                && self.shift == other.shift
        }
    }
    impl From<Ssat> for Operation {
        fn from(val: Ssat) -> Operation {
            Operation::Ssat(val)
        }
    }
    pub struct Ssat16 {
        pub rd: Register,
        pub imm: u32,
        pub rn: Register,
    }
    pub struct Ssat16Builder<const rdSET: bool, const immSET: bool, const rnSET: bool> {
        rd: Option<Register>,
        imm: Option<u32>,
        rn: Option<Register>,
    }
    impl<const immSET: bool, const rnSET: bool> Ssat16Builder<false, immSET, rnSET> {
        pub fn set_rd(mut self, rd: Register) -> Ssat16Builder<true, immSET, rnSET> {
            self.rd = Some(rd);
            Ssat16Builder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Ssat16Builder<rdSET, false, rnSET> {
        pub fn set_imm(mut self, imm: u32) -> Ssat16Builder<rdSET, true, rnSET> {
            self.imm = Some(imm);
            Ssat16Builder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const immSET: bool> Ssat16Builder<rdSET, immSET, false> {
        pub fn set_rn(mut self, rn: Register) -> Ssat16Builder<rdSET, immSET, true> {
            self.rn = Some(rn);
            Ssat16Builder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
            }
        }
    }
    impl Ssat16Builder<false, false, false> {
        pub fn new() -> Ssat16Builder<false, false, false> {
            Ssat16Builder {
                rd: None,
                imm: None,
                rn: None,
            }
        }
    }
    impl Ssat16 {
        pub fn builder() -> Ssat16Builder<false, false, false> {
            Ssat16Builder {
                rd: None,
                imm: None,
                rn: None,
            }
        }
    }
    impl Ssat16Builder<true, true, true> {
        pub fn complete(self) -> Ssat16 {
            Ssat16 {
                rd: self.rd.unwrap(),
                imm: self.imm.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct Ssat16Consumer<const rdSET: bool, const immSET: bool, const rnSET: bool> {
        rd: Option<Register>,
        imm: Option<u32>,
        rn: Option<Register>,
    }
    impl<
        const immCONSUMED: bool,
        const rnCONSUMED: bool,
    > Ssat16Consumer<false, immCONSUMED, rnCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, Ssat16Consumer<true, immCONSUMED, rnCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Ssat16Consumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Ssat16Consumer<rdCONSUMED, false, rnCONSUMED> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, Ssat16Consumer<rdCONSUMED, true, rnCONSUMED>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                Ssat16Consumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > Ssat16Consumer<rdCONSUMED, immCONSUMED, false> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Ssat16Consumer<rdCONSUMED, immCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Ssat16Consumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                },
            )
        }
    }
    impl Ssat16 {
        pub fn consumer(self) -> Ssat16Consumer<false, false, false> {
            Ssat16Consumer {
                rd: Some(self.rd),
                imm: Some(self.imm),
                rn: Some(self.rn),
            }
        }
    }
    impl Ssat16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ssat16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ssat16",
                "rd",
                &self.rd,
                "imm",
                &self.imm,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ssat16 {
        #[inline]
        fn clone(&self) -> Ssat16 {
            Ssat16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                imm: ::core::clone::Clone::clone(&self.imm),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ssat16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ssat16 {
        #[inline]
        fn eq(&self, other: &Ssat16) -> bool {
            self.rd == other.rd && self.imm == other.imm && self.rn == other.rn
        }
    }
    impl From<Ssat16> for Operation {
        fn from(val: Ssat16) -> Operation {
            Operation::Ssat16(val)
        }
    }
    pub struct Ssax {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct SsaxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> SsaxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SsaxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            SsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> SsaxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> SsaxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            SsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> SsaxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> SsaxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            SsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl SsaxBuilder<false, false, false> {
        pub fn new() -> SsaxBuilder<false, false, false> {
            SsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Ssax {
        pub fn builder() -> SsaxBuilder<false, false, false> {
            SsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl SsaxBuilder<true, true, true> {
        pub fn complete(self) -> Ssax {
            Ssax {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct SsaxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SsaxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, SsaxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SsaxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SsaxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SsaxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SsaxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Ssax {
        pub fn consumer(self) -> SsaxConsumer<false, false, false> {
            SsaxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl SsaxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ssax {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ssax",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ssax {
        #[inline]
        fn clone(&self) -> Ssax {
            Ssax {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ssax {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ssax {
        #[inline]
        fn eq(&self, other: &Ssax) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Ssax> for Operation {
        fn from(val: Ssax) -> Operation {
            Operation::Ssax(val)
        }
    }
    pub struct Ssub16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Ssub16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Ssub16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Ssub16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Ssub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Ssub16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Ssub16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Ssub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Ssub16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Ssub16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Ssub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Ssub16Builder<false, false, false> {
        pub fn new() -> Ssub16Builder<false, false, false> {
            Ssub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Ssub16 {
        pub fn builder() -> Ssub16Builder<false, false, false> {
            Ssub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Ssub16Builder<true, true, true> {
        pub fn complete(self) -> Ssub16 {
            Ssub16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Ssub16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Ssub16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Ssub16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Ssub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Ssub16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Ssub16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Ssub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Ssub16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Ssub16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Ssub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Ssub16 {
        pub fn consumer(self) -> Ssub16Consumer<false, false, false> {
            Ssub16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Ssub16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ssub16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ssub16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ssub16 {
        #[inline]
        fn clone(&self) -> Ssub16 {
            Ssub16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ssub16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ssub16 {
        #[inline]
        fn eq(&self, other: &Ssub16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Ssub16> for Operation {
        fn from(val: Ssub16) -> Operation {
            Operation::Ssub16(val)
        }
    }
    pub struct Ssub8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Ssub8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Ssub8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Ssub8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Ssub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Ssub8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Ssub8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Ssub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Ssub8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Ssub8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Ssub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Ssub8Builder<false, false, false> {
        pub fn new() -> Ssub8Builder<false, false, false> {
            Ssub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Ssub8 {
        pub fn builder() -> Ssub8Builder<false, false, false> {
            Ssub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Ssub8Builder<true, true, true> {
        pub fn complete(self) -> Ssub8 {
            Ssub8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Ssub8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Ssub8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Ssub8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Ssub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Ssub8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Ssub8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Ssub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Ssub8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Ssub8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Ssub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Ssub8 {
        pub fn consumer(self) -> Ssub8Consumer<false, false, false> {
            Ssub8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Ssub8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ssub8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ssub8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ssub8 {
        #[inline]
        fn clone(&self) -> Ssub8 {
            Ssub8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ssub8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ssub8 {
        #[inline]
        fn eq(&self, other: &Ssub8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Ssub8> for Operation {
        fn from(val: Ssub8) -> Operation {
            Operation::Ssub8(val)
        }
    }
    pub struct Stm {
        pub w: Option<bool>,
        pub rn: Register,
        pub registers: RegisterList,
    }
    pub struct StmBuilder<
        const wSET: bool,
        const rnSET: bool,
        const registersSET: bool,
    > {
        w: Option<Option<bool>>,
        rn: Option<Register>,
        registers: Option<RegisterList>,
    }
    impl<
        const rnSET: bool,
        const registersSET: bool,
    > StmBuilder<false, rnSET, registersSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> StmBuilder<true, rnSET, registersSET> {
            self.w = Some(w);
            StmBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl<
        const wSET: bool,
        const registersSET: bool,
    > StmBuilder<wSET, false, registersSET> {
        pub fn set_rn(mut self, rn: Register) -> StmBuilder<wSET, true, registersSET> {
            self.rn = Some(rn);
            StmBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl<const wSET: bool, const rnSET: bool> StmBuilder<wSET, rnSET, false> {
        pub fn set_registers(
            mut self,
            registers: RegisterList,
        ) -> StmBuilder<wSET, rnSET, true> {
            self.registers = Some(registers);
            StmBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl StmBuilder<false, false, false> {
        pub fn new() -> StmBuilder<false, false, false> {
            StmBuilder {
                w: None,
                rn: None,
                registers: None,
            }
        }
    }
    impl Stm {
        pub fn builder() -> StmBuilder<false, false, false> {
            StmBuilder {
                w: None,
                rn: None,
                registers: None,
            }
        }
    }
    impl StmBuilder<true, true, true> {
        pub fn complete(self) -> Stm {
            Stm {
                w: self.w.unwrap(),
                rn: self.rn.unwrap(),
                registers: self.registers.unwrap(),
            }
        }
    }
    pub struct StmConsumer<
        const wSET: bool,
        const rnSET: bool,
        const registersSET: bool,
    > {
        w: Option<Option<bool>>,
        rn: Option<Register>,
        registers: Option<RegisterList>,
    }
    impl<
        const rnCONSUMED: bool,
        const registersCONSUMED: bool,
    > StmConsumer<false, rnCONSUMED, registersCONSUMED> {
        pub fn consume_w(
            mut self,
        ) -> (Option<bool>, StmConsumer<true, rnCONSUMED, registersCONSUMED>) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                StmConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const registersCONSUMED: bool,
    > StmConsumer<wCONSUMED, false, registersCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, StmConsumer<wCONSUMED, true, registersCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StmConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const rnCONSUMED: bool,
    > StmConsumer<wCONSUMED, rnCONSUMED, false> {
        pub fn consume_registers(
            mut self,
        ) -> (RegisterList, StmConsumer<wCONSUMED, rnCONSUMED, true>) {
            let ret = self.registers.unwrap();
            self.registers = None;
            (
                ret,
                StmConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl Stm {
        pub fn consumer(self) -> StmConsumer<false, false, false> {
            StmConsumer {
                w: Some(self.w),
                rn: Some(self.rn),
                registers: Some(self.registers),
            }
        }
    }
    impl StmConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Stm {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Stm",
                "w",
                &self.w,
                "rn",
                &self.rn,
                "registers",
                &&self.registers,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Stm {
        #[inline]
        fn clone(&self) -> Stm {
            Stm {
                w: ::core::clone::Clone::clone(&self.w),
                rn: ::core::clone::Clone::clone(&self.rn),
                registers: ::core::clone::Clone::clone(&self.registers),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Stm {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Stm {
        #[inline]
        fn eq(&self, other: &Stm) -> bool {
            self.w == other.w && self.rn == other.rn && self.registers == other.registers
        }
    }
    impl From<Stm> for Operation {
        fn from(val: Stm) -> Operation {
            Operation::Stm(val)
        }
    }
    pub struct Stmdb {
        pub w: Option<bool>,
        pub rn: Register,
        pub registers: RegisterList,
    }
    pub struct StmdbBuilder<
        const wSET: bool,
        const rnSET: bool,
        const registersSET: bool,
    > {
        w: Option<Option<bool>>,
        rn: Option<Register>,
        registers: Option<RegisterList>,
    }
    impl<
        const rnSET: bool,
        const registersSET: bool,
    > StmdbBuilder<false, rnSET, registersSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> StmdbBuilder<true, rnSET, registersSET> {
            self.w = Some(w);
            StmdbBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl<
        const wSET: bool,
        const registersSET: bool,
    > StmdbBuilder<wSET, false, registersSET> {
        pub fn set_rn(mut self, rn: Register) -> StmdbBuilder<wSET, true, registersSET> {
            self.rn = Some(rn);
            StmdbBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl<const wSET: bool, const rnSET: bool> StmdbBuilder<wSET, rnSET, false> {
        pub fn set_registers(
            mut self,
            registers: RegisterList,
        ) -> StmdbBuilder<wSET, rnSET, true> {
            self.registers = Some(registers);
            StmdbBuilder {
                w: self.w,
                rn: self.rn,
                registers: self.registers,
            }
        }
    }
    impl StmdbBuilder<false, false, false> {
        pub fn new() -> StmdbBuilder<false, false, false> {
            StmdbBuilder {
                w: None,
                rn: None,
                registers: None,
            }
        }
    }
    impl Stmdb {
        pub fn builder() -> StmdbBuilder<false, false, false> {
            StmdbBuilder {
                w: None,
                rn: None,
                registers: None,
            }
        }
    }
    impl StmdbBuilder<true, true, true> {
        pub fn complete(self) -> Stmdb {
            Stmdb {
                w: self.w.unwrap(),
                rn: self.rn.unwrap(),
                registers: self.registers.unwrap(),
            }
        }
    }
    pub struct StmdbConsumer<
        const wSET: bool,
        const rnSET: bool,
        const registersSET: bool,
    > {
        w: Option<Option<bool>>,
        rn: Option<Register>,
        registers: Option<RegisterList>,
    }
    impl<
        const rnCONSUMED: bool,
        const registersCONSUMED: bool,
    > StmdbConsumer<false, rnCONSUMED, registersCONSUMED> {
        pub fn consume_w(
            mut self,
        ) -> (Option<bool>, StmdbConsumer<true, rnCONSUMED, registersCONSUMED>) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                StmdbConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const registersCONSUMED: bool,
    > StmdbConsumer<wCONSUMED, false, registersCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, StmdbConsumer<wCONSUMED, true, registersCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StmdbConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const rnCONSUMED: bool,
    > StmdbConsumer<wCONSUMED, rnCONSUMED, false> {
        pub fn consume_registers(
            mut self,
        ) -> (RegisterList, StmdbConsumer<wCONSUMED, rnCONSUMED, true>) {
            let ret = self.registers.unwrap();
            self.registers = None;
            (
                ret,
                StmdbConsumer {
                    w: self.w,
                    rn: self.rn,
                    registers: self.registers,
                },
            )
        }
    }
    impl Stmdb {
        pub fn consumer(self) -> StmdbConsumer<false, false, false> {
            StmdbConsumer {
                w: Some(self.w),
                rn: Some(self.rn),
                registers: Some(self.registers),
            }
        }
    }
    impl StmdbConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Stmdb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Stmdb",
                "w",
                &self.w,
                "rn",
                &self.rn,
                "registers",
                &&self.registers,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Stmdb {
        #[inline]
        fn clone(&self) -> Stmdb {
            Stmdb {
                w: ::core::clone::Clone::clone(&self.w),
                rn: ::core::clone::Clone::clone(&self.rn),
                registers: ::core::clone::Clone::clone(&self.registers),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Stmdb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Stmdb {
        #[inline]
        fn eq(&self, other: &Stmdb) -> bool {
            self.w == other.w && self.rn == other.rn && self.registers == other.registers
        }
    }
    impl From<Stmdb> for Operation {
        fn from(val: Stmdb) -> Operation {
            Operation::Stmdb(val)
        }
    }
    pub struct StrImmediate {
        pub w: Option<bool>,
        pub index: Option<bool>,
        pub add: bool,
        pub rt: Register,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct StrImmediateBuilder<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        index: Option<Option<bool>>,
        add: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrImmediateBuilder<false, indexSET, addSET, rtSET, rnSET, immSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> StrImmediateBuilder<true, indexSET, addSET, rtSET, rnSET, immSET> {
            self.w = Some(w);
            StrImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrImmediateBuilder<wSET, false, addSET, rtSET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: Option<bool>,
        ) -> StrImmediateBuilder<wSET, true, addSET, rtSET, rnSET, immSET> {
            self.index = Some(index);
            StrImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrImmediateBuilder<wSET, indexSET, false, rtSET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> StrImmediateBuilder<wSET, indexSET, true, rtSET, rnSET, immSET> {
            self.add = Some(add);
            StrImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrImmediateBuilder<wSET, indexSET, addSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> StrImmediateBuilder<wSET, indexSET, addSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            StrImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > StrImmediateBuilder<wSET, indexSET, addSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StrImmediateBuilder<wSET, indexSET, addSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            StrImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > StrImmediateBuilder<wSET, indexSET, addSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> StrImmediateBuilder<wSET, indexSET, addSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            StrImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl StrImmediateBuilder<false, false, false, false, false, false> {
        pub fn new() -> StrImmediateBuilder<false, false, false, false, false, false> {
            StrImmediateBuilder {
                w: None,
                index: None,
                add: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrImmediate {
        pub fn builder() -> StrImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            StrImmediateBuilder {
                w: None,
                index: None,
                add: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrImmediateBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> StrImmediate {
            StrImmediate {
                w: self.w.unwrap(),
                index: self.index.unwrap(),
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct StrImmediateConsumer<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        index: Option<Option<bool>>,
        add: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrImmediateConsumer<
        false,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            StrImmediateConsumer<
                true,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                StrImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrImmediateConsumer<
        wCONSUMED,
        false,
        addCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            Option<bool>,
            StrImmediateConsumer<
                wCONSUMED,
                true,
                addCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                StrImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        false,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            StrImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                true,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                StrImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            StrImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > StrImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            StrImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            StrImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StrImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl StrImmediate {
        pub fn consumer(
            self,
        ) -> StrImmediateConsumer<false, false, false, false, false, false> {
            StrImmediateConsumer {
                w: Some(self.w),
                index: Some(self.index),
                add: Some(self.add),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl StrImmediateConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StrImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["w", "index", "add", "rt", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.w,
                &self.index,
                &self.add,
                &self.rt,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "StrImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StrImmediate {
        #[inline]
        fn clone(&self) -> StrImmediate {
            StrImmediate {
                w: ::core::clone::Clone::clone(&self.w),
                index: ::core::clone::Clone::clone(&self.index),
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StrImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StrImmediate {
        #[inline]
        fn eq(&self, other: &StrImmediate) -> bool {
            self.w == other.w && self.index == other.index && self.add == other.add
                && self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<StrImmediate> for Operation {
        fn from(val: StrImmediate) -> Operation {
            Operation::StrImmediate(val)
        }
    }
    pub struct StrRegister {
        pub rt: Register,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct StrRegisterBuilder<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > StrRegisterBuilder<false, rnSET, rmSET, shiftSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> StrRegisterBuilder<true, rnSET, rmSET, shiftSET> {
            self.rt = Some(rt);
            StrRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > StrRegisterBuilder<rtSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StrRegisterBuilder<rtSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            StrRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > StrRegisterBuilder<rtSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> StrRegisterBuilder<rtSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            StrRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > StrRegisterBuilder<rtSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> StrRegisterBuilder<rtSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            StrRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl StrRegisterBuilder<false, false, false, false> {
        pub fn new() -> StrRegisterBuilder<false, false, false, false> {
            StrRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl StrRegister {
        pub fn builder() -> StrRegisterBuilder<false, false, false, false> {
            StrRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl StrRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> StrRegister {
            StrRegister {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct StrRegisterConsumer<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrRegisterConsumer<false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            StrRegisterConsumer<true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrRegisterConsumer<rtCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            StrRegisterConsumer<rtCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrRegisterConsumer<rtCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            StrRegisterConsumer<rtCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                StrRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > StrRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            StrRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                StrRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl StrRegister {
        pub fn consumer(self) -> StrRegisterConsumer<false, false, false, false> {
            StrRegisterConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl StrRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StrRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "StrRegister",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StrRegister {
        #[inline]
        fn clone(&self) -> StrRegister {
            StrRegister {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StrRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StrRegister {
        #[inline]
        fn eq(&self, other: &StrRegister) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<StrRegister> for Operation {
        fn from(val: StrRegister) -> Operation {
            Operation::StrRegister(val)
        }
    }
    pub struct StrbImmediate {
        pub w: Option<bool>,
        pub index: Option<bool>,
        pub add: bool,
        pub rt: Register,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct StrbImmediateBuilder<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        index: Option<Option<bool>>,
        add: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrbImmediateBuilder<false, indexSET, addSET, rtSET, rnSET, immSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> StrbImmediateBuilder<true, indexSET, addSET, rtSET, rnSET, immSET> {
            self.w = Some(w);
            StrbImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrbImmediateBuilder<wSET, false, addSET, rtSET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: Option<bool>,
        ) -> StrbImmediateBuilder<wSET, true, addSET, rtSET, rnSET, immSET> {
            self.index = Some(index);
            StrbImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrbImmediateBuilder<wSET, indexSET, false, rtSET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> StrbImmediateBuilder<wSET, indexSET, true, rtSET, rnSET, immSET> {
            self.add = Some(add);
            StrbImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrbImmediateBuilder<wSET, indexSET, addSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> StrbImmediateBuilder<wSET, indexSET, addSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            StrbImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > StrbImmediateBuilder<wSET, indexSET, addSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StrbImmediateBuilder<wSET, indexSET, addSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            StrbImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > StrbImmediateBuilder<wSET, indexSET, addSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> StrbImmediateBuilder<wSET, indexSET, addSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            StrbImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl StrbImmediateBuilder<false, false, false, false, false, false> {
        pub fn new() -> StrbImmediateBuilder<false, false, false, false, false, false> {
            StrbImmediateBuilder {
                w: None,
                index: None,
                add: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrbImmediate {
        pub fn builder() -> StrbImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            StrbImmediateBuilder {
                w: None,
                index: None,
                add: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrbImmediateBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> StrbImmediate {
            StrbImmediate {
                w: self.w.unwrap(),
                index: self.index.unwrap(),
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct StrbImmediateConsumer<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        index: Option<Option<bool>>,
        add: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrbImmediateConsumer<
        false,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            StrbImmediateConsumer<
                true,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                StrbImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrbImmediateConsumer<
        wCONSUMED,
        false,
        addCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            Option<bool>,
            StrbImmediateConsumer<
                wCONSUMED,
                true,
                addCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                StrbImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrbImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        false,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            StrbImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                true,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                StrbImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrbImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            StrbImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrbImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > StrbImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            StrbImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrbImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrbImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            u32,
            StrbImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StrbImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl StrbImmediate {
        pub fn consumer(
            self,
        ) -> StrbImmediateConsumer<false, false, false, false, false, false> {
            StrbImmediateConsumer {
                w: Some(self.w),
                index: Some(self.index),
                add: Some(self.add),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl StrbImmediateConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StrbImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["w", "index", "add", "rt", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.w,
                &self.index,
                &self.add,
                &self.rt,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "StrbImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StrbImmediate {
        #[inline]
        fn clone(&self) -> StrbImmediate {
            StrbImmediate {
                w: ::core::clone::Clone::clone(&self.w),
                index: ::core::clone::Clone::clone(&self.index),
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StrbImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StrbImmediate {
        #[inline]
        fn eq(&self, other: &StrbImmediate) -> bool {
            self.w == other.w && self.index == other.index && self.add == other.add
                && self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<StrbImmediate> for Operation {
        fn from(val: StrbImmediate) -> Operation {
            Operation::StrbImmediate(val)
        }
    }
    pub struct StrbRegister {
        pub rt: Register,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct StrbRegisterBuilder<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > StrbRegisterBuilder<false, rnSET, rmSET, shiftSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> StrbRegisterBuilder<true, rnSET, rmSET, shiftSET> {
            self.rt = Some(rt);
            StrbRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > StrbRegisterBuilder<rtSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StrbRegisterBuilder<rtSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            StrbRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > StrbRegisterBuilder<rtSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> StrbRegisterBuilder<rtSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            StrbRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > StrbRegisterBuilder<rtSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> StrbRegisterBuilder<rtSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            StrbRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl StrbRegisterBuilder<false, false, false, false> {
        pub fn new() -> StrbRegisterBuilder<false, false, false, false> {
            StrbRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl StrbRegister {
        pub fn builder() -> StrbRegisterBuilder<false, false, false, false> {
            StrbRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl StrbRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> StrbRegister {
            StrbRegister {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct StrbRegisterConsumer<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrbRegisterConsumer<false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            StrbRegisterConsumer<true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrbRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrbRegisterConsumer<rtCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            StrbRegisterConsumer<rtCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrbRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrbRegisterConsumer<rtCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            StrbRegisterConsumer<rtCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                StrbRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > StrbRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            StrbRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                StrbRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl StrbRegister {
        pub fn consumer(self) -> StrbRegisterConsumer<false, false, false, false> {
            StrbRegisterConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl StrbRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StrbRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "StrbRegister",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StrbRegister {
        #[inline]
        fn clone(&self) -> StrbRegister {
            StrbRegister {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StrbRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StrbRegister {
        #[inline]
        fn eq(&self, other: &StrbRegister) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<StrbRegister> for Operation {
        fn from(val: StrbRegister) -> Operation {
            Operation::StrbRegister(val)
        }
    }
    pub struct Strbt {
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct StrbtBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<const rnSET: bool, const immSET: bool> StrbtBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> StrbtBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            StrbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> StrbtBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> StrbtBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            StrbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> StrbtBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: Option<u32>) -> StrbtBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            StrbtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl StrbtBuilder<false, false, false> {
        pub fn new() -> StrbtBuilder<false, false, false> {
            StrbtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Strbt {
        pub fn builder() -> StrbtBuilder<false, false, false> {
            StrbtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrbtBuilder<true, true, true> {
        pub fn complete(self) -> Strbt {
            Strbt {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct StrbtConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrbtConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, StrbtConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > StrbtConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, StrbtConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrbtConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (Option<u32>, StrbtConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StrbtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Strbt {
        pub fn consumer(self) -> StrbtConsumer<false, false, false> {
            StrbtConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl StrbtConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Strbt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Strbt",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Strbt {
        #[inline]
        fn clone(&self) -> Strbt {
            Strbt {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Strbt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Strbt {
        #[inline]
        fn eq(&self, other: &Strbt) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Strbt> for Operation {
        fn from(val: Strbt) -> Operation {
            Operation::Strbt(val)
        }
    }
    pub struct StrdImmediate {
        pub w: Option<bool>,
        pub index: Option<bool>,
        pub add: bool,
        pub rt: Register,
        pub rt2: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct StrdImmediateBuilder<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        index: Option<Option<bool>>,
        add: Option<bool>,
        rt: Option<Register>,
        rt2: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrdImmediateBuilder<false, indexSET, addSET, rtSET, rt2SET, rnSET, immSET> {
        pub fn set_w(
            mut self,
            w: Option<bool>,
        ) -> StrdImmediateBuilder<true, indexSET, addSET, rtSET, rt2SET, rnSET, immSET> {
            self.w = Some(w);
            StrdImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrdImmediateBuilder<wSET, false, addSET, rtSET, rt2SET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: Option<bool>,
        ) -> StrdImmediateBuilder<wSET, true, addSET, rtSET, rt2SET, rnSET, immSET> {
            self.index = Some(index);
            StrdImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrdImmediateBuilder<wSET, indexSET, false, rtSET, rt2SET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> StrdImmediateBuilder<wSET, indexSET, true, rtSET, rt2SET, rnSET, immSET> {
            self.add = Some(add);
            StrdImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrdImmediateBuilder<wSET, indexSET, addSET, false, rt2SET, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> StrdImmediateBuilder<wSET, indexSET, addSET, true, rt2SET, rnSET, immSET> {
            self.rt = Some(rt);
            StrdImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrdImmediateBuilder<wSET, indexSET, addSET, rtSET, false, rnSET, immSET> {
        pub fn set_rt2(
            mut self,
            rt2: Register,
        ) -> StrdImmediateBuilder<wSET, indexSET, addSET, rtSET, true, rnSET, immSET> {
            self.rt2 = Some(rt2);
            StrdImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const immSET: bool,
    > StrdImmediateBuilder<wSET, indexSET, addSET, rtSET, rt2SET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StrdImmediateBuilder<wSET, indexSET, addSET, rtSET, rt2SET, true, immSET> {
            self.rn = Some(rn);
            StrdImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
    > StrdImmediateBuilder<wSET, indexSET, addSET, rtSET, rt2SET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: Option<u32>,
        ) -> StrdImmediateBuilder<wSET, indexSET, addSET, rtSET, rt2SET, rnSET, true> {
            self.imm = Some(imm);
            StrdImmediateBuilder {
                w: self.w,
                index: self.index,
                add: self.add,
                rt: self.rt,
                rt2: self.rt2,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl StrdImmediateBuilder<false, false, false, false, false, false, false> {
        pub fn new() -> StrdImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            StrdImmediateBuilder {
                w: None,
                index: None,
                add: None,
                rt: None,
                rt2: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrdImmediate {
        pub fn builder() -> StrdImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            StrdImmediateBuilder {
                w: None,
                index: None,
                add: None,
                rt: None,
                rt2: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrdImmediateBuilder<true, true, true, true, true, true, true> {
        pub fn complete(self) -> StrdImmediate {
            StrdImmediate {
                w: self.w.unwrap(),
                index: self.index.unwrap(),
                add: self.add.unwrap(),
                rt: self.rt.unwrap(),
                rt2: self.rt2.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct StrdImmediateConsumer<
        const wSET: bool,
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rt2SET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        w: Option<Option<bool>>,
        index: Option<Option<bool>>,
        add: Option<bool>,
        rt: Option<Register>,
        rt2: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrdImmediateConsumer<
        false,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            Option<bool>,
            StrdImmediateConsumer<
                true,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                StrdImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrdImmediateConsumer<
        wCONSUMED,
        false,
        addCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            Option<bool>,
            StrdImmediateConsumer<
                wCONSUMED,
                true,
                addCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                StrdImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrdImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        false,
        rtCONSUMED,
        rt2CONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            StrdImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                true,
                rtCONSUMED,
                rt2CONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                StrdImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrdImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        false,
        rt2CONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            StrdImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                true,
                rt2CONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrdImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrdImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt2(
            mut self,
        ) -> (
            Register,
            StrdImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt2.unwrap();
            self.rt2 = None;
            (
                ret,
                StrdImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const immCONSUMED: bool,
    > StrdImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            StrdImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrdImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rt2CONSUMED: bool,
        const rnCONSUMED: bool,
    > StrdImmediateConsumer<
        wCONSUMED,
        indexCONSUMED,
        addCONSUMED,
        rtCONSUMED,
        rt2CONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            Option<u32>,
            StrdImmediateConsumer<
                wCONSUMED,
                indexCONSUMED,
                addCONSUMED,
                rtCONSUMED,
                rt2CONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StrdImmediateConsumer {
                    w: self.w,
                    index: self.index,
                    add: self.add,
                    rt: self.rt,
                    rt2: self.rt2,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl StrdImmediate {
        pub fn consumer(
            self,
        ) -> StrdImmediateConsumer<false, false, false, false, false, false, false> {
            StrdImmediateConsumer {
                w: Some(self.w),
                index: Some(self.index),
                add: Some(self.add),
                rt: Some(self.rt),
                rt2: Some(self.rt2),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl StrdImmediateConsumer<true, true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StrdImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["w", "index", "add", "rt", "rt2", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.w,
                &self.index,
                &self.add,
                &self.rt,
                &self.rt2,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "StrdImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StrdImmediate {
        #[inline]
        fn clone(&self) -> StrdImmediate {
            StrdImmediate {
                w: ::core::clone::Clone::clone(&self.w),
                index: ::core::clone::Clone::clone(&self.index),
                add: ::core::clone::Clone::clone(&self.add),
                rt: ::core::clone::Clone::clone(&self.rt),
                rt2: ::core::clone::Clone::clone(&self.rt2),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StrdImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StrdImmediate {
        #[inline]
        fn eq(&self, other: &StrdImmediate) -> bool {
            self.w == other.w && self.index == other.index && self.add == other.add
                && self.rt == other.rt && self.rt2 == other.rt2 && self.rn == other.rn
                && self.imm == other.imm
        }
    }
    impl From<StrdImmediate> for Operation {
        fn from(val: StrdImmediate) -> Operation {
            Operation::StrdImmediate(val)
        }
    }
    pub struct Strex {
        pub rd: Register,
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct StrexBuilder<
        const rdSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        rd: Option<Register>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrexBuilder<false, rtSET, rnSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> StrexBuilder<true, rtSET, rnSET, immSET> {
            self.rd = Some(rd);
            StrexBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrexBuilder<rdSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> StrexBuilder<rdSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            StrexBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > StrexBuilder<rdSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StrexBuilder<rdSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            StrexBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > StrexBuilder<rdSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: Option<u32>,
        ) -> StrexBuilder<rdSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            StrexBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl StrexBuilder<false, false, false, false> {
        pub fn new() -> StrexBuilder<false, false, false, false> {
            StrexBuilder {
                rd: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Strex {
        pub fn builder() -> StrexBuilder<false, false, false, false> {
            StrexBuilder {
                rd: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrexBuilder<true, true, true, true> {
        pub fn complete(self) -> Strex {
            Strex {
                rd: self.rd.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct StrexConsumer<
        const rdSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        rd: Option<Register>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrexConsumer<false, rtCONSUMED, rnCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, StrexConsumer<true, rtCONSUMED, rnCONSUMED, immCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                StrexConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrexConsumer<rdCONSUMED, false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, StrexConsumer<rdCONSUMED, true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrexConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > StrexConsumer<rdCONSUMED, rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, StrexConsumer<rdCONSUMED, rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrexConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrexConsumer<rdCONSUMED, rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (Option<u32>, StrexConsumer<rdCONSUMED, rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StrexConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Strex {
        pub fn consumer(self) -> StrexConsumer<false, false, false, false> {
            StrexConsumer {
                rd: Some(self.rd),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl StrexConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Strex {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Strex",
                "rd",
                &self.rd,
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Strex {
        #[inline]
        fn clone(&self) -> Strex {
            Strex {
                rd: ::core::clone::Clone::clone(&self.rd),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Strex {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Strex {
        #[inline]
        fn eq(&self, other: &Strex) -> bool {
            self.rd == other.rd && self.rt == other.rt && self.rn == other.rn
                && self.imm == other.imm
        }
    }
    impl From<Strex> for Operation {
        fn from(val: Strex) -> Operation {
            Operation::Strex(val)
        }
    }
    pub struct Strexb {
        pub rd: Register,
        pub rt: Register,
        pub rn: Register,
    }
    pub struct StrexbBuilder<const rdSET: bool, const rtSET: bool, const rnSET: bool> {
        rd: Option<Register>,
        rt: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rtSET: bool, const rnSET: bool> StrexbBuilder<false, rtSET, rnSET> {
        pub fn set_rd(mut self, rd: Register) -> StrexbBuilder<true, rtSET, rnSET> {
            self.rd = Some(rd);
            StrexbBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> StrexbBuilder<rdSET, false, rnSET> {
        pub fn set_rt(mut self, rt: Register) -> StrexbBuilder<rdSET, true, rnSET> {
            self.rt = Some(rt);
            StrexbBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rtSET: bool> StrexbBuilder<rdSET, rtSET, false> {
        pub fn set_rn(mut self, rn: Register) -> StrexbBuilder<rdSET, rtSET, true> {
            self.rn = Some(rn);
            StrexbBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl StrexbBuilder<false, false, false> {
        pub fn new() -> StrexbBuilder<false, false, false> {
            StrexbBuilder {
                rd: None,
                rt: None,
                rn: None,
            }
        }
    }
    impl Strexb {
        pub fn builder() -> StrexbBuilder<false, false, false> {
            StrexbBuilder {
                rd: None,
                rt: None,
                rn: None,
            }
        }
    }
    impl StrexbBuilder<true, true, true> {
        pub fn complete(self) -> Strexb {
            Strexb {
                rd: self.rd.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct StrexbConsumer<const rdSET: bool, const rtSET: bool, const rnSET: bool> {
        rd: Option<Register>,
        rt: Option<Register>,
        rn: Option<Register>,
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrexbConsumer<false, rtCONSUMED, rnCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, StrexbConsumer<true, rtCONSUMED, rnCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                StrexbConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrexbConsumer<rdCONSUMED, false, rnCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, StrexbConsumer<rdCONSUMED, true, rnCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrexbConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rtCONSUMED: bool,
    > StrexbConsumer<rdCONSUMED, rtCONSUMED, false> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, StrexbConsumer<rdCONSUMED, rtCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrexbConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl Strexb {
        pub fn consumer(self) -> StrexbConsumer<false, false, false> {
            StrexbConsumer {
                rd: Some(self.rd),
                rt: Some(self.rt),
                rn: Some(self.rn),
            }
        }
    }
    impl StrexbConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Strexb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Strexb",
                "rd",
                &self.rd,
                "rt",
                &self.rt,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Strexb {
        #[inline]
        fn clone(&self) -> Strexb {
            Strexb {
                rd: ::core::clone::Clone::clone(&self.rd),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Strexb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Strexb {
        #[inline]
        fn eq(&self, other: &Strexb) -> bool {
            self.rd == other.rd && self.rt == other.rt && self.rn == other.rn
        }
    }
    impl From<Strexb> for Operation {
        fn from(val: Strexb) -> Operation {
            Operation::Strexb(val)
        }
    }
    pub struct Strexh {
        pub rd: Register,
        pub rt: Register,
        pub rn: Register,
    }
    pub struct StrexhBuilder<const rdSET: bool, const rtSET: bool, const rnSET: bool> {
        rd: Option<Register>,
        rt: Option<Register>,
        rn: Option<Register>,
    }
    impl<const rtSET: bool, const rnSET: bool> StrexhBuilder<false, rtSET, rnSET> {
        pub fn set_rd(mut self, rd: Register) -> StrexhBuilder<true, rtSET, rnSET> {
            self.rd = Some(rd);
            StrexhBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> StrexhBuilder<rdSET, false, rnSET> {
        pub fn set_rt(mut self, rt: Register) -> StrexhBuilder<rdSET, true, rnSET> {
            self.rt = Some(rt);
            StrexhBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rtSET: bool> StrexhBuilder<rdSET, rtSET, false> {
        pub fn set_rn(mut self, rn: Register) -> StrexhBuilder<rdSET, rtSET, true> {
            self.rn = Some(rn);
            StrexhBuilder {
                rd: self.rd,
                rt: self.rt,
                rn: self.rn,
            }
        }
    }
    impl StrexhBuilder<false, false, false> {
        pub fn new() -> StrexhBuilder<false, false, false> {
            StrexhBuilder {
                rd: None,
                rt: None,
                rn: None,
            }
        }
    }
    impl Strexh {
        pub fn builder() -> StrexhBuilder<false, false, false> {
            StrexhBuilder {
                rd: None,
                rt: None,
                rn: None,
            }
        }
    }
    impl StrexhBuilder<true, true, true> {
        pub fn complete(self) -> Strexh {
            Strexh {
                rd: self.rd.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct StrexhConsumer<const rdSET: bool, const rtSET: bool, const rnSET: bool> {
        rd: Option<Register>,
        rt: Option<Register>,
        rn: Option<Register>,
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrexhConsumer<false, rtCONSUMED, rnCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, StrexhConsumer<true, rtCONSUMED, rnCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                StrexhConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrexhConsumer<rdCONSUMED, false, rnCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, StrexhConsumer<rdCONSUMED, true, rnCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrexhConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rtCONSUMED: bool,
    > StrexhConsumer<rdCONSUMED, rtCONSUMED, false> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, StrexhConsumer<rdCONSUMED, rtCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrexhConsumer {
                    rd: self.rd,
                    rt: self.rt,
                    rn: self.rn,
                },
            )
        }
    }
    impl Strexh {
        pub fn consumer(self) -> StrexhConsumer<false, false, false> {
            StrexhConsumer {
                rd: Some(self.rd),
                rt: Some(self.rt),
                rn: Some(self.rn),
            }
        }
    }
    impl StrexhConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Strexh {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Strexh",
                "rd",
                &self.rd,
                "rt",
                &self.rt,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Strexh {
        #[inline]
        fn clone(&self) -> Strexh {
            Strexh {
                rd: ::core::clone::Clone::clone(&self.rd),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Strexh {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Strexh {
        #[inline]
        fn eq(&self, other: &Strexh) -> bool {
            self.rd == other.rd && self.rt == other.rt && self.rn == other.rn
        }
    }
    impl From<Strexh> for Operation {
        fn from(val: Strexh) -> Operation {
            Operation::Strexh(val)
        }
    }
    pub struct StrhImmediate {
        pub index: bool,
        pub add: bool,
        pub w: bool,
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct StrhImmediateBuilder<
        const indexSET: bool,
        const addSET: bool,
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        index: Option<bool>,
        add: Option<bool>,
        w: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const addSET: bool,
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrhImmediateBuilder<false, addSET, wSET, rtSET, rnSET, immSET> {
        pub fn set_index(
            mut self,
            index: bool,
        ) -> StrhImmediateBuilder<true, addSET, wSET, rtSET, rnSET, immSET> {
            self.index = Some(index);
            StrhImmediateBuilder {
                index: self.index,
                add: self.add,
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const indexSET: bool,
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrhImmediateBuilder<indexSET, false, wSET, rtSET, rnSET, immSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> StrhImmediateBuilder<indexSET, true, wSET, rtSET, rnSET, immSET> {
            self.add = Some(add);
            StrhImmediateBuilder {
                index: self.index,
                add: self.add,
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const indexSET: bool,
        const addSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrhImmediateBuilder<indexSET, addSET, false, rtSET, rnSET, immSET> {
        pub fn set_w(
            mut self,
            w: bool,
        ) -> StrhImmediateBuilder<indexSET, addSET, true, rtSET, rnSET, immSET> {
            self.w = Some(w);
            StrhImmediateBuilder {
                index: self.index,
                add: self.add,
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const indexSET: bool,
        const addSET: bool,
        const wSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > StrhImmediateBuilder<indexSET, addSET, wSET, false, rnSET, immSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> StrhImmediateBuilder<indexSET, addSET, wSET, true, rnSET, immSET> {
            self.rt = Some(rt);
            StrhImmediateBuilder {
                index: self.index,
                add: self.add,
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const indexSET: bool,
        const addSET: bool,
        const wSET: bool,
        const rtSET: bool,
        const immSET: bool,
    > StrhImmediateBuilder<indexSET, addSET, wSET, rtSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StrhImmediateBuilder<indexSET, addSET, wSET, rtSET, true, immSET> {
            self.rn = Some(rn);
            StrhImmediateBuilder {
                index: self.index,
                add: self.add,
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const indexSET: bool,
        const addSET: bool,
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
    > StrhImmediateBuilder<indexSET, addSET, wSET, rtSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: Option<u32>,
        ) -> StrhImmediateBuilder<indexSET, addSET, wSET, rtSET, rnSET, true> {
            self.imm = Some(imm);
            StrhImmediateBuilder {
                index: self.index,
                add: self.add,
                w: self.w,
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl StrhImmediateBuilder<false, false, false, false, false, false> {
        pub fn new() -> StrhImmediateBuilder<false, false, false, false, false, false> {
            StrhImmediateBuilder {
                index: None,
                add: None,
                w: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrhImmediate {
        pub fn builder() -> StrhImmediateBuilder<
            false,
            false,
            false,
            false,
            false,
            false,
        > {
            StrhImmediateBuilder {
                index: None,
                add: None,
                w: None,
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrhImmediateBuilder<true, true, true, true, true, true> {
        pub fn complete(self) -> StrhImmediate {
            StrhImmediate {
                index: self.index.unwrap(),
                add: self.add.unwrap(),
                w: self.w.unwrap(),
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct StrhImmediateConsumer<
        const indexSET: bool,
        const addSET: bool,
        const wSET: bool,
        const rtSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        index: Option<bool>,
        add: Option<bool>,
        w: Option<bool>,
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrhImmediateConsumer<
        false,
        addCONSUMED,
        wCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            bool,
            StrhImmediateConsumer<
                true,
                addCONSUMED,
                wCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                StrhImmediateConsumer {
                    index: self.index,
                    add: self.add,
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const indexCONSUMED: bool,
        const wCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrhImmediateConsumer<
        indexCONSUMED,
        false,
        wCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            StrhImmediateConsumer<
                indexCONSUMED,
                true,
                wCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                StrhImmediateConsumer {
                    index: self.index,
                    add: self.add,
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrhImmediateConsumer<
        indexCONSUMED,
        addCONSUMED,
        false,
        rtCONSUMED,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            bool,
            StrhImmediateConsumer<
                indexCONSUMED,
                addCONSUMED,
                true,
                rtCONSUMED,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                StrhImmediateConsumer {
                    index: self.index,
                    add: self.add,
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrhImmediateConsumer<
        indexCONSUMED,
        addCONSUMED,
        wCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
    > {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            StrhImmediateConsumer<
                indexCONSUMED,
                addCONSUMED,
                wCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
            >,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrhImmediateConsumer {
                    index: self.index,
                    add: self.add,
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > StrhImmediateConsumer<
        indexCONSUMED,
        addCONSUMED,
        wCONSUMED,
        rtCONSUMED,
        false,
        immCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            StrhImmediateConsumer<
                indexCONSUMED,
                addCONSUMED,
                wCONSUMED,
                rtCONSUMED,
                true,
                immCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrhImmediateConsumer {
                    index: self.index,
                    add: self.add,
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const indexCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrhImmediateConsumer<
        indexCONSUMED,
        addCONSUMED,
        wCONSUMED,
        rtCONSUMED,
        rnCONSUMED,
        false,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            Option<u32>,
            StrhImmediateConsumer<
                indexCONSUMED,
                addCONSUMED,
                wCONSUMED,
                rtCONSUMED,
                rnCONSUMED,
                true,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StrhImmediateConsumer {
                    index: self.index,
                    add: self.add,
                    w: self.w,
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl StrhImmediate {
        pub fn consumer(
            self,
        ) -> StrhImmediateConsumer<false, false, false, false, false, false> {
            StrhImmediateConsumer {
                index: Some(self.index),
                add: Some(self.add),
                w: Some(self.w),
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl StrhImmediateConsumer<true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StrhImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["index", "add", "w", "rt", "rn", "imm"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.index,
                &self.add,
                &self.w,
                &self.rt,
                &self.rn,
                &&self.imm,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "StrhImmediate",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StrhImmediate {
        #[inline]
        fn clone(&self) -> StrhImmediate {
            StrhImmediate {
                index: ::core::clone::Clone::clone(&self.index),
                add: ::core::clone::Clone::clone(&self.add),
                w: ::core::clone::Clone::clone(&self.w),
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StrhImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StrhImmediate {
        #[inline]
        fn eq(&self, other: &StrhImmediate) -> bool {
            self.index == other.index && self.add == other.add && self.w == other.w
                && self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<StrhImmediate> for Operation {
        fn from(val: StrhImmediate) -> Operation {
            Operation::StrhImmediate(val)
        }
    }
    pub struct StrhRegister {
        pub rt: Register,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct StrhRegisterBuilder<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > StrhRegisterBuilder<false, rnSET, rmSET, shiftSET> {
        pub fn set_rt(
            mut self,
            rt: Register,
        ) -> StrhRegisterBuilder<true, rnSET, rmSET, shiftSET> {
            self.rt = Some(rt);
            StrhRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > StrhRegisterBuilder<rtSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StrhRegisterBuilder<rtSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            StrhRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > StrhRegisterBuilder<rtSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> StrhRegisterBuilder<rtSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            StrhRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > StrhRegisterBuilder<rtSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> StrhRegisterBuilder<rtSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            StrhRegisterBuilder {
                rt: self.rt,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl StrhRegisterBuilder<false, false, false, false> {
        pub fn new() -> StrhRegisterBuilder<false, false, false, false> {
            StrhRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl StrhRegister {
        pub fn builder() -> StrhRegisterBuilder<false, false, false, false> {
            StrhRegisterBuilder {
                rt: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl StrhRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> StrhRegister {
            StrhRegister {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct StrhRegisterConsumer<
        const rtSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rt: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrhRegisterConsumer<false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (
            Register,
            StrhRegisterConsumer<true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrhRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrhRegisterConsumer<rtCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            StrhRegisterConsumer<rtCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrhRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > StrhRegisterConsumer<rtCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            StrhRegisterConsumer<rtCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                StrhRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > StrhRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            StrhRegisterConsumer<rtCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                StrhRegisterConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl StrhRegister {
        pub fn consumer(self) -> StrhRegisterConsumer<false, false, false, false> {
            StrhRegisterConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl StrhRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StrhRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "StrhRegister",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StrhRegister {
        #[inline]
        fn clone(&self) -> StrhRegister {
            StrhRegister {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StrhRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StrhRegister {
        #[inline]
        fn eq(&self, other: &StrhRegister) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<StrhRegister> for Operation {
        fn from(val: StrhRegister) -> Operation {
            Operation::StrhRegister(val)
        }
    }
    pub struct Strht {
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct StrhtBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<const rnSET: bool, const immSET: bool> StrhtBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> StrhtBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            StrhtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> StrhtBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> StrhtBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            StrhtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> StrhtBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: Option<u32>) -> StrhtBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            StrhtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl StrhtBuilder<false, false, false> {
        pub fn new() -> StrhtBuilder<false, false, false> {
            StrhtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Strht {
        pub fn builder() -> StrhtBuilder<false, false, false> {
            StrhtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrhtBuilder<true, true, true> {
        pub fn complete(self) -> Strht {
            Strht {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct StrhtConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrhtConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, StrhtConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrhtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > StrhtConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, StrhtConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrhtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrhtConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (Option<u32>, StrhtConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StrhtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Strht {
        pub fn consumer(self) -> StrhtConsumer<false, false, false> {
            StrhtConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl StrhtConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Strht {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Strht",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Strht {
        #[inline]
        fn clone(&self) -> Strht {
            Strht {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Strht {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Strht {
        #[inline]
        fn eq(&self, other: &Strht) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Strht> for Operation {
        fn from(val: Strht) -> Operation {
            Operation::Strht(val)
        }
    }
    pub struct Strt {
        pub rt: Register,
        pub rn: Register,
        pub imm: Option<u32>,
    }
    pub struct StrtBuilder<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<const rnSET: bool, const immSET: bool> StrtBuilder<false, rnSET, immSET> {
        pub fn set_rt(mut self, rt: Register) -> StrtBuilder<true, rnSET, immSET> {
            self.rt = Some(rt);
            StrtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const immSET: bool> StrtBuilder<rtSET, false, immSET> {
        pub fn set_rn(mut self, rn: Register) -> StrtBuilder<rtSET, true, immSET> {
            self.rn = Some(rn);
            StrtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<const rtSET: bool, const rnSET: bool> StrtBuilder<rtSET, rnSET, false> {
        pub fn set_imm(mut self, imm: Option<u32>) -> StrtBuilder<rtSET, rnSET, true> {
            self.imm = Some(imm);
            StrtBuilder {
                rt: self.rt,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl StrtBuilder<false, false, false> {
        pub fn new() -> StrtBuilder<false, false, false> {
            StrtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl Strt {
        pub fn builder() -> StrtBuilder<false, false, false> {
            StrtBuilder {
                rt: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl StrtBuilder<true, true, true> {
        pub fn complete(self) -> Strt {
            Strt {
                rt: self.rt.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct StrtConsumer<const rtSET: bool, const rnSET: bool, const immSET: bool> {
        rt: Option<Register>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > StrtConsumer<false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rt(
            mut self,
        ) -> (Register, StrtConsumer<true, rnCONSUMED, immCONSUMED>) {
            let ret = self.rt.unwrap();
            self.rt = None;
            (
                ret,
                StrtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const immCONSUMED: bool,
    > StrtConsumer<rtCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, StrtConsumer<rtCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StrtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rtCONSUMED: bool,
        const rnCONSUMED: bool,
    > StrtConsumer<rtCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (Option<u32>, StrtConsumer<rtCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StrtConsumer {
                    rt: self.rt,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl Strt {
        pub fn consumer(self) -> StrtConsumer<false, false, false> {
            StrtConsumer {
                rt: Some(self.rt),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl StrtConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Strt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Strt",
                "rt",
                &self.rt,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Strt {
        #[inline]
        fn clone(&self) -> Strt {
            Strt {
                rt: ::core::clone::Clone::clone(&self.rt),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Strt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Strt {
        #[inline]
        fn eq(&self, other: &Strt) -> bool {
            self.rt == other.rt && self.rn == other.rn && self.imm == other.imm
        }
    }
    impl From<Strt> for Operation {
        fn from(val: Strt) -> Operation {
            Operation::Strt(val)
        }
    }
    pub struct SubImmediate {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub imm: u32,
    }
    pub struct SubImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > SubImmediateBuilder<false, rdSET, rnSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> SubImmediateBuilder<true, rdSET, rnSET, immSET> {
            self.s = Some(s);
            SubImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > SubImmediateBuilder<sSET, false, rnSET, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SubImmediateBuilder<sSET, true, rnSET, immSET> {
            self.rd = Some(rd);
            SubImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > SubImmediateBuilder<sSET, rdSET, false, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SubImmediateBuilder<sSET, rdSET, true, immSET> {
            self.rn = Some(rn);
            SubImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
    > SubImmediateBuilder<sSET, rdSET, rnSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> SubImmediateBuilder<sSET, rdSET, rnSET, true> {
            self.imm = Some(imm);
            SubImmediateBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                imm: self.imm,
            }
        }
    }
    impl SubImmediateBuilder<false, false, false, false> {
        pub fn new() -> SubImmediateBuilder<false, false, false, false> {
            SubImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl SubImmediate {
        pub fn builder() -> SubImmediateBuilder<false, false, false, false> {
            SubImmediateBuilder {
                s: None,
                rd: None,
                rn: None,
                imm: None,
            }
        }
    }
    impl SubImmediateBuilder<true, true, true, true> {
        pub fn complete(self) -> SubImmediate {
            SubImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct SubImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > SubImmediateConsumer<false, rdCONSUMED, rnCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            SubImmediateConsumer<true, rdCONSUMED, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                SubImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > SubImmediateConsumer<sCONSUMED, false, rnCONSUMED, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SubImmediateConsumer<sCONSUMED, true, rnCONSUMED, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SubImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > SubImmediateConsumer<sCONSUMED, rdCONSUMED, false, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SubImmediateConsumer<sCONSUMED, rdCONSUMED, true, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SubImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > SubImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, SubImmediateConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                SubImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    imm: self.imm,
                },
            )
        }
    }
    impl SubImmediate {
        pub fn consumer(self) -> SubImmediateConsumer<false, false, false, false> {
            SubImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                imm: Some(self.imm),
            }
        }
    }
    impl SubImmediateConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SubImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "SubImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SubImmediate {
        #[inline]
        fn clone(&self) -> SubImmediate {
            SubImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SubImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SubImmediate {
        #[inline]
        fn eq(&self, other: &SubImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.imm == other.imm
        }
    }
    impl From<SubImmediate> for Operation {
        fn from(val: SubImmediate) -> Operation {
            Operation::SubImmediate(val)
        }
    }
    pub struct SubRegister {
        pub s: Option<SetFlags>,
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct SubRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > SubRegisterBuilder<false, rdSET, rnSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<SetFlags>,
        ) -> SubRegisterBuilder<true, rdSET, rnSET, rmSET, shiftSET> {
            self.s = Some(s);
            SubRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > SubRegisterBuilder<sSET, false, rnSET, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SubRegisterBuilder<sSET, true, rnSET, rmSET, shiftSET> {
            self.rd = Some(rd);
            SubRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > SubRegisterBuilder<sSET, rdSET, false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SubRegisterBuilder<sSET, rdSET, true, rmSET, shiftSET> {
            self.rn = Some(rn);
            SubRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > SubRegisterBuilder<sSET, rdSET, rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SubRegisterBuilder<sSET, rdSET, rnSET, true, shiftSET> {
            self.rm = Some(rm);
            SubRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SubRegisterBuilder<sSET, rdSET, rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> SubRegisterBuilder<sSET, rdSET, rnSET, rmSET, true> {
            self.shift = Some(shift);
            SubRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl SubRegisterBuilder<false, false, false, false, false> {
        pub fn new() -> SubRegisterBuilder<false, false, false, false, false> {
            SubRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl SubRegister {
        pub fn builder() -> SubRegisterBuilder<false, false, false, false, false> {
            SubRegisterBuilder {
                s: None,
                rd: None,
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl SubRegisterBuilder<true, true, true, true, true> {
        pub fn complete(self) -> SubRegister {
            SubRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct SubRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<SetFlags>>,
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SubRegisterConsumer<false, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<SetFlags>,
            SubRegisterConsumer<true, rdCONSUMED, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                SubRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SubRegisterConsumer<sCONSUMED, false, rnCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SubRegisterConsumer<sCONSUMED, true, rnCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SubRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SubRegisterConsumer<sCONSUMED, rdCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            SubRegisterConsumer<sCONSUMED, rdCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SubRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SubRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SubRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SubRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SubRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            SubRegisterConsumer<sCONSUMED, rdCONSUMED, rnCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                SubRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl SubRegister {
        pub fn consumer(self) -> SubRegisterConsumer<false, false, false, false, false> {
            SubRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl SubRegisterConsumer<true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SubRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SubRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SubRegister {
        #[inline]
        fn clone(&self) -> SubRegister {
            SubRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SubRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SubRegister {
        #[inline]
        fn eq(&self, other: &SubRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rn == other.rn
                && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<SubRegister> for Operation {
        fn from(val: SubRegister) -> Operation {
            Operation::SubRegister(val)
        }
    }
    pub struct Stc {
        pub coproc: CoProcessor,
        pub crd: u8,
        pub rn: Register,
        pub imm: Option<u32>,
        pub add: bool,
        pub w: bool,
        pub index: bool,
    }
    pub struct StcBuilder<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > {
        coproc: Option<CoProcessor>,
        crd: Option<u8>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
        add: Option<bool>,
        w: Option<bool>,
        index: Option<bool>,
    }
    impl<
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > StcBuilder<false, crdSET, rnSET, immSET, addSET, wSET, indexSET> {
        pub fn set_coproc(
            mut self,
            coproc: CoProcessor,
        ) -> StcBuilder<true, crdSET, rnSET, immSET, addSET, wSET, indexSET> {
            self.coproc = Some(coproc);
            StcBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > StcBuilder<coprocSET, false, rnSET, immSET, addSET, wSET, indexSET> {
        pub fn set_crd(
            mut self,
            crd: u8,
        ) -> StcBuilder<coprocSET, true, rnSET, immSET, addSET, wSET, indexSET> {
            self.crd = Some(crd);
            StcBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > StcBuilder<coprocSET, crdSET, false, immSET, addSET, wSET, indexSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> StcBuilder<coprocSET, crdSET, true, immSET, addSET, wSET, indexSET> {
            self.rn = Some(rn);
            StcBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > StcBuilder<coprocSET, crdSET, rnSET, false, addSET, wSET, indexSET> {
        pub fn set_imm(
            mut self,
            imm: Option<u32>,
        ) -> StcBuilder<coprocSET, crdSET, rnSET, true, addSET, wSET, indexSET> {
            self.imm = Some(imm);
            StcBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > StcBuilder<coprocSET, crdSET, rnSET, immSET, false, wSET, indexSET> {
        pub fn set_add(
            mut self,
            add: bool,
        ) -> StcBuilder<coprocSET, crdSET, rnSET, immSET, true, wSET, indexSET> {
            self.add = Some(add);
            StcBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const indexSET: bool,
    > StcBuilder<coprocSET, crdSET, rnSET, immSET, addSET, false, indexSET> {
        pub fn set_w(
            mut self,
            w: bool,
        ) -> StcBuilder<coprocSET, crdSET, rnSET, immSET, addSET, true, indexSET> {
            self.w = Some(w);
            StcBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
    > StcBuilder<coprocSET, crdSET, rnSET, immSET, addSET, wSET, false> {
        pub fn set_index(
            mut self,
            index: bool,
        ) -> StcBuilder<coprocSET, crdSET, rnSET, immSET, addSET, wSET, true> {
            self.index = Some(index);
            StcBuilder {
                coproc: self.coproc,
                crd: self.crd,
                rn: self.rn,
                imm: self.imm,
                add: self.add,
                w: self.w,
                index: self.index,
            }
        }
    }
    impl StcBuilder<false, false, false, false, false, false, false> {
        pub fn new() -> StcBuilder<false, false, false, false, false, false, false> {
            StcBuilder {
                coproc: None,
                crd: None,
                rn: None,
                imm: None,
                add: None,
                w: None,
                index: None,
            }
        }
    }
    impl Stc {
        pub fn builder() -> StcBuilder<false, false, false, false, false, false, false> {
            StcBuilder {
                coproc: None,
                crd: None,
                rn: None,
                imm: None,
                add: None,
                w: None,
                index: None,
            }
        }
    }
    impl StcBuilder<true, true, true, true, true, true, true> {
        pub fn complete(self) -> Stc {
            Stc {
                coproc: self.coproc.unwrap(),
                crd: self.crd.unwrap(),
                rn: self.rn.unwrap(),
                imm: self.imm.unwrap(),
                add: self.add.unwrap(),
                w: self.w.unwrap(),
                index: self.index.unwrap(),
            }
        }
    }
    pub struct StcConsumer<
        const coprocSET: bool,
        const crdSET: bool,
        const rnSET: bool,
        const immSET: bool,
        const addSET: bool,
        const wSET: bool,
        const indexSET: bool,
    > {
        coproc: Option<CoProcessor>,
        crd: Option<u8>,
        rn: Option<Register>,
        imm: Option<Option<u32>>,
        add: Option<bool>,
        w: Option<bool>,
        index: Option<bool>,
    }
    impl<
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > StcConsumer<
        false,
        crdCONSUMED,
        rnCONSUMED,
        immCONSUMED,
        addCONSUMED,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_coproc(
            mut self,
        ) -> (
            CoProcessor,
            StcConsumer<
                true,
                crdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                addCONSUMED,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.coproc.unwrap();
            self.coproc = None;
            (
                ret,
                StcConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > StcConsumer<
        coprocCONSUMED,
        false,
        rnCONSUMED,
        immCONSUMED,
        addCONSUMED,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_crd(
            mut self,
        ) -> (
            u8,
            StcConsumer<
                coprocCONSUMED,
                true,
                rnCONSUMED,
                immCONSUMED,
                addCONSUMED,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.crd.unwrap();
            self.crd = None;
            (
                ret,
                StcConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > StcConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        false,
        immCONSUMED,
        addCONSUMED,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            StcConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                true,
                immCONSUMED,
                addCONSUMED,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                StcConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > StcConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        rnCONSUMED,
        false,
        addCONSUMED,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_imm(
            mut self,
        ) -> (
            Option<u32>,
            StcConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                rnCONSUMED,
                true,
                addCONSUMED,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                StcConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const wCONSUMED: bool,
        const indexCONSUMED: bool,
    > StcConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        rnCONSUMED,
        immCONSUMED,
        false,
        wCONSUMED,
        indexCONSUMED,
    > {
        pub fn consume_add(
            mut self,
        ) -> (
            bool,
            StcConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                true,
                wCONSUMED,
                indexCONSUMED,
            >,
        ) {
            let ret = self.add.unwrap();
            self.add = None;
            (
                ret,
                StcConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const indexCONSUMED: bool,
    > StcConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        rnCONSUMED,
        immCONSUMED,
        addCONSUMED,
        false,
        indexCONSUMED,
    > {
        pub fn consume_w(
            mut self,
        ) -> (
            bool,
            StcConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                addCONSUMED,
                true,
                indexCONSUMED,
            >,
        ) {
            let ret = self.w.unwrap();
            self.w = None;
            (
                ret,
                StcConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl<
        const coprocCONSUMED: bool,
        const crdCONSUMED: bool,
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
        const addCONSUMED: bool,
        const wCONSUMED: bool,
    > StcConsumer<
        coprocCONSUMED,
        crdCONSUMED,
        rnCONSUMED,
        immCONSUMED,
        addCONSUMED,
        wCONSUMED,
        false,
    > {
        pub fn consume_index(
            mut self,
        ) -> (
            bool,
            StcConsumer<
                coprocCONSUMED,
                crdCONSUMED,
                rnCONSUMED,
                immCONSUMED,
                addCONSUMED,
                wCONSUMED,
                true,
            >,
        ) {
            let ret = self.index.unwrap();
            self.index = None;
            (
                ret,
                StcConsumer {
                    coproc: self.coproc,
                    crd: self.crd,
                    rn: self.rn,
                    imm: self.imm,
                    add: self.add,
                    w: self.w,
                    index: self.index,
                },
            )
        }
    }
    impl Stc {
        pub fn consumer(
            self,
        ) -> StcConsumer<false, false, false, false, false, false, false> {
            StcConsumer {
                coproc: Some(self.coproc),
                crd: Some(self.crd),
                rn: Some(self.rn),
                imm: Some(self.imm),
                add: Some(self.add),
                w: Some(self.w),
                index: Some(self.index),
            }
        }
    }
    impl StcConsumer<true, true, true, true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Stc {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["coproc", "crd", "rn", "imm", "add", "w", "index"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.coproc,
                &self.crd,
                &self.rn,
                &self.imm,
                &self.add,
                &self.w,
                &&self.index,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Stc", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Stc {
        #[inline]
        fn clone(&self) -> Stc {
            Stc {
                coproc: ::core::clone::Clone::clone(&self.coproc),
                crd: ::core::clone::Clone::clone(&self.crd),
                rn: ::core::clone::Clone::clone(&self.rn),
                imm: ::core::clone::Clone::clone(&self.imm),
                add: ::core::clone::Clone::clone(&self.add),
                w: ::core::clone::Clone::clone(&self.w),
                index: ::core::clone::Clone::clone(&self.index),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Stc {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Stc {
        #[inline]
        fn eq(&self, other: &Stc) -> bool {
            self.coproc == other.coproc && self.crd == other.crd && self.rn == other.rn
                && self.imm == other.imm && self.add == other.add && self.w == other.w
                && self.index == other.index
        }
    }
    impl From<Stc> for Operation {
        fn from(val: Stc) -> Operation {
            Operation::Stc(val)
        }
    }
    pub struct SubSpMinusImmediate {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub imm: u32,
    }
    pub struct SubSpMinusImmediateBuilder<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        imm: Option<u32>,
    }
    impl<
        const rdSET: bool,
        const immSET: bool,
    > SubSpMinusImmediateBuilder<false, rdSET, immSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> SubSpMinusImmediateBuilder<true, rdSET, immSET> {
            self.s = Some(s);
            SubSpMinusImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const immSET: bool,
    > SubSpMinusImmediateBuilder<sSET, false, immSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SubSpMinusImmediateBuilder<sSET, true, immSET> {
            self.rd = Some(rd);
            SubSpMinusImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
    > SubSpMinusImmediateBuilder<sSET, rdSET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> SubSpMinusImmediateBuilder<sSET, rdSET, true> {
            self.imm = Some(imm);
            SubSpMinusImmediateBuilder {
                s: self.s,
                rd: self.rd,
                imm: self.imm,
            }
        }
    }
    impl SubSpMinusImmediateBuilder<false, false, false> {
        pub fn new() -> SubSpMinusImmediateBuilder<false, false, false> {
            SubSpMinusImmediateBuilder {
                s: None,
                rd: None,
                imm: None,
            }
        }
    }
    impl SubSpMinusImmediate {
        pub fn builder() -> SubSpMinusImmediateBuilder<false, false, false> {
            SubSpMinusImmediateBuilder {
                s: None,
                rd: None,
                imm: None,
            }
        }
    }
    impl SubSpMinusImmediateBuilder<true, true, true> {
        pub fn complete(self) -> SubSpMinusImmediate {
            SubSpMinusImmediate {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct SubSpMinusImmediateConsumer<
        const sSET: bool,
        const rdSET: bool,
        const immSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        imm: Option<u32>,
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > SubSpMinusImmediateConsumer<false, rdCONSUMED, immCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (Option<bool>, SubSpMinusImmediateConsumer<true, rdCONSUMED, immCONSUMED>) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                SubSpMinusImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const immCONSUMED: bool,
    > SubSpMinusImmediateConsumer<sCONSUMED, false, immCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SubSpMinusImmediateConsumer<sCONSUMED, true, immCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SubSpMinusImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
    > SubSpMinusImmediateConsumer<sCONSUMED, rdCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, SubSpMinusImmediateConsumer<sCONSUMED, rdCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                SubSpMinusImmediateConsumer {
                    s: self.s,
                    rd: self.rd,
                    imm: self.imm,
                },
            )
        }
    }
    impl SubSpMinusImmediate {
        pub fn consumer(self) -> SubSpMinusImmediateConsumer<false, false, false> {
            SubSpMinusImmediateConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                imm: Some(self.imm),
            }
        }
    }
    impl SubSpMinusImmediateConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SubSpMinusImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "SubSpMinusImmediate",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SubSpMinusImmediate {
        #[inline]
        fn clone(&self) -> SubSpMinusImmediate {
            SubSpMinusImmediate {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SubSpMinusImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SubSpMinusImmediate {
        #[inline]
        fn eq(&self, other: &SubSpMinusImmediate) -> bool {
            self.s == other.s && self.rd == other.rd && self.imm == other.imm
        }
    }
    impl From<SubSpMinusImmediate> for Operation {
        fn from(val: SubSpMinusImmediate) -> Operation {
            Operation::SubSpMinusImmediate(val)
        }
    }
    pub struct SubSpMinusRegister {
        pub s: Option<bool>,
        pub rd: Option<Register>,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct SubSpMinusRegisterBuilder<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > SubSpMinusRegisterBuilder<false, rdSET, rmSET, shiftSET> {
        pub fn set_s(
            mut self,
            s: Option<bool>,
        ) -> SubSpMinusRegisterBuilder<true, rdSET, rmSET, shiftSET> {
            self.s = Some(s);
            SubSpMinusRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > SubSpMinusRegisterBuilder<sSET, false, rmSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SubSpMinusRegisterBuilder<sSET, true, rmSET, shiftSET> {
            self.rd = Some(rd);
            SubSpMinusRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const shiftSET: bool,
    > SubSpMinusRegisterBuilder<sSET, rdSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SubSpMinusRegisterBuilder<sSET, rdSET, true, shiftSET> {
            self.rm = Some(rm);
            SubSpMinusRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
    > SubSpMinusRegisterBuilder<sSET, rdSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> SubSpMinusRegisterBuilder<sSET, rdSET, rmSET, true> {
            self.shift = Some(shift);
            SubSpMinusRegisterBuilder {
                s: self.s,
                rd: self.rd,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl SubSpMinusRegisterBuilder<false, false, false, false> {
        pub fn new() -> SubSpMinusRegisterBuilder<false, false, false, false> {
            SubSpMinusRegisterBuilder {
                s: None,
                rd: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl SubSpMinusRegister {
        pub fn builder() -> SubSpMinusRegisterBuilder<false, false, false, false> {
            SubSpMinusRegisterBuilder {
                s: None,
                rd: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl SubSpMinusRegisterBuilder<true, true, true, true> {
        pub fn complete(self) -> SubSpMinusRegister {
            SubSpMinusRegister {
                s: self.s.unwrap(),
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct SubSpMinusRegisterConsumer<
        const sSET: bool,
        const rdSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        s: Option<Option<bool>>,
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SubSpMinusRegisterConsumer<false, rdCONSUMED, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_s(
            mut self,
        ) -> (
            Option<bool>,
            SubSpMinusRegisterConsumer<true, rdCONSUMED, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.s.unwrap();
            self.s = None;
            (
                ret,
                SubSpMinusRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SubSpMinusRegisterConsumer<sCONSUMED, false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SubSpMinusRegisterConsumer<sCONSUMED, true, rmCONSUMED, shiftCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SubSpMinusRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const shiftCONSUMED: bool,
    > SubSpMinusRegisterConsumer<sCONSUMED, rdCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            SubSpMinusRegisterConsumer<sCONSUMED, rdCONSUMED, true, shiftCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SubSpMinusRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const sCONSUMED: bool,
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SubSpMinusRegisterConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            SubSpMinusRegisterConsumer<sCONSUMED, rdCONSUMED, rmCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                SubSpMinusRegisterConsumer {
                    s: self.s,
                    rd: self.rd,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl SubSpMinusRegister {
        pub fn consumer(self) -> SubSpMinusRegisterConsumer<false, false, false, false> {
            SubSpMinusRegisterConsumer {
                s: Some(self.s),
                rd: Some(self.rd),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl SubSpMinusRegisterConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SubSpMinusRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "SubSpMinusRegister",
                "s",
                &self.s,
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SubSpMinusRegister {
        #[inline]
        fn clone(&self) -> SubSpMinusRegister {
            SubSpMinusRegister {
                s: ::core::clone::Clone::clone(&self.s),
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SubSpMinusRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SubSpMinusRegister {
        #[inline]
        fn eq(&self, other: &SubSpMinusRegister) -> bool {
            self.s == other.s && self.rd == other.rd && self.rm == other.rm
                && self.shift == other.shift
        }
    }
    impl From<SubSpMinusRegister> for Operation {
        fn from(val: SubSpMinusRegister) -> Operation {
            Operation::SubSpMinusRegister(val)
        }
    }
    pub struct Sxtab {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct SxtabBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > SxtabBuilder<false, rnSET, rmSET, rotationSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SxtabBuilder<true, rnSET, rmSET, rotationSET> {
            self.rd = Some(rd);
            SxtabBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > SxtabBuilder<rdSET, false, rmSET, rotationSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SxtabBuilder<rdSET, true, rmSET, rotationSET> {
            self.rn = Some(rn);
            SxtabBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rotationSET: bool,
    > SxtabBuilder<rdSET, rnSET, false, rotationSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SxtabBuilder<rdSET, rnSET, true, rotationSET> {
            self.rm = Some(rm);
            SxtabBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SxtabBuilder<rdSET, rnSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> SxtabBuilder<rdSET, rnSET, rmSET, true> {
            self.rotation = Some(rotation);
            SxtabBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl SxtabBuilder<false, false, false, false> {
        pub fn new() -> SxtabBuilder<false, false, false, false> {
            SxtabBuilder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Sxtab {
        pub fn builder() -> SxtabBuilder<false, false, false, false> {
            SxtabBuilder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl SxtabBuilder<true, true, true, true> {
        pub fn complete(self) -> Sxtab {
            Sxtab {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct SxtabConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxtabConsumer<false, rnCONSUMED, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SxtabConsumer<true, rnCONSUMED, rmCONSUMED, rotationCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SxtabConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxtabConsumer<rdCONSUMED, false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SxtabConsumer<rdCONSUMED, true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SxtabConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxtabConsumer<rdCONSUMED, rnCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SxtabConsumer<rdCONSUMED, rnCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SxtabConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SxtabConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, SxtabConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                SxtabConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Sxtab {
        pub fn consumer(self) -> SxtabConsumer<false, false, false, false> {
            SxtabConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl SxtabConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sxtab {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Sxtab",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sxtab {
        #[inline]
        fn clone(&self) -> Sxtab {
            Sxtab {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sxtab {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sxtab {
        #[inline]
        fn eq(&self, other: &Sxtab) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.rotation == other.rotation
        }
    }
    impl From<Sxtab> for Operation {
        fn from(val: Sxtab) -> Operation {
            Operation::Sxtab(val)
        }
    }
    pub struct Sxtab16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct Sxtab16Builder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > Sxtab16Builder<false, rnSET, rmSET, rotationSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Sxtab16Builder<true, rnSET, rmSET, rotationSET> {
            self.rd = Some(rd);
            Sxtab16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > Sxtab16Builder<rdSET, false, rmSET, rotationSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> Sxtab16Builder<rdSET, true, rmSET, rotationSET> {
            self.rn = Some(rn);
            Sxtab16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rotationSET: bool,
    > Sxtab16Builder<rdSET, rnSET, false, rotationSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> Sxtab16Builder<rdSET, rnSET, true, rotationSET> {
            self.rm = Some(rm);
            Sxtab16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > Sxtab16Builder<rdSET, rnSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> Sxtab16Builder<rdSET, rnSET, rmSET, true> {
            self.rotation = Some(rotation);
            Sxtab16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl Sxtab16Builder<false, false, false, false> {
        pub fn new() -> Sxtab16Builder<false, false, false, false> {
            Sxtab16Builder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Sxtab16 {
        pub fn builder() -> Sxtab16Builder<false, false, false, false> {
            Sxtab16Builder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Sxtab16Builder<true, true, true, true> {
        pub fn complete(self) -> Sxtab16 {
            Sxtab16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct Sxtab16Consumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Sxtab16Consumer<false, rnCONSUMED, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            Sxtab16Consumer<true, rnCONSUMED, rmCONSUMED, rotationCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Sxtab16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Sxtab16Consumer<rdCONSUMED, false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            Sxtab16Consumer<rdCONSUMED, true, rmCONSUMED, rotationCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Sxtab16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Sxtab16Consumer<rdCONSUMED, rnCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            Sxtab16Consumer<rdCONSUMED, rnCONSUMED, true, rotationCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Sxtab16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Sxtab16Consumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, Sxtab16Consumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                Sxtab16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Sxtab16 {
        pub fn consumer(self) -> Sxtab16Consumer<false, false, false, false> {
            Sxtab16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl Sxtab16Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sxtab16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Sxtab16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sxtab16 {
        #[inline]
        fn clone(&self) -> Sxtab16 {
            Sxtab16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sxtab16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sxtab16 {
        #[inline]
        fn eq(&self, other: &Sxtab16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.rotation == other.rotation
        }
    }
    impl From<Sxtab16> for Operation {
        fn from(val: Sxtab16) -> Operation {
            Operation::Sxtab16(val)
        }
    }
    pub struct Sxtah {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct SxtahBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > SxtahBuilder<false, rnSET, rmSET, rotationSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> SxtahBuilder<true, rnSET, rmSET, rotationSET> {
            self.rd = Some(rd);
            SxtahBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > SxtahBuilder<rdSET, false, rmSET, rotationSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> SxtahBuilder<rdSET, true, rmSET, rotationSET> {
            self.rn = Some(rn);
            SxtahBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rotationSET: bool,
    > SxtahBuilder<rdSET, rnSET, false, rotationSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> SxtahBuilder<rdSET, rnSET, true, rotationSET> {
            self.rm = Some(rm);
            SxtahBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > SxtahBuilder<rdSET, rnSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> SxtahBuilder<rdSET, rnSET, rmSET, true> {
            self.rotation = Some(rotation);
            SxtahBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl SxtahBuilder<false, false, false, false> {
        pub fn new() -> SxtahBuilder<false, false, false, false> {
            SxtahBuilder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Sxtah {
        pub fn builder() -> SxtahBuilder<false, false, false, false> {
            SxtahBuilder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl SxtahBuilder<true, true, true, true> {
        pub fn complete(self) -> Sxtah {
            Sxtah {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct SxtahConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxtahConsumer<false, rnCONSUMED, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            SxtahConsumer<true, rnCONSUMED, rmCONSUMED, rotationCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SxtahConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxtahConsumer<rdCONSUMED, false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, SxtahConsumer<rdCONSUMED, true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                SxtahConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxtahConsumer<rdCONSUMED, rnCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SxtahConsumer<rdCONSUMED, rnCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SxtahConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > SxtahConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, SxtahConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                SxtahConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Sxtah {
        pub fn consumer(self) -> SxtahConsumer<false, false, false, false> {
            SxtahConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl SxtahConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sxtah {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Sxtah",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sxtah {
        #[inline]
        fn clone(&self) -> Sxtah {
            Sxtah {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sxtah {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sxtah {
        #[inline]
        fn eq(&self, other: &Sxtah) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.rotation == other.rotation
        }
    }
    impl From<Sxtah> for Operation {
        fn from(val: Sxtah) -> Operation {
            Operation::Sxtah(val)
        }
    }
    pub struct Sxtb {
        pub rd: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct SxtbBuilder<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmSET: bool,
        const rotationSET: bool,
    > SxtbBuilder<false, rmSET, rotationSET> {
        pub fn set_rd(mut self, rd: Register) -> SxtbBuilder<true, rmSET, rotationSET> {
            self.rd = Some(rd);
            SxtbBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rotationSET: bool,
    > SxtbBuilder<rdSET, false, rotationSET> {
        pub fn set_rm(mut self, rm: Register) -> SxtbBuilder<rdSET, true, rotationSET> {
            self.rm = Some(rm);
            SxtbBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> SxtbBuilder<rdSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> SxtbBuilder<rdSET, rmSET, true> {
            self.rotation = Some(rotation);
            SxtbBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl SxtbBuilder<false, false, false> {
        pub fn new() -> SxtbBuilder<false, false, false> {
            SxtbBuilder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Sxtb {
        pub fn builder() -> SxtbBuilder<false, false, false> {
            SxtbBuilder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl SxtbBuilder<true, true, true> {
        pub fn complete(self) -> Sxtb {
            Sxtb {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct SxtbConsumer<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxtbConsumer<false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, SxtbConsumer<true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SxtbConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxtbConsumer<rdCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SxtbConsumer<rdCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SxtbConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SxtbConsumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, SxtbConsumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                SxtbConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Sxtb {
        pub fn consumer(self) -> SxtbConsumer<false, false, false> {
            SxtbConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl SxtbConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sxtb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Sxtb",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sxtb {
        #[inline]
        fn clone(&self) -> Sxtb {
            Sxtb {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sxtb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sxtb {
        #[inline]
        fn eq(&self, other: &Sxtb) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rotation == other.rotation
        }
    }
    impl From<Sxtb> for Operation {
        fn from(val: Sxtb) -> Operation {
            Operation::Sxtb(val)
        }
    }
    pub struct Sxtb16 {
        pub rd: Option<Register>,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct Sxtb16Builder<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmSET: bool,
        const rotationSET: bool,
    > Sxtb16Builder<false, rmSET, rotationSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Sxtb16Builder<true, rmSET, rotationSET> {
            self.rd = Some(rd);
            Sxtb16Builder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rotationSET: bool,
    > Sxtb16Builder<rdSET, false, rotationSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> Sxtb16Builder<rdSET, true, rotationSET> {
            self.rm = Some(rm);
            Sxtb16Builder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Sxtb16Builder<rdSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> Sxtb16Builder<rdSET, rmSET, true> {
            self.rotation = Some(rotation);
            Sxtb16Builder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl Sxtb16Builder<false, false, false> {
        pub fn new() -> Sxtb16Builder<false, false, false> {
            Sxtb16Builder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Sxtb16 {
        pub fn builder() -> Sxtb16Builder<false, false, false> {
            Sxtb16Builder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Sxtb16Builder<true, true, true> {
        pub fn complete(self) -> Sxtb16 {
            Sxtb16 {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct Sxtb16Consumer<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Sxtb16Consumer<false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Sxtb16Consumer<true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Sxtb16Consumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Sxtb16Consumer<rdCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Sxtb16Consumer<rdCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Sxtb16Consumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Sxtb16Consumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, Sxtb16Consumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                Sxtb16Consumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Sxtb16 {
        pub fn consumer(self) -> Sxtb16Consumer<false, false, false> {
            Sxtb16Consumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl Sxtb16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sxtb16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Sxtb16",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sxtb16 {
        #[inline]
        fn clone(&self) -> Sxtb16 {
            Sxtb16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sxtb16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sxtb16 {
        #[inline]
        fn eq(&self, other: &Sxtb16) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rotation == other.rotation
        }
    }
    impl From<Sxtb16> for Operation {
        fn from(val: Sxtb16) -> Operation {
            Operation::Sxtb16(val)
        }
    }
    pub struct Sxth {
        pub rd: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct SxthBuilder<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmSET: bool,
        const rotationSET: bool,
    > SxthBuilder<false, rmSET, rotationSET> {
        pub fn set_rd(mut self, rd: Register) -> SxthBuilder<true, rmSET, rotationSET> {
            self.rd = Some(rd);
            SxthBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rotationSET: bool,
    > SxthBuilder<rdSET, false, rotationSET> {
        pub fn set_rm(mut self, rm: Register) -> SxthBuilder<rdSET, true, rotationSET> {
            self.rm = Some(rm);
            SxthBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> SxthBuilder<rdSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> SxthBuilder<rdSET, rmSET, true> {
            self.rotation = Some(rotation);
            SxthBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl SxthBuilder<false, false, false> {
        pub fn new() -> SxthBuilder<false, false, false> {
            SxthBuilder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Sxth {
        pub fn builder() -> SxthBuilder<false, false, false> {
            SxthBuilder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl SxthBuilder<true, true, true> {
        pub fn complete(self) -> Sxth {
            Sxth {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct SxthConsumer<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxthConsumer<false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, SxthConsumer<true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                SxthConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rotationCONSUMED: bool,
    > SxthConsumer<rdCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, SxthConsumer<rdCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                SxthConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > SxthConsumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, SxthConsumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                SxthConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Sxth {
        pub fn consumer(self) -> SxthConsumer<false, false, false> {
            SxthConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl SxthConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sxth {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Sxth",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sxth {
        #[inline]
        fn clone(&self) -> Sxth {
            Sxth {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sxth {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sxth {
        #[inline]
        fn eq(&self, other: &Sxth) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rotation == other.rotation
        }
    }
    impl From<Sxth> for Operation {
        fn from(val: Sxth) -> Operation {
            Operation::Sxth(val)
        }
    }
    pub struct Tb {
        pub is_tbh: Option<bool>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct TbBuilder<const is_tbhSET: bool, const rnSET: bool, const rmSET: bool> {
        is_tbh: Option<Option<bool>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> TbBuilder<false, rnSET, rmSET> {
        pub fn set_is_tbh(
            mut self,
            is_tbh: Option<bool>,
        ) -> TbBuilder<true, rnSET, rmSET> {
            self.is_tbh = Some(is_tbh);
            TbBuilder {
                is_tbh: self.is_tbh,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const is_tbhSET: bool, const rmSET: bool> TbBuilder<is_tbhSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> TbBuilder<is_tbhSET, true, rmSET> {
            self.rn = Some(rn);
            TbBuilder {
                is_tbh: self.is_tbh,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const is_tbhSET: bool, const rnSET: bool> TbBuilder<is_tbhSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> TbBuilder<is_tbhSET, rnSET, true> {
            self.rm = Some(rm);
            TbBuilder {
                is_tbh: self.is_tbh,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl TbBuilder<false, false, false> {
        pub fn new() -> TbBuilder<false, false, false> {
            TbBuilder {
                is_tbh: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Tb {
        pub fn builder() -> TbBuilder<false, false, false> {
            TbBuilder {
                is_tbh: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl TbBuilder<true, true, true> {
        pub fn complete(self) -> Tb {
            Tb {
                is_tbh: self.is_tbh.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct TbConsumer<const is_tbhSET: bool, const rnSET: bool, const rmSET: bool> {
        is_tbh: Option<Option<bool>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > TbConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_is_tbh(
            mut self,
        ) -> (Option<bool>, TbConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.is_tbh.unwrap();
            self.is_tbh = None;
            (
                ret,
                TbConsumer {
                    is_tbh: self.is_tbh,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const is_tbhCONSUMED: bool,
        const rmCONSUMED: bool,
    > TbConsumer<is_tbhCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, TbConsumer<is_tbhCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                TbConsumer {
                    is_tbh: self.is_tbh,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const is_tbhCONSUMED: bool,
        const rnCONSUMED: bool,
    > TbConsumer<is_tbhCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, TbConsumer<is_tbhCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                TbConsumer {
                    is_tbh: self.is_tbh,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Tb {
        pub fn consumer(self) -> TbConsumer<false, false, false> {
            TbConsumer {
                is_tbh: Some(self.is_tbh),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl TbConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Tb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Tb",
                "is_tbh",
                &self.is_tbh,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Tb {
        #[inline]
        fn clone(&self) -> Tb {
            Tb {
                is_tbh: ::core::clone::Clone::clone(&self.is_tbh),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Tb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Tb {
        #[inline]
        fn eq(&self, other: &Tb) -> bool {
            self.is_tbh == other.is_tbh && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Tb> for Operation {
        fn from(val: Tb) -> Operation {
            Operation::Tb(val)
        }
    }
    pub struct TeqImmediate {
        pub rn: Register,
        pub carry: Option<bool>,
        pub imm: u32,
    }
    pub struct TeqImmediateBuilder<
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        rn: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const carrySET: bool,
        const immSET: bool,
    > TeqImmediateBuilder<false, carrySET, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> TeqImmediateBuilder<true, carrySET, immSET> {
            self.rn = Some(rn);
            TeqImmediateBuilder {
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const rnSET: bool,
        const immSET: bool,
    > TeqImmediateBuilder<rnSET, false, immSET> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> TeqImmediateBuilder<rnSET, true, immSET> {
            self.carry = Some(carry);
            TeqImmediateBuilder {
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const rnSET: bool,
        const carrySET: bool,
    > TeqImmediateBuilder<rnSET, carrySET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> TeqImmediateBuilder<rnSET, carrySET, true> {
            self.imm = Some(imm);
            TeqImmediateBuilder {
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl TeqImmediateBuilder<false, false, false> {
        pub fn new() -> TeqImmediateBuilder<false, false, false> {
            TeqImmediateBuilder {
                rn: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl TeqImmediate {
        pub fn builder() -> TeqImmediateBuilder<false, false, false> {
            TeqImmediateBuilder {
                rn: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl TeqImmediateBuilder<true, true, true> {
        pub fn complete(self) -> TeqImmediate {
            TeqImmediate {
                rn: self.rn.unwrap(),
                carry: self.carry.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct TeqImmediateConsumer<
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        rn: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > TeqImmediateConsumer<false, carryCONSUMED, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, TeqImmediateConsumer<true, carryCONSUMED, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                TeqImmediateConsumer {
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > TeqImmediateConsumer<rnCONSUMED, false, immCONSUMED> {
        pub fn consume_carry(
            mut self,
        ) -> (Option<bool>, TeqImmediateConsumer<rnCONSUMED, true, immCONSUMED>) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                TeqImmediateConsumer {
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
    > TeqImmediateConsumer<rnCONSUMED, carryCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, TeqImmediateConsumer<rnCONSUMED, carryCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                TeqImmediateConsumer {
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl TeqImmediate {
        pub fn consumer(self) -> TeqImmediateConsumer<false, false, false> {
            TeqImmediateConsumer {
                rn: Some(self.rn),
                carry: Some(self.carry),
                imm: Some(self.imm),
            }
        }
    }
    impl TeqImmediateConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TeqImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TeqImmediate",
                "rn",
                &self.rn,
                "carry",
                &self.carry,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TeqImmediate {
        #[inline]
        fn clone(&self) -> TeqImmediate {
            TeqImmediate {
                rn: ::core::clone::Clone::clone(&self.rn),
                carry: ::core::clone::Clone::clone(&self.carry),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TeqImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TeqImmediate {
        #[inline]
        fn eq(&self, other: &TeqImmediate) -> bool {
            self.rn == other.rn && self.carry == other.carry && self.imm == other.imm
        }
    }
    impl From<TeqImmediate> for Operation {
        fn from(val: TeqImmediate) -> Operation {
            Operation::TeqImmediate(val)
        }
    }
    pub struct TeqRegister {
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct TeqRegisterBuilder<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmSET: bool,
        const shiftSET: bool,
    > TeqRegisterBuilder<false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> TeqRegisterBuilder<true, rmSET, shiftSET> {
            self.rn = Some(rn);
            TeqRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rnSET: bool,
        const shiftSET: bool,
    > TeqRegisterBuilder<rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> TeqRegisterBuilder<rnSET, true, shiftSET> {
            self.rm = Some(rm);
            TeqRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<const rnSET: bool, const rmSET: bool> TeqRegisterBuilder<rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> TeqRegisterBuilder<rnSET, rmSET, true> {
            self.shift = Some(shift);
            TeqRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl TeqRegisterBuilder<false, false, false> {
        pub fn new() -> TeqRegisterBuilder<false, false, false> {
            TeqRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl TeqRegister {
        pub fn builder() -> TeqRegisterBuilder<false, false, false> {
            TeqRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl TeqRegisterBuilder<true, true, true> {
        pub fn complete(self) -> TeqRegister {
            TeqRegister {
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct TeqRegisterConsumer<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > TeqRegisterConsumer<false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, TeqRegisterConsumer<true, rmCONSUMED, shiftCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                TeqRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > TeqRegisterConsumer<rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, TeqRegisterConsumer<rnCONSUMED, true, shiftCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                TeqRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > TeqRegisterConsumer<rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (Option<ImmShift>, TeqRegisterConsumer<rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                TeqRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl TeqRegister {
        pub fn consumer(self) -> TeqRegisterConsumer<false, false, false> {
            TeqRegisterConsumer {
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl TeqRegisterConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TeqRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TeqRegister",
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TeqRegister {
        #[inline]
        fn clone(&self) -> TeqRegister {
            TeqRegister {
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TeqRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TeqRegister {
        #[inline]
        fn eq(&self, other: &TeqRegister) -> bool {
            self.rn == other.rn && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<TeqRegister> for Operation {
        fn from(val: TeqRegister) -> Operation {
            Operation::TeqRegister(val)
        }
    }
    pub struct TstImmediate {
        pub rn: Register,
        pub carry: Option<bool>,
        pub imm: u32,
    }
    pub struct TstImmediateBuilder<
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        rn: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const carrySET: bool,
        const immSET: bool,
    > TstImmediateBuilder<false, carrySET, immSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> TstImmediateBuilder<true, carrySET, immSET> {
            self.rn = Some(rn);
            TstImmediateBuilder {
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const rnSET: bool,
        const immSET: bool,
    > TstImmediateBuilder<rnSET, false, immSET> {
        pub fn set_carry(
            mut self,
            carry: Option<bool>,
        ) -> TstImmediateBuilder<rnSET, true, immSET> {
            self.carry = Some(carry);
            TstImmediateBuilder {
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl<
        const rnSET: bool,
        const carrySET: bool,
    > TstImmediateBuilder<rnSET, carrySET, false> {
        pub fn set_imm(
            mut self,
            imm: u32,
        ) -> TstImmediateBuilder<rnSET, carrySET, true> {
            self.imm = Some(imm);
            TstImmediateBuilder {
                rn: self.rn,
                carry: self.carry,
                imm: self.imm,
            }
        }
    }
    impl TstImmediateBuilder<false, false, false> {
        pub fn new() -> TstImmediateBuilder<false, false, false> {
            TstImmediateBuilder {
                rn: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl TstImmediate {
        pub fn builder() -> TstImmediateBuilder<false, false, false> {
            TstImmediateBuilder {
                rn: None,
                carry: None,
                imm: None,
            }
        }
    }
    impl TstImmediateBuilder<true, true, true> {
        pub fn complete(self) -> TstImmediate {
            TstImmediate {
                rn: self.rn.unwrap(),
                carry: self.carry.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct TstImmediateConsumer<
        const rnSET: bool,
        const carrySET: bool,
        const immSET: bool,
    > {
        rn: Option<Register>,
        carry: Option<Option<bool>>,
        imm: Option<u32>,
    }
    impl<
        const carryCONSUMED: bool,
        const immCONSUMED: bool,
    > TstImmediateConsumer<false, carryCONSUMED, immCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, TstImmediateConsumer<true, carryCONSUMED, immCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                TstImmediateConsumer {
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const immCONSUMED: bool,
    > TstImmediateConsumer<rnCONSUMED, false, immCONSUMED> {
        pub fn consume_carry(
            mut self,
        ) -> (Option<bool>, TstImmediateConsumer<rnCONSUMED, true, immCONSUMED>) {
            let ret = self.carry.unwrap();
            self.carry = None;
            (
                ret,
                TstImmediateConsumer {
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const carryCONSUMED: bool,
    > TstImmediateConsumer<rnCONSUMED, carryCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, TstImmediateConsumer<rnCONSUMED, carryCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                TstImmediateConsumer {
                    rn: self.rn,
                    carry: self.carry,
                    imm: self.imm,
                },
            )
        }
    }
    impl TstImmediate {
        pub fn consumer(self) -> TstImmediateConsumer<false, false, false> {
            TstImmediateConsumer {
                rn: Some(self.rn),
                carry: Some(self.carry),
                imm: Some(self.imm),
            }
        }
    }
    impl TstImmediateConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TstImmediate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TstImmediate",
                "rn",
                &self.rn,
                "carry",
                &self.carry,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TstImmediate {
        #[inline]
        fn clone(&self) -> TstImmediate {
            TstImmediate {
                rn: ::core::clone::Clone::clone(&self.rn),
                carry: ::core::clone::Clone::clone(&self.carry),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TstImmediate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TstImmediate {
        #[inline]
        fn eq(&self, other: &TstImmediate) -> bool {
            self.rn == other.rn && self.carry == other.carry && self.imm == other.imm
        }
    }
    impl From<TstImmediate> for Operation {
        fn from(val: TstImmediate) -> Operation {
            Operation::TstImmediate(val)
        }
    }
    pub struct TstRegister {
        pub rn: Register,
        pub rm: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct TstRegisterBuilder<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmSET: bool,
        const shiftSET: bool,
    > TstRegisterBuilder<false, rmSET, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> TstRegisterBuilder<true, rmSET, shiftSET> {
            self.rn = Some(rn);
            TstRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<
        const rnSET: bool,
        const shiftSET: bool,
    > TstRegisterBuilder<rnSET, false, shiftSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> TstRegisterBuilder<rnSET, true, shiftSET> {
            self.rm = Some(rm);
            TstRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl<const rnSET: bool, const rmSET: bool> TstRegisterBuilder<rnSET, rmSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> TstRegisterBuilder<rnSET, rmSET, true> {
            self.shift = Some(shift);
            TstRegisterBuilder {
                rn: self.rn,
                rm: self.rm,
                shift: self.shift,
            }
        }
    }
    impl TstRegisterBuilder<false, false, false> {
        pub fn new() -> TstRegisterBuilder<false, false, false> {
            TstRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl TstRegister {
        pub fn builder() -> TstRegisterBuilder<false, false, false> {
            TstRegisterBuilder {
                rn: None,
                rm: None,
                shift: None,
            }
        }
    }
    impl TstRegisterBuilder<true, true, true> {
        pub fn complete(self) -> TstRegister {
            TstRegister {
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct TstRegisterConsumer<
        const rnSET: bool,
        const rmSET: bool,
        const shiftSET: bool,
    > {
        rn: Option<Register>,
        rm: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const rmCONSUMED: bool,
        const shiftCONSUMED: bool,
    > TstRegisterConsumer<false, rmCONSUMED, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, TstRegisterConsumer<true, rmCONSUMED, shiftCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                TstRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > TstRegisterConsumer<rnCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, TstRegisterConsumer<rnCONSUMED, true, shiftCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                TstRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > TstRegisterConsumer<rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (Option<ImmShift>, TstRegisterConsumer<rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                TstRegisterConsumer {
                    rn: self.rn,
                    rm: self.rm,
                    shift: self.shift,
                },
            )
        }
    }
    impl TstRegister {
        pub fn consumer(self) -> TstRegisterConsumer<false, false, false> {
            TstRegisterConsumer {
                rn: Some(self.rn),
                rm: Some(self.rm),
                shift: Some(self.shift),
            }
        }
    }
    impl TstRegisterConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TstRegister {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TstRegister",
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TstRegister {
        #[inline]
        fn clone(&self) -> TstRegister {
            TstRegister {
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TstRegister {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TstRegister {
        #[inline]
        fn eq(&self, other: &TstRegister) -> bool {
            self.rn == other.rn && self.rm == other.rm && self.shift == other.shift
        }
    }
    impl From<TstRegister> for Operation {
        fn from(val: TstRegister) -> Operation {
            Operation::TstRegister(val)
        }
    }
    pub struct Uadd16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uadd16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uadd16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uadd16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uadd16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uadd16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uadd16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uadd16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uadd16Builder<false, false, false> {
        pub fn new() -> Uadd16Builder<false, false, false> {
            Uadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uadd16 {
        pub fn builder() -> Uadd16Builder<false, false, false> {
            Uadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uadd16Builder<true, true, true> {
        pub fn complete(self) -> Uadd16 {
            Uadd16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uadd16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uadd16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uadd16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uadd16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uadd16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uadd16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uadd16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uadd16 {
        pub fn consumer(self) -> Uadd16Consumer<false, false, false> {
            Uadd16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uadd16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uadd16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uadd16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uadd16 {
        #[inline]
        fn clone(&self) -> Uadd16 {
            Uadd16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uadd16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uadd16 {
        #[inline]
        fn eq(&self, other: &Uadd16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uadd16> for Operation {
        fn from(val: Uadd16) -> Operation {
            Operation::Uadd16(val)
        }
    }
    pub struct Uadd8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uadd8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uadd8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uadd8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uadd8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uadd8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uadd8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uadd8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uadd8Builder<false, false, false> {
        pub fn new() -> Uadd8Builder<false, false, false> {
            Uadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uadd8 {
        pub fn builder() -> Uadd8Builder<false, false, false> {
            Uadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uadd8Builder<true, true, true> {
        pub fn complete(self) -> Uadd8 {
            Uadd8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uadd8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uadd8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uadd8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uadd8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uadd8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uadd8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uadd8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uadd8 {
        pub fn consumer(self) -> Uadd8Consumer<false, false, false> {
            Uadd8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uadd8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uadd8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uadd8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uadd8 {
        #[inline]
        fn clone(&self) -> Uadd8 {
            Uadd8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uadd8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uadd8 {
        #[inline]
        fn eq(&self, other: &Uadd8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uadd8> for Operation {
        fn from(val: Uadd8) -> Operation {
            Operation::Uadd8(val)
        }
    }
    pub struct Uasx {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UasxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> UasxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UasxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            UasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UasxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> UasxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            UasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> UasxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> UasxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            UasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UasxBuilder<false, false, false> {
        pub fn new() -> UasxBuilder<false, false, false> {
            UasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uasx {
        pub fn builder() -> UasxBuilder<false, false, false> {
            UasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UasxBuilder<true, true, true> {
        pub fn complete(self) -> Uasx {
            Uasx {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UasxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UasxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, UasxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UasxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UasxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > UasxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UasxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uasx {
        pub fn consumer(self) -> UasxConsumer<false, false, false> {
            UasxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UasxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uasx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uasx",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uasx {
        #[inline]
        fn clone(&self) -> Uasx {
            Uasx {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uasx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uasx {
        #[inline]
        fn eq(&self, other: &Uasx) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uasx> for Operation {
        fn from(val: Uasx) -> Operation {
            Operation::Uasx(val)
        }
    }
    pub struct Ubfx {
        pub rd: Register,
        pub rn: Register,
        pub lsb: u32,
        pub width: u32,
    }
    pub struct UbfxBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
        const widthSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        lsb: Option<u32>,
        width: Option<u32>,
    }
    impl<
        const rnSET: bool,
        const lsbSET: bool,
        const widthSET: bool,
    > UbfxBuilder<false, rnSET, lsbSET, widthSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> UbfxBuilder<true, rnSET, lsbSET, widthSET> {
            self.rd = Some(rd);
            UbfxBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                width: self.width,
            }
        }
    }
    impl<
        const rdSET: bool,
        const lsbSET: bool,
        const widthSET: bool,
    > UbfxBuilder<rdSET, false, lsbSET, widthSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> UbfxBuilder<rdSET, true, lsbSET, widthSET> {
            self.rn = Some(rn);
            UbfxBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                width: self.width,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const widthSET: bool,
    > UbfxBuilder<rdSET, rnSET, false, widthSET> {
        pub fn set_lsb(mut self, lsb: u32) -> UbfxBuilder<rdSET, rnSET, true, widthSET> {
            self.lsb = Some(lsb);
            UbfxBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                width: self.width,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
    > UbfxBuilder<rdSET, rnSET, lsbSET, false> {
        pub fn set_width(
            mut self,
            width: u32,
        ) -> UbfxBuilder<rdSET, rnSET, lsbSET, true> {
            self.width = Some(width);
            UbfxBuilder {
                rd: self.rd,
                rn: self.rn,
                lsb: self.lsb,
                width: self.width,
            }
        }
    }
    impl UbfxBuilder<false, false, false, false> {
        pub fn new() -> UbfxBuilder<false, false, false, false> {
            UbfxBuilder {
                rd: None,
                rn: None,
                lsb: None,
                width: None,
            }
        }
    }
    impl Ubfx {
        pub fn builder() -> UbfxBuilder<false, false, false, false> {
            UbfxBuilder {
                rd: None,
                rn: None,
                lsb: None,
                width: None,
            }
        }
    }
    impl UbfxBuilder<true, true, true, true> {
        pub fn complete(self) -> Ubfx {
            Ubfx {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                lsb: self.lsb.unwrap(),
                width: self.width.unwrap(),
            }
        }
    }
    pub struct UbfxConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const lsbSET: bool,
        const widthSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        lsb: Option<u32>,
        width: Option<u32>,
    }
    impl<
        const rnCONSUMED: bool,
        const lsbCONSUMED: bool,
        const widthCONSUMED: bool,
    > UbfxConsumer<false, rnCONSUMED, lsbCONSUMED, widthCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, UbfxConsumer<true, rnCONSUMED, lsbCONSUMED, widthCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UbfxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    width: self.width,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const lsbCONSUMED: bool,
        const widthCONSUMED: bool,
    > UbfxConsumer<rdCONSUMED, false, lsbCONSUMED, widthCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UbfxConsumer<rdCONSUMED, true, lsbCONSUMED, widthCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UbfxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    width: self.width,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const widthCONSUMED: bool,
    > UbfxConsumer<rdCONSUMED, rnCONSUMED, false, widthCONSUMED> {
        pub fn consume_lsb(
            mut self,
        ) -> (u32, UbfxConsumer<rdCONSUMED, rnCONSUMED, true, widthCONSUMED>) {
            let ret = self.lsb.unwrap();
            self.lsb = None;
            (
                ret,
                UbfxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    width: self.width,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const lsbCONSUMED: bool,
    > UbfxConsumer<rdCONSUMED, rnCONSUMED, lsbCONSUMED, false> {
        pub fn consume_width(
            mut self,
        ) -> (u32, UbfxConsumer<rdCONSUMED, rnCONSUMED, lsbCONSUMED, true>) {
            let ret = self.width.unwrap();
            self.width = None;
            (
                ret,
                UbfxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    lsb: self.lsb,
                    width: self.width,
                },
            )
        }
    }
    impl Ubfx {
        pub fn consumer(self) -> UbfxConsumer<false, false, false, false> {
            UbfxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                lsb: Some(self.lsb),
                width: Some(self.width),
            }
        }
    }
    impl UbfxConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ubfx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Ubfx",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "lsb",
                &self.lsb,
                "width",
                &&self.width,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ubfx {
        #[inline]
        fn clone(&self) -> Ubfx {
            Ubfx {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                lsb: ::core::clone::Clone::clone(&self.lsb),
                width: ::core::clone::Clone::clone(&self.width),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ubfx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ubfx {
        #[inline]
        fn eq(&self, other: &Ubfx) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.lsb == other.lsb
                && self.width == other.width
        }
    }
    impl From<Ubfx> for Operation {
        fn from(val: Ubfx) -> Operation {
            Operation::Ubfx(val)
        }
    }
    pub struct Udf {
        pub imm: u32,
    }
    pub struct UdfBuilder<const immSET: bool> {
        imm: Option<u32>,
    }
    impl UdfBuilder<false> {
        pub fn set_imm(mut self, imm: u32) -> UdfBuilder<true> {
            self.imm = Some(imm);
            UdfBuilder { imm: self.imm }
        }
    }
    impl UdfBuilder<false> {
        pub fn new() -> UdfBuilder<false> {
            UdfBuilder { imm: None }
        }
    }
    impl Udf {
        pub fn builder() -> UdfBuilder<false> {
            UdfBuilder { imm: None }
        }
    }
    impl UdfBuilder<true> {
        pub fn complete(self) -> Udf {
            Udf { imm: self.imm.unwrap() }
        }
    }
    pub struct UdfConsumer<const immSET: bool> {
        imm: Option<u32>,
    }
    impl UdfConsumer<false> {
        pub fn consume_imm(mut self) -> (u32, UdfConsumer<true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (ret, UdfConsumer { imm: self.imm })
        }
    }
    impl Udf {
        pub fn consumer(self) -> UdfConsumer<false> {
            UdfConsumer { imm: Some(self.imm) }
        }
    }
    impl UdfConsumer<true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Udf {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Udf",
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Udf {
        #[inline]
        fn clone(&self) -> Udf {
            Udf {
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Udf {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Udf {
        #[inline]
        fn eq(&self, other: &Udf) -> bool {
            self.imm == other.imm
        }
    }
    impl From<Udf> for Operation {
        fn from(val: Udf) -> Operation {
            Operation::Udf(val)
        }
    }
    pub struct Udiv {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UdivBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> UdivBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UdivBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            UdivBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UdivBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> UdivBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            UdivBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> UdivBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> UdivBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            UdivBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UdivBuilder<false, false, false> {
        pub fn new() -> UdivBuilder<false, false, false> {
            UdivBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Udiv {
        pub fn builder() -> UdivBuilder<false, false, false> {
            UdivBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UdivBuilder<true, true, true> {
        pub fn complete(self) -> Udiv {
            Udiv {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UdivConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UdivConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, UdivConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UdivConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UdivConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UdivConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UdivConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > UdivConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UdivConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UdivConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Udiv {
        pub fn consumer(self) -> UdivConsumer<false, false, false> {
            UdivConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UdivConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Udiv {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Udiv",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Udiv {
        #[inline]
        fn clone(&self) -> Udiv {
            Udiv {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Udiv {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Udiv {
        #[inline]
        fn eq(&self, other: &Udiv) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Udiv> for Operation {
        fn from(val: Udiv) -> Operation {
            Operation::Udiv(val)
        }
    }
    pub struct Uhadd16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uhadd16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uhadd16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uhadd16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uhadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uhadd16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uhadd16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uhadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uhadd16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uhadd16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uhadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uhadd16Builder<false, false, false> {
        pub fn new() -> Uhadd16Builder<false, false, false> {
            Uhadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhadd16 {
        pub fn builder() -> Uhadd16Builder<false, false, false> {
            Uhadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhadd16Builder<true, true, true> {
        pub fn complete(self) -> Uhadd16 {
            Uhadd16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uhadd16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uhadd16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uhadd16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uhadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uhadd16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uhadd16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uhadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uhadd16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uhadd16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uhadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uhadd16 {
        pub fn consumer(self) -> Uhadd16Consumer<false, false, false> {
            Uhadd16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uhadd16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uhadd16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uhadd16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uhadd16 {
        #[inline]
        fn clone(&self) -> Uhadd16 {
            Uhadd16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uhadd16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uhadd16 {
        #[inline]
        fn eq(&self, other: &Uhadd16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uhadd16> for Operation {
        fn from(val: Uhadd16) -> Operation {
            Operation::Uhadd16(val)
        }
    }
    pub struct Uhadd8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uhadd8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uhadd8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uhadd8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uhadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uhadd8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uhadd8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uhadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uhadd8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uhadd8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uhadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uhadd8Builder<false, false, false> {
        pub fn new() -> Uhadd8Builder<false, false, false> {
            Uhadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhadd8 {
        pub fn builder() -> Uhadd8Builder<false, false, false> {
            Uhadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhadd8Builder<true, true, true> {
        pub fn complete(self) -> Uhadd8 {
            Uhadd8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uhadd8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uhadd8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uhadd8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uhadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uhadd8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uhadd8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uhadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uhadd8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uhadd8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uhadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uhadd8 {
        pub fn consumer(self) -> Uhadd8Consumer<false, false, false> {
            Uhadd8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uhadd8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uhadd8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uhadd8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uhadd8 {
        #[inline]
        fn clone(&self) -> Uhadd8 {
            Uhadd8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uhadd8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uhadd8 {
        #[inline]
        fn eq(&self, other: &Uhadd8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uhadd8> for Operation {
        fn from(val: Uhadd8) -> Operation {
            Operation::Uhadd8(val)
        }
    }
    pub struct Uhasx {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UhasxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> UhasxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UhasxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            UhasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UhasxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> UhasxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            UhasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> UhasxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> UhasxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            UhasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UhasxBuilder<false, false, false> {
        pub fn new() -> UhasxBuilder<false, false, false> {
            UhasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhasx {
        pub fn builder() -> UhasxBuilder<false, false, false> {
            UhasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UhasxBuilder<true, true, true> {
        pub fn complete(self) -> Uhasx {
            Uhasx {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UhasxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UhasxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, UhasxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UhasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UhasxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UhasxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UhasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > UhasxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UhasxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UhasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uhasx {
        pub fn consumer(self) -> UhasxConsumer<false, false, false> {
            UhasxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UhasxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uhasx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uhasx",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uhasx {
        #[inline]
        fn clone(&self) -> Uhasx {
            Uhasx {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uhasx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uhasx {
        #[inline]
        fn eq(&self, other: &Uhasx) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uhasx> for Operation {
        fn from(val: Uhasx) -> Operation {
            Operation::Uhasx(val)
        }
    }
    pub struct Uhsax {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UhsaxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> UhsaxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UhsaxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            UhsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UhsaxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> UhsaxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            UhsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> UhsaxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> UhsaxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            UhsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UhsaxBuilder<false, false, false> {
        pub fn new() -> UhsaxBuilder<false, false, false> {
            UhsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhsax {
        pub fn builder() -> UhsaxBuilder<false, false, false> {
            UhsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UhsaxBuilder<true, true, true> {
        pub fn complete(self) -> Uhsax {
            Uhsax {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UhsaxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UhsaxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, UhsaxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UhsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UhsaxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UhsaxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UhsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > UhsaxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UhsaxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UhsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uhsax {
        pub fn consumer(self) -> UhsaxConsumer<false, false, false> {
            UhsaxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UhsaxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uhsax {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uhsax",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uhsax {
        #[inline]
        fn clone(&self) -> Uhsax {
            Uhsax {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uhsax {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uhsax {
        #[inline]
        fn eq(&self, other: &Uhsax) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uhsax> for Operation {
        fn from(val: Uhsax) -> Operation {
            Operation::Uhsax(val)
        }
    }
    pub struct Uhsub16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uhsub16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uhsub16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uhsub16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uhsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uhsub16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uhsub16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uhsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uhsub16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uhsub16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uhsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uhsub16Builder<false, false, false> {
        pub fn new() -> Uhsub16Builder<false, false, false> {
            Uhsub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhsub16 {
        pub fn builder() -> Uhsub16Builder<false, false, false> {
            Uhsub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhsub16Builder<true, true, true> {
        pub fn complete(self) -> Uhsub16 {
            Uhsub16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uhsub16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uhsub16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uhsub16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uhsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uhsub16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uhsub16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uhsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uhsub16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uhsub16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uhsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uhsub16 {
        pub fn consumer(self) -> Uhsub16Consumer<false, false, false> {
            Uhsub16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uhsub16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uhsub16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uhsub16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uhsub16 {
        #[inline]
        fn clone(&self) -> Uhsub16 {
            Uhsub16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uhsub16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uhsub16 {
        #[inline]
        fn eq(&self, other: &Uhsub16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uhsub16> for Operation {
        fn from(val: Uhsub16) -> Operation {
            Operation::Uhsub16(val)
        }
    }
    pub struct Uhsub8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uhsub8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uhsub8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uhsub8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uhsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uhsub8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uhsub8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uhsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uhsub8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uhsub8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uhsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uhsub8Builder<false, false, false> {
        pub fn new() -> Uhsub8Builder<false, false, false> {
            Uhsub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhsub8 {
        pub fn builder() -> Uhsub8Builder<false, false, false> {
            Uhsub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uhsub8Builder<true, true, true> {
        pub fn complete(self) -> Uhsub8 {
            Uhsub8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uhsub8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uhsub8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uhsub8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uhsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uhsub8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uhsub8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uhsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uhsub8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uhsub8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uhsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uhsub8 {
        pub fn consumer(self) -> Uhsub8Consumer<false, false, false> {
            Uhsub8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uhsub8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uhsub8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uhsub8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uhsub8 {
        #[inline]
        fn clone(&self) -> Uhsub8 {
            Uhsub8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uhsub8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uhsub8 {
        #[inline]
        fn eq(&self, other: &Uhsub8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uhsub8> for Operation {
        fn from(val: Uhsub8) -> Operation {
            Operation::Uhsub8(val)
        }
    }
    pub struct Umaal {
        pub rdlo: Register,
        pub rdhi: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UmaalBuilder<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > UmaalBuilder<false, rdhiSET, rnSET, rmSET> {
        pub fn set_rdlo(
            mut self,
            rdlo: Register,
        ) -> UmaalBuilder<true, rdhiSET, rnSET, rmSET> {
            self.rdlo = Some(rdlo);
            UmaalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > UmaalBuilder<rdloSET, false, rnSET, rmSET> {
        pub fn set_rdhi(
            mut self,
            rdhi: Register,
        ) -> UmaalBuilder<rdloSET, true, rnSET, rmSET> {
            self.rdhi = Some(rdhi);
            UmaalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rmSET: bool,
    > UmaalBuilder<rdloSET, rdhiSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> UmaalBuilder<rdloSET, rdhiSET, true, rmSET> {
            self.rn = Some(rn);
            UmaalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
    > UmaalBuilder<rdloSET, rdhiSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> UmaalBuilder<rdloSET, rdhiSET, rnSET, true> {
            self.rm = Some(rm);
            UmaalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UmaalBuilder<false, false, false, false> {
        pub fn new() -> UmaalBuilder<false, false, false, false> {
            UmaalBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Umaal {
        pub fn builder() -> UmaalBuilder<false, false, false, false> {
            UmaalBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UmaalBuilder<true, true, true, true> {
        pub fn complete(self) -> Umaal {
            Umaal {
                rdlo: self.rdlo.unwrap(),
                rdhi: self.rdhi.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UmaalConsumer<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmaalConsumer<false, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdlo(
            mut self,
        ) -> (Register, UmaalConsumer<true, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdlo.unwrap();
            self.rdlo = None;
            (
                ret,
                UmaalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmaalConsumer<rdloCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdhi(
            mut self,
        ) -> (Register, UmaalConsumer<rdloCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdhi.unwrap();
            self.rdhi = None;
            (
                ret,
                UmaalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmaalConsumer<rdloCONSUMED, rdhiCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UmaalConsumer<rdloCONSUMED, rdhiCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UmaalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
    > UmaalConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UmaalConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UmaalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Umaal {
        pub fn consumer(self) -> UmaalConsumer<false, false, false, false> {
            UmaalConsumer {
                rdlo: Some(self.rdlo),
                rdhi: Some(self.rdhi),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UmaalConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Umaal {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Umaal",
                "rdlo",
                &self.rdlo,
                "rdhi",
                &self.rdhi,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Umaal {
        #[inline]
        fn clone(&self) -> Umaal {
            Umaal {
                rdlo: ::core::clone::Clone::clone(&self.rdlo),
                rdhi: ::core::clone::Clone::clone(&self.rdhi),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Umaal {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Umaal {
        #[inline]
        fn eq(&self, other: &Umaal) -> bool {
            self.rdlo == other.rdlo && self.rdhi == other.rdhi && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Umaal> for Operation {
        fn from(val: Umaal) -> Operation {
            Operation::Umaal(val)
        }
    }
    pub struct Umlal {
        pub rdlo: Register,
        pub rdhi: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UmlalBuilder<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > UmlalBuilder<false, rdhiSET, rnSET, rmSET> {
        pub fn set_rdlo(
            mut self,
            rdlo: Register,
        ) -> UmlalBuilder<true, rdhiSET, rnSET, rmSET> {
            self.rdlo = Some(rdlo);
            UmlalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > UmlalBuilder<rdloSET, false, rnSET, rmSET> {
        pub fn set_rdhi(
            mut self,
            rdhi: Register,
        ) -> UmlalBuilder<rdloSET, true, rnSET, rmSET> {
            self.rdhi = Some(rdhi);
            UmlalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rmSET: bool,
    > UmlalBuilder<rdloSET, rdhiSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> UmlalBuilder<rdloSET, rdhiSET, true, rmSET> {
            self.rn = Some(rn);
            UmlalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
    > UmlalBuilder<rdloSET, rdhiSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> UmlalBuilder<rdloSET, rdhiSET, rnSET, true> {
            self.rm = Some(rm);
            UmlalBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UmlalBuilder<false, false, false, false> {
        pub fn new() -> UmlalBuilder<false, false, false, false> {
            UmlalBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Umlal {
        pub fn builder() -> UmlalBuilder<false, false, false, false> {
            UmlalBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UmlalBuilder<true, true, true, true> {
        pub fn complete(self) -> Umlal {
            Umlal {
                rdlo: self.rdlo.unwrap(),
                rdhi: self.rdhi.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UmlalConsumer<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmlalConsumer<false, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdlo(
            mut self,
        ) -> (Register, UmlalConsumer<true, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdlo.unwrap();
            self.rdlo = None;
            (
                ret,
                UmlalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmlalConsumer<rdloCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdhi(
            mut self,
        ) -> (Register, UmlalConsumer<rdloCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdhi.unwrap();
            self.rdhi = None;
            (
                ret,
                UmlalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmlalConsumer<rdloCONSUMED, rdhiCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UmlalConsumer<rdloCONSUMED, rdhiCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UmlalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
    > UmlalConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UmlalConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UmlalConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Umlal {
        pub fn consumer(self) -> UmlalConsumer<false, false, false, false> {
            UmlalConsumer {
                rdlo: Some(self.rdlo),
                rdhi: Some(self.rdhi),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UmlalConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Umlal {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Umlal",
                "rdlo",
                &self.rdlo,
                "rdhi",
                &self.rdhi,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Umlal {
        #[inline]
        fn clone(&self) -> Umlal {
            Umlal {
                rdlo: ::core::clone::Clone::clone(&self.rdlo),
                rdhi: ::core::clone::Clone::clone(&self.rdhi),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Umlal {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Umlal {
        #[inline]
        fn eq(&self, other: &Umlal) -> bool {
            self.rdlo == other.rdlo && self.rdhi == other.rdhi && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Umlal> for Operation {
        fn from(val: Umlal) -> Operation {
            Operation::Umlal(val)
        }
    }
    pub struct Umull {
        pub rdlo: Register,
        pub rdhi: Register,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UmullBuilder<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > UmullBuilder<false, rdhiSET, rnSET, rmSET> {
        pub fn set_rdlo(
            mut self,
            rdlo: Register,
        ) -> UmullBuilder<true, rdhiSET, rnSET, rmSET> {
            self.rdlo = Some(rdlo);
            UmullBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > UmullBuilder<rdloSET, false, rnSET, rmSET> {
        pub fn set_rdhi(
            mut self,
            rdhi: Register,
        ) -> UmullBuilder<rdloSET, true, rnSET, rmSET> {
            self.rdhi = Some(rdhi);
            UmullBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rmSET: bool,
    > UmullBuilder<rdloSET, rdhiSET, false, rmSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> UmullBuilder<rdloSET, rdhiSET, true, rmSET> {
            self.rn = Some(rn);
            UmullBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
    > UmullBuilder<rdloSET, rdhiSET, rnSET, false> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> UmullBuilder<rdloSET, rdhiSET, rnSET, true> {
            self.rm = Some(rm);
            UmullBuilder {
                rdlo: self.rdlo,
                rdhi: self.rdhi,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UmullBuilder<false, false, false, false> {
        pub fn new() -> UmullBuilder<false, false, false, false> {
            UmullBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Umull {
        pub fn builder() -> UmullBuilder<false, false, false, false> {
            UmullBuilder {
                rdlo: None,
                rdhi: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UmullBuilder<true, true, true, true> {
        pub fn complete(self) -> Umull {
            Umull {
                rdlo: self.rdlo.unwrap(),
                rdhi: self.rdhi.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UmullConsumer<
        const rdloSET: bool,
        const rdhiSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > {
        rdlo: Option<Register>,
        rdhi: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmullConsumer<false, rdhiCONSUMED, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdlo(
            mut self,
        ) -> (Register, UmullConsumer<true, rdhiCONSUMED, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdlo.unwrap();
            self.rdlo = None;
            (
                ret,
                UmullConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmullConsumer<rdloCONSUMED, false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rdhi(
            mut self,
        ) -> (Register, UmullConsumer<rdloCONSUMED, true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rdhi.unwrap();
            self.rdhi = None;
            (
                ret,
                UmullConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rmCONSUMED: bool,
    > UmullConsumer<rdloCONSUMED, rdhiCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UmullConsumer<rdloCONSUMED, rdhiCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UmullConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdloCONSUMED: bool,
        const rdhiCONSUMED: bool,
        const rnCONSUMED: bool,
    > UmullConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UmullConsumer<rdloCONSUMED, rdhiCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UmullConsumer {
                    rdlo: self.rdlo,
                    rdhi: self.rdhi,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Umull {
        pub fn consumer(self) -> UmullConsumer<false, false, false, false> {
            UmullConsumer {
                rdlo: Some(self.rdlo),
                rdhi: Some(self.rdhi),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UmullConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Umull {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Umull",
                "rdlo",
                &self.rdlo,
                "rdhi",
                &self.rdhi,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Umull {
        #[inline]
        fn clone(&self) -> Umull {
            Umull {
                rdlo: ::core::clone::Clone::clone(&self.rdlo),
                rdhi: ::core::clone::Clone::clone(&self.rdhi),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Umull {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Umull {
        #[inline]
        fn eq(&self, other: &Umull) -> bool {
            self.rdlo == other.rdlo && self.rdhi == other.rdhi && self.rn == other.rn
                && self.rm == other.rm
        }
    }
    impl From<Umull> for Operation {
        fn from(val: Umull) -> Operation {
            Operation::Umull(val)
        }
    }
    pub struct Uqadd16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uqadd16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uqadd16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uqadd16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uqadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uqadd16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uqadd16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uqadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uqadd16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uqadd16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uqadd16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uqadd16Builder<false, false, false> {
        pub fn new() -> Uqadd16Builder<false, false, false> {
            Uqadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqadd16 {
        pub fn builder() -> Uqadd16Builder<false, false, false> {
            Uqadd16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqadd16Builder<true, true, true> {
        pub fn complete(self) -> Uqadd16 {
            Uqadd16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uqadd16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqadd16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uqadd16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uqadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqadd16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uqadd16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uqadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uqadd16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uqadd16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uqadd16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uqadd16 {
        pub fn consumer(self) -> Uqadd16Consumer<false, false, false> {
            Uqadd16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uqadd16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uqadd16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uqadd16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uqadd16 {
        #[inline]
        fn clone(&self) -> Uqadd16 {
            Uqadd16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uqadd16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uqadd16 {
        #[inline]
        fn eq(&self, other: &Uqadd16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uqadd16> for Operation {
        fn from(val: Uqadd16) -> Operation {
            Operation::Uqadd16(val)
        }
    }
    pub struct Uqadd8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uqadd8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uqadd8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uqadd8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uqadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uqadd8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uqadd8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uqadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uqadd8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uqadd8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uqadd8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uqadd8Builder<false, false, false> {
        pub fn new() -> Uqadd8Builder<false, false, false> {
            Uqadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqadd8 {
        pub fn builder() -> Uqadd8Builder<false, false, false> {
            Uqadd8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqadd8Builder<true, true, true> {
        pub fn complete(self) -> Uqadd8 {
            Uqadd8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uqadd8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqadd8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uqadd8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uqadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqadd8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uqadd8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uqadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uqadd8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uqadd8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uqadd8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uqadd8 {
        pub fn consumer(self) -> Uqadd8Consumer<false, false, false> {
            Uqadd8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uqadd8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uqadd8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uqadd8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uqadd8 {
        #[inline]
        fn clone(&self) -> Uqadd8 {
            Uqadd8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uqadd8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uqadd8 {
        #[inline]
        fn eq(&self, other: &Uqadd8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uqadd8> for Operation {
        fn from(val: Uqadd8) -> Operation {
            Operation::Uqadd8(val)
        }
    }
    pub struct Uqasx {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UqasxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> UqasxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UqasxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            UqasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UqasxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> UqasxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            UqasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> UqasxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> UqasxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            UqasxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UqasxBuilder<false, false, false> {
        pub fn new() -> UqasxBuilder<false, false, false> {
            UqasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqasx {
        pub fn builder() -> UqasxBuilder<false, false, false> {
            UqasxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UqasxBuilder<true, true, true> {
        pub fn complete(self) -> Uqasx {
            Uqasx {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UqasxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UqasxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, UqasxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UqasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UqasxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UqasxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UqasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > UqasxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UqasxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UqasxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uqasx {
        pub fn consumer(self) -> UqasxConsumer<false, false, false> {
            UqasxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UqasxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uqasx {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uqasx",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uqasx {
        #[inline]
        fn clone(&self) -> Uqasx {
            Uqasx {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uqasx {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uqasx {
        #[inline]
        fn eq(&self, other: &Uqasx) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uqasx> for Operation {
        fn from(val: Uqasx) -> Operation {
            Operation::Uqasx(val)
        }
    }
    pub struct Uqsax {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UqsaxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> UqsaxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UqsaxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            UqsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UqsaxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> UqsaxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            UqsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> UqsaxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> UqsaxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            UqsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UqsaxBuilder<false, false, false> {
        pub fn new() -> UqsaxBuilder<false, false, false> {
            UqsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqsax {
        pub fn builder() -> UqsaxBuilder<false, false, false> {
            UqsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UqsaxBuilder<true, true, true> {
        pub fn complete(self) -> Uqsax {
            Uqsax {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UqsaxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UqsaxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, UqsaxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UqsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UqsaxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UqsaxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UqsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > UqsaxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UqsaxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UqsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uqsax {
        pub fn consumer(self) -> UqsaxConsumer<false, false, false> {
            UqsaxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UqsaxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uqsax {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uqsax",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uqsax {
        #[inline]
        fn clone(&self) -> Uqsax {
            Uqsax {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uqsax {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uqsax {
        #[inline]
        fn eq(&self, other: &Uqsax) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uqsax> for Operation {
        fn from(val: Uqsax) -> Operation {
            Operation::Uqsax(val)
        }
    }
    pub struct Uqsub16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uqsub16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uqsub16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uqsub16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uqsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uqsub16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uqsub16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uqsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uqsub16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uqsub16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uqsub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uqsub16Builder<false, false, false> {
        pub fn new() -> Uqsub16Builder<false, false, false> {
            Uqsub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqsub16 {
        pub fn builder() -> Uqsub16Builder<false, false, false> {
            Uqsub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqsub16Builder<true, true, true> {
        pub fn complete(self) -> Uqsub16 {
            Uqsub16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uqsub16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqsub16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uqsub16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uqsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqsub16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uqsub16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uqsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uqsub16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uqsub16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uqsub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uqsub16 {
        pub fn consumer(self) -> Uqsub16Consumer<false, false, false> {
            Uqsub16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uqsub16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uqsub16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uqsub16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uqsub16 {
        #[inline]
        fn clone(&self) -> Uqsub16 {
            Uqsub16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uqsub16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uqsub16 {
        #[inline]
        fn eq(&self, other: &Uqsub16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uqsub16> for Operation {
        fn from(val: Uqsub16) -> Operation {
            Operation::Uqsub16(val)
        }
    }
    pub struct Uqsub8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uqsub8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uqsub8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uqsub8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uqsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uqsub8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uqsub8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uqsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uqsub8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uqsub8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uqsub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uqsub8Builder<false, false, false> {
        pub fn new() -> Uqsub8Builder<false, false, false> {
            Uqsub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqsub8 {
        pub fn builder() -> Uqsub8Builder<false, false, false> {
            Uqsub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqsub8Builder<true, true, true> {
        pub fn complete(self) -> Uqsub8 {
            Uqsub8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uqsub8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqsub8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uqsub8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uqsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqsub8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uqsub8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uqsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uqsub8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uqsub8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uqsub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uqsub8 {
        pub fn consumer(self) -> Uqsub8Consumer<false, false, false> {
            Uqsub8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uqsub8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uqsub8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uqsub8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uqsub8 {
        #[inline]
        fn clone(&self) -> Uqsub8 {
            Uqsub8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uqsub8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uqsub8 {
        #[inline]
        fn eq(&self, other: &Uqsub8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uqsub8> for Operation {
        fn from(val: Uqsub8) -> Operation {
            Operation::Uqsub8(val)
        }
    }
    pub struct Uqsad8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Uqsad8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Uqsad8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uqsad8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Uqsad8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uqsad8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Uqsad8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Uqsad8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Uqsad8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Uqsad8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Uqsad8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Uqsad8Builder<false, false, false> {
        pub fn new() -> Uqsad8Builder<false, false, false> {
            Uqsad8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqsad8 {
        pub fn builder() -> Uqsad8Builder<false, false, false> {
            Uqsad8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Uqsad8Builder<true, true, true> {
        pub fn complete(self) -> Uqsad8 {
            Uqsad8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Uqsad8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqsad8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uqsad8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uqsad8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uqsad8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Uqsad8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uqsad8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Uqsad8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uqsad8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uqsad8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Uqsad8 {
        pub fn consumer(self) -> Uqsad8Consumer<false, false, false> {
            Uqsad8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Uqsad8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uqsad8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uqsad8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uqsad8 {
        #[inline]
        fn clone(&self) -> Uqsad8 {
            Uqsad8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uqsad8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uqsad8 {
        #[inline]
        fn eq(&self, other: &Uqsad8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Uqsad8> for Operation {
        fn from(val: Uqsad8) -> Operation {
            Operation::Uqsad8(val)
        }
    }
    pub struct Usada8 {
        pub rd: Register,
        pub rn: Register,
        pub rm: Register,
        pub ra: Register,
    }
    pub struct Usada8Builder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > Usada8Builder<false, rnSET, rmSET, raSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> Usada8Builder<true, rnSET, rmSET, raSET> {
            self.rd = Some(rd);
            Usada8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > Usada8Builder<rdSET, false, rmSET, raSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> Usada8Builder<rdSET, true, rmSET, raSET> {
            self.rn = Some(rn);
            Usada8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const raSET: bool,
    > Usada8Builder<rdSET, rnSET, false, raSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> Usada8Builder<rdSET, rnSET, true, raSET> {
            self.rm = Some(rm);
            Usada8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > Usada8Builder<rdSET, rnSET, rmSET, false> {
        pub fn set_ra(
            mut self,
            ra: Register,
        ) -> Usada8Builder<rdSET, rnSET, rmSET, true> {
            self.ra = Some(ra);
            Usada8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                ra: self.ra,
            }
        }
    }
    impl Usada8Builder<false, false, false, false> {
        pub fn new() -> Usada8Builder<false, false, false, false> {
            Usada8Builder {
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Usada8 {
        pub fn builder() -> Usada8Builder<false, false, false, false> {
            Usada8Builder {
                rd: None,
                rn: None,
                rm: None,
                ra: None,
            }
        }
    }
    impl Usada8Builder<true, true, true, true> {
        pub fn complete(self) -> Usada8 {
            Usada8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                ra: self.ra.unwrap(),
            }
        }
    }
    pub struct Usada8Consumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const raSET: bool,
    > {
        rd: Option<Register>,
        rn: Option<Register>,
        rm: Option<Register>,
        ra: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > Usada8Consumer<false, rnCONSUMED, rmCONSUMED, raCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, Usada8Consumer<true, rnCONSUMED, rmCONSUMED, raCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Usada8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const raCONSUMED: bool,
    > Usada8Consumer<rdCONSUMED, false, rmCONSUMED, raCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Usada8Consumer<rdCONSUMED, true, rmCONSUMED, raCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Usada8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const raCONSUMED: bool,
    > Usada8Consumer<rdCONSUMED, rnCONSUMED, false, raCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Usada8Consumer<rdCONSUMED, rnCONSUMED, true, raCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Usada8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Usada8Consumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_ra(
            mut self,
        ) -> (Register, Usada8Consumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.ra.unwrap();
            self.ra = None;
            (
                ret,
                Usada8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    ra: self.ra,
                },
            )
        }
    }
    impl Usada8 {
        pub fn consumer(self) -> Usada8Consumer<false, false, false, false> {
            Usada8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                ra: Some(self.ra),
            }
        }
    }
    impl Usada8Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Usada8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Usada8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "ra",
                &&self.ra,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Usada8 {
        #[inline]
        fn clone(&self) -> Usada8 {
            Usada8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                ra: ::core::clone::Clone::clone(&self.ra),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Usada8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Usada8 {
        #[inline]
        fn eq(&self, other: &Usada8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.ra == other.ra
        }
    }
    impl From<Usada8> for Operation {
        fn from(val: Usada8) -> Operation {
            Operation::Usada8(val)
        }
    }
    pub struct Usad8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Usad8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Usad8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Usad8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Usad8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Usad8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Usad8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Usad8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Usad8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Usad8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Usad8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Usad8Builder<false, false, false> {
        pub fn new() -> Usad8Builder<false, false, false> {
            Usad8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Usad8 {
        pub fn builder() -> Usad8Builder<false, false, false> {
            Usad8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Usad8Builder<true, true, true> {
        pub fn complete(self) -> Usad8 {
            Usad8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Usad8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Usad8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Usad8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Usad8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Usad8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Usad8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Usad8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Usad8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Usad8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Usad8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Usad8 {
        pub fn consumer(self) -> Usad8Consumer<false, false, false> {
            Usad8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Usad8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Usad8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Usad8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Usad8 {
        #[inline]
        fn clone(&self) -> Usad8 {
            Usad8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Usad8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Usad8 {
        #[inline]
        fn eq(&self, other: &Usad8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Usad8> for Operation {
        fn from(val: Usad8) -> Operation {
            Operation::Usad8(val)
        }
    }
    pub struct Usat {
        pub rd: Register,
        pub imm: u32,
        pub rn: Register,
        pub shift: Option<ImmShift>,
    }
    pub struct UsatBuilder<
        const rdSET: bool,
        const immSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > {
        rd: Option<Register>,
        imm: Option<u32>,
        rn: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const immSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > UsatBuilder<false, immSET, rnSET, shiftSET> {
        pub fn set_rd(
            mut self,
            rd: Register,
        ) -> UsatBuilder<true, immSET, rnSET, shiftSET> {
            self.rd = Some(rd);
            UsatBuilder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
                shift: self.shift,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > UsatBuilder<rdSET, false, rnSET, shiftSET> {
        pub fn set_imm(mut self, imm: u32) -> UsatBuilder<rdSET, true, rnSET, shiftSET> {
            self.imm = Some(imm);
            UsatBuilder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
                shift: self.shift,
            }
        }
    }
    impl<
        const rdSET: bool,
        const immSET: bool,
        const shiftSET: bool,
    > UsatBuilder<rdSET, immSET, false, shiftSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> UsatBuilder<rdSET, immSET, true, shiftSET> {
            self.rn = Some(rn);
            UsatBuilder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
                shift: self.shift,
            }
        }
    }
    impl<
        const rdSET: bool,
        const immSET: bool,
        const rnSET: bool,
    > UsatBuilder<rdSET, immSET, rnSET, false> {
        pub fn set_shift(
            mut self,
            shift: Option<ImmShift>,
        ) -> UsatBuilder<rdSET, immSET, rnSET, true> {
            self.shift = Some(shift);
            UsatBuilder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
                shift: self.shift,
            }
        }
    }
    impl UsatBuilder<false, false, false, false> {
        pub fn new() -> UsatBuilder<false, false, false, false> {
            UsatBuilder {
                rd: None,
                imm: None,
                rn: None,
                shift: None,
            }
        }
    }
    impl Usat {
        pub fn builder() -> UsatBuilder<false, false, false, false> {
            UsatBuilder {
                rd: None,
                imm: None,
                rn: None,
                shift: None,
            }
        }
    }
    impl UsatBuilder<true, true, true, true> {
        pub fn complete(self) -> Usat {
            Usat {
                rd: self.rd.unwrap(),
                imm: self.imm.unwrap(),
                rn: self.rn.unwrap(),
                shift: self.shift.unwrap(),
            }
        }
    }
    pub struct UsatConsumer<
        const rdSET: bool,
        const immSET: bool,
        const rnSET: bool,
        const shiftSET: bool,
    > {
        rd: Option<Register>,
        imm: Option<u32>,
        rn: Option<Register>,
        shift: Option<Option<ImmShift>>,
    }
    impl<
        const immCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > UsatConsumer<false, immCONSUMED, rnCONSUMED, shiftCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, UsatConsumer<true, immCONSUMED, rnCONSUMED, shiftCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UsatConsumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const shiftCONSUMED: bool,
    > UsatConsumer<rdCONSUMED, false, rnCONSUMED, shiftCONSUMED> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, UsatConsumer<rdCONSUMED, true, rnCONSUMED, shiftCONSUMED>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                UsatConsumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
        const shiftCONSUMED: bool,
    > UsatConsumer<rdCONSUMED, immCONSUMED, false, shiftCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UsatConsumer<rdCONSUMED, immCONSUMED, true, shiftCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UsatConsumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                    shift: self.shift,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
        const rnCONSUMED: bool,
    > UsatConsumer<rdCONSUMED, immCONSUMED, rnCONSUMED, false> {
        pub fn consume_shift(
            mut self,
        ) -> (
            Option<ImmShift>,
            UsatConsumer<rdCONSUMED, immCONSUMED, rnCONSUMED, true>,
        ) {
            let ret = self.shift.unwrap();
            self.shift = None;
            (
                ret,
                UsatConsumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                    shift: self.shift,
                },
            )
        }
    }
    impl Usat {
        pub fn consumer(self) -> UsatConsumer<false, false, false, false> {
            UsatConsumer {
                rd: Some(self.rd),
                imm: Some(self.imm),
                rn: Some(self.rn),
                shift: Some(self.shift),
            }
        }
    }
    impl UsatConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Usat {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Usat",
                "rd",
                &self.rd,
                "imm",
                &self.imm,
                "rn",
                &self.rn,
                "shift",
                &&self.shift,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Usat {
        #[inline]
        fn clone(&self) -> Usat {
            Usat {
                rd: ::core::clone::Clone::clone(&self.rd),
                imm: ::core::clone::Clone::clone(&self.imm),
                rn: ::core::clone::Clone::clone(&self.rn),
                shift: ::core::clone::Clone::clone(&self.shift),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Usat {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Usat {
        #[inline]
        fn eq(&self, other: &Usat) -> bool {
            self.rd == other.rd && self.imm == other.imm && self.rn == other.rn
                && self.shift == other.shift
        }
    }
    impl From<Usat> for Operation {
        fn from(val: Usat) -> Operation {
            Operation::Usat(val)
        }
    }
    pub struct Usat16 {
        pub rd: Register,
        pub imm: u32,
        pub rn: Register,
    }
    pub struct Usat16Builder<const rdSET: bool, const immSET: bool, const rnSET: bool> {
        rd: Option<Register>,
        imm: Option<u32>,
        rn: Option<Register>,
    }
    impl<const immSET: bool, const rnSET: bool> Usat16Builder<false, immSET, rnSET> {
        pub fn set_rd(mut self, rd: Register) -> Usat16Builder<true, immSET, rnSET> {
            self.rd = Some(rd);
            Usat16Builder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Usat16Builder<rdSET, false, rnSET> {
        pub fn set_imm(mut self, imm: u32) -> Usat16Builder<rdSET, true, rnSET> {
            self.imm = Some(imm);
            Usat16Builder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
            }
        }
    }
    impl<const rdSET: bool, const immSET: bool> Usat16Builder<rdSET, immSET, false> {
        pub fn set_rn(mut self, rn: Register) -> Usat16Builder<rdSET, immSET, true> {
            self.rn = Some(rn);
            Usat16Builder {
                rd: self.rd,
                imm: self.imm,
                rn: self.rn,
            }
        }
    }
    impl Usat16Builder<false, false, false> {
        pub fn new() -> Usat16Builder<false, false, false> {
            Usat16Builder {
                rd: None,
                imm: None,
                rn: None,
            }
        }
    }
    impl Usat16 {
        pub fn builder() -> Usat16Builder<false, false, false> {
            Usat16Builder {
                rd: None,
                imm: None,
                rn: None,
            }
        }
    }
    impl Usat16Builder<true, true, true> {
        pub fn complete(self) -> Usat16 {
            Usat16 {
                rd: self.rd.unwrap(),
                imm: self.imm.unwrap(),
                rn: self.rn.unwrap(),
            }
        }
    }
    pub struct Usat16Consumer<const rdSET: bool, const immSET: bool, const rnSET: bool> {
        rd: Option<Register>,
        imm: Option<u32>,
        rn: Option<Register>,
    }
    impl<
        const immCONSUMED: bool,
        const rnCONSUMED: bool,
    > Usat16Consumer<false, immCONSUMED, rnCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, Usat16Consumer<true, immCONSUMED, rnCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Usat16Consumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Usat16Consumer<rdCONSUMED, false, rnCONSUMED> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, Usat16Consumer<rdCONSUMED, true, rnCONSUMED>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                Usat16Consumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const immCONSUMED: bool,
    > Usat16Consumer<rdCONSUMED, immCONSUMED, false> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Usat16Consumer<rdCONSUMED, immCONSUMED, true>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Usat16Consumer {
                    rd: self.rd,
                    imm: self.imm,
                    rn: self.rn,
                },
            )
        }
    }
    impl Usat16 {
        pub fn consumer(self) -> Usat16Consumer<false, false, false> {
            Usat16Consumer {
                rd: Some(self.rd),
                imm: Some(self.imm),
                rn: Some(self.rn),
            }
        }
    }
    impl Usat16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Usat16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Usat16",
                "rd",
                &self.rd,
                "imm",
                &self.imm,
                "rn",
                &&self.rn,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Usat16 {
        #[inline]
        fn clone(&self) -> Usat16 {
            Usat16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                imm: ::core::clone::Clone::clone(&self.imm),
                rn: ::core::clone::Clone::clone(&self.rn),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Usat16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Usat16 {
        #[inline]
        fn eq(&self, other: &Usat16) -> bool {
            self.rd == other.rd && self.imm == other.imm && self.rn == other.rn
        }
    }
    impl From<Usat16> for Operation {
        fn from(val: Usat16) -> Operation {
            Operation::Usat16(val)
        }
    }
    pub struct Usax {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct UsaxBuilder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> UsaxBuilder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UsaxBuilder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            UsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UsaxBuilder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> UsaxBuilder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            UsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> UsaxBuilder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> UsaxBuilder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            UsaxBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl UsaxBuilder<false, false, false> {
        pub fn new() -> UsaxBuilder<false, false, false> {
            UsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Usax {
        pub fn builder() -> UsaxBuilder<false, false, false> {
            UsaxBuilder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl UsaxBuilder<true, true, true> {
        pub fn complete(self) -> Usax {
            Usax {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct UsaxConsumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UsaxConsumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, UsaxConsumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UsaxConsumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UsaxConsumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > UsaxConsumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UsaxConsumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UsaxConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Usax {
        pub fn consumer(self) -> UsaxConsumer<false, false, false> {
            UsaxConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl UsaxConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Usax {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Usax",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Usax {
        #[inline]
        fn clone(&self) -> Usax {
            Usax {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Usax {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Usax {
        #[inline]
        fn eq(&self, other: &Usax) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Usax> for Operation {
        fn from(val: Usax) -> Operation {
            Operation::Usax(val)
        }
    }
    pub struct Usub16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Usub16Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Usub16Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Usub16Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Usub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Usub16Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Usub16Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Usub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Usub16Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Usub16Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Usub16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Usub16Builder<false, false, false> {
        pub fn new() -> Usub16Builder<false, false, false> {
            Usub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Usub16 {
        pub fn builder() -> Usub16Builder<false, false, false> {
            Usub16Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Usub16Builder<true, true, true> {
        pub fn complete(self) -> Usub16 {
            Usub16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Usub16Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Usub16Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Usub16Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Usub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Usub16Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Usub16Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Usub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Usub16Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Usub16Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Usub16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Usub16 {
        pub fn consumer(self) -> Usub16Consumer<false, false, false> {
            Usub16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Usub16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Usub16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Usub16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Usub16 {
        #[inline]
        fn clone(&self) -> Usub16 {
            Usub16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Usub16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Usub16 {
        #[inline]
        fn eq(&self, other: &Usub16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Usub16> for Operation {
        fn from(val: Usub16) -> Operation {
            Operation::Usub16(val)
        }
    }
    pub struct Usub8 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
    }
    pub struct Usub8Builder<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<const rnSET: bool, const rmSET: bool> Usub8Builder<false, rnSET, rmSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Usub8Builder<true, rnSET, rmSET> {
            self.rd = Some(rd);
            Usub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Usub8Builder<rdSET, false, rmSET> {
        pub fn set_rn(mut self, rn: Register) -> Usub8Builder<rdSET, true, rmSET> {
            self.rn = Some(rn);
            Usub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl<const rdSET: bool, const rnSET: bool> Usub8Builder<rdSET, rnSET, false> {
        pub fn set_rm(mut self, rm: Register) -> Usub8Builder<rdSET, rnSET, true> {
            self.rm = Some(rm);
            Usub8Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
            }
        }
    }
    impl Usub8Builder<false, false, false> {
        pub fn new() -> Usub8Builder<false, false, false> {
            Usub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Usub8 {
        pub fn builder() -> Usub8Builder<false, false, false> {
            Usub8Builder {
                rd: None,
                rn: None,
                rm: None,
            }
        }
    }
    impl Usub8Builder<true, true, true> {
        pub fn complete(self) -> Usub8 {
            Usub8 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
            }
        }
    }
    pub struct Usub8Consumer<const rdSET: bool, const rnSET: bool, const rmSET: bool> {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Usub8Consumer<false, rnCONSUMED, rmCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Usub8Consumer<true, rnCONSUMED, rmCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Usub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Usub8Consumer<rdCONSUMED, false, rmCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, Usub8Consumer<rdCONSUMED, true, rmCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Usub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
    > Usub8Consumer<rdCONSUMED, rnCONSUMED, false> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Usub8Consumer<rdCONSUMED, rnCONSUMED, true>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Usub8Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                },
            )
        }
    }
    impl Usub8 {
        pub fn consumer(self) -> Usub8Consumer<false, false, false> {
            Usub8Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
            }
        }
    }
    impl Usub8Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Usub8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Usub8",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &&self.rm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Usub8 {
        #[inline]
        fn clone(&self) -> Usub8 {
            Usub8 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Usub8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Usub8 {
        #[inline]
        fn eq(&self, other: &Usub8) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
        }
    }
    impl From<Usub8> for Operation {
        fn from(val: Usub8) -> Operation {
            Operation::Usub8(val)
        }
    }
    pub struct Uxtab {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct UxtabBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > UxtabBuilder<false, rnSET, rmSET, rotationSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UxtabBuilder<true, rnSET, rmSET, rotationSET> {
            self.rd = Some(rd);
            UxtabBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > UxtabBuilder<rdSET, false, rmSET, rotationSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> UxtabBuilder<rdSET, true, rmSET, rotationSET> {
            self.rn = Some(rn);
            UxtabBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rotationSET: bool,
    > UxtabBuilder<rdSET, rnSET, false, rotationSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> UxtabBuilder<rdSET, rnSET, true, rotationSET> {
            self.rm = Some(rm);
            UxtabBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > UxtabBuilder<rdSET, rnSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> UxtabBuilder<rdSET, rnSET, rmSET, true> {
            self.rotation = Some(rotation);
            UxtabBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl UxtabBuilder<false, false, false, false> {
        pub fn new() -> UxtabBuilder<false, false, false, false> {
            UxtabBuilder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Uxtab {
        pub fn builder() -> UxtabBuilder<false, false, false, false> {
            UxtabBuilder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl UxtabBuilder<true, true, true, true> {
        pub fn complete(self) -> Uxtab {
            Uxtab {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct UxtabConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxtabConsumer<false, rnCONSUMED, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            UxtabConsumer<true, rnCONSUMED, rmCONSUMED, rotationCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UxtabConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxtabConsumer<rdCONSUMED, false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UxtabConsumer<rdCONSUMED, true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UxtabConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxtabConsumer<rdCONSUMED, rnCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UxtabConsumer<rdCONSUMED, rnCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UxtabConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UxtabConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, UxtabConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                UxtabConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Uxtab {
        pub fn consumer(self) -> UxtabConsumer<false, false, false, false> {
            UxtabConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl UxtabConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uxtab {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Uxtab",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uxtab {
        #[inline]
        fn clone(&self) -> Uxtab {
            Uxtab {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uxtab {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uxtab {
        #[inline]
        fn eq(&self, other: &Uxtab) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.rotation == other.rotation
        }
    }
    impl From<Uxtab> for Operation {
        fn from(val: Uxtab) -> Operation {
            Operation::Uxtab(val)
        }
    }
    pub struct Uxtab16 {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct Uxtab16Builder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > Uxtab16Builder<false, rnSET, rmSET, rotationSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uxtab16Builder<true, rnSET, rmSET, rotationSET> {
            self.rd = Some(rd);
            Uxtab16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > Uxtab16Builder<rdSET, false, rmSET, rotationSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> Uxtab16Builder<rdSET, true, rmSET, rotationSET> {
            self.rn = Some(rn);
            Uxtab16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rotationSET: bool,
    > Uxtab16Builder<rdSET, rnSET, false, rotationSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> Uxtab16Builder<rdSET, rnSET, true, rotationSET> {
            self.rm = Some(rm);
            Uxtab16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > Uxtab16Builder<rdSET, rnSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> Uxtab16Builder<rdSET, rnSET, rmSET, true> {
            self.rotation = Some(rotation);
            Uxtab16Builder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl Uxtab16Builder<false, false, false, false> {
        pub fn new() -> Uxtab16Builder<false, false, false, false> {
            Uxtab16Builder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Uxtab16 {
        pub fn builder() -> Uxtab16Builder<false, false, false, false> {
            Uxtab16Builder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Uxtab16Builder<true, true, true, true> {
        pub fn complete(self) -> Uxtab16 {
            Uxtab16 {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct Uxtab16Consumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Uxtab16Consumer<false, rnCONSUMED, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            Uxtab16Consumer<true, rnCONSUMED, rmCONSUMED, rotationCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uxtab16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Uxtab16Consumer<rdCONSUMED, false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (
            Register,
            Uxtab16Consumer<rdCONSUMED, true, rmCONSUMED, rotationCONSUMED>,
        ) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                Uxtab16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Uxtab16Consumer<rdCONSUMED, rnCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (
            Register,
            Uxtab16Consumer<rdCONSUMED, rnCONSUMED, true, rotationCONSUMED>,
        ) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uxtab16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uxtab16Consumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, Uxtab16Consumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                Uxtab16Consumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Uxtab16 {
        pub fn consumer(self) -> Uxtab16Consumer<false, false, false, false> {
            Uxtab16Consumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl Uxtab16Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uxtab16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Uxtab16",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uxtab16 {
        #[inline]
        fn clone(&self) -> Uxtab16 {
            Uxtab16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uxtab16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uxtab16 {
        #[inline]
        fn eq(&self, other: &Uxtab16) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.rotation == other.rotation
        }
    }
    impl From<Uxtab16> for Operation {
        fn from(val: Uxtab16) -> Operation {
            Operation::Uxtab16(val)
        }
    }
    pub struct Uxtah {
        pub rd: Option<Register>,
        pub rn: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct UxtahBuilder<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > UxtahBuilder<false, rnSET, rmSET, rotationSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> UxtahBuilder<true, rnSET, rmSET, rotationSET> {
            self.rd = Some(rd);
            UxtahBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > UxtahBuilder<rdSET, false, rmSET, rotationSET> {
        pub fn set_rn(
            mut self,
            rn: Register,
        ) -> UxtahBuilder<rdSET, true, rmSET, rotationSET> {
            self.rn = Some(rn);
            UxtahBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rotationSET: bool,
    > UxtahBuilder<rdSET, rnSET, false, rotationSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> UxtahBuilder<rdSET, rnSET, true, rotationSET> {
            self.rm = Some(rm);
            UxtahBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
    > UxtahBuilder<rdSET, rnSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> UxtahBuilder<rdSET, rnSET, rmSET, true> {
            self.rotation = Some(rotation);
            UxtahBuilder {
                rd: self.rd,
                rn: self.rn,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl UxtahBuilder<false, false, false, false> {
        pub fn new() -> UxtahBuilder<false, false, false, false> {
            UxtahBuilder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Uxtah {
        pub fn builder() -> UxtahBuilder<false, false, false, false> {
            UxtahBuilder {
                rd: None,
                rn: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl UxtahBuilder<true, true, true, true> {
        pub fn complete(self) -> Uxtah {
            Uxtah {
                rd: self.rd.unwrap(),
                rn: self.rn.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct UxtahConsumer<
        const rdSET: bool,
        const rnSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rn: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxtahConsumer<false, rnCONSUMED, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (
            Option<Register>,
            UxtahConsumer<true, rnCONSUMED, rmCONSUMED, rotationCONSUMED>,
        ) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UxtahConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxtahConsumer<rdCONSUMED, false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rn(
            mut self,
        ) -> (Register, UxtahConsumer<rdCONSUMED, true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rn.unwrap();
            self.rn = None;
            (
                ret,
                UxtahConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxtahConsumer<rdCONSUMED, rnCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UxtahConsumer<rdCONSUMED, rnCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UxtahConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rnCONSUMED: bool,
        const rmCONSUMED: bool,
    > UxtahConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, UxtahConsumer<rdCONSUMED, rnCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                UxtahConsumer {
                    rd: self.rd,
                    rn: self.rn,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Uxtah {
        pub fn consumer(self) -> UxtahConsumer<false, false, false, false> {
            UxtahConsumer {
                rd: Some(self.rd),
                rn: Some(self.rn),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl UxtahConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uxtah {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Uxtah",
                "rd",
                &self.rd,
                "rn",
                &self.rn,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uxtah {
        #[inline]
        fn clone(&self) -> Uxtah {
            Uxtah {
                rd: ::core::clone::Clone::clone(&self.rd),
                rn: ::core::clone::Clone::clone(&self.rn),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uxtah {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uxtah {
        #[inline]
        fn eq(&self, other: &Uxtah) -> bool {
            self.rd == other.rd && self.rn == other.rn && self.rm == other.rm
                && self.rotation == other.rotation
        }
    }
    impl From<Uxtah> for Operation {
        fn from(val: Uxtah) -> Operation {
            Operation::Uxtah(val)
        }
    }
    pub struct Uxtb {
        pub rd: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct UxtbBuilder<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmSET: bool,
        const rotationSET: bool,
    > UxtbBuilder<false, rmSET, rotationSET> {
        pub fn set_rd(mut self, rd: Register) -> UxtbBuilder<true, rmSET, rotationSET> {
            self.rd = Some(rd);
            UxtbBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rotationSET: bool,
    > UxtbBuilder<rdSET, false, rotationSET> {
        pub fn set_rm(mut self, rm: Register) -> UxtbBuilder<rdSET, true, rotationSET> {
            self.rm = Some(rm);
            UxtbBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UxtbBuilder<rdSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> UxtbBuilder<rdSET, rmSET, true> {
            self.rotation = Some(rotation);
            UxtbBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl UxtbBuilder<false, false, false> {
        pub fn new() -> UxtbBuilder<false, false, false> {
            UxtbBuilder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Uxtb {
        pub fn builder() -> UxtbBuilder<false, false, false> {
            UxtbBuilder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl UxtbBuilder<true, true, true> {
        pub fn complete(self) -> Uxtb {
            Uxtb {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct UxtbConsumer<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxtbConsumer<false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, UxtbConsumer<true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UxtbConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxtbConsumer<rdCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UxtbConsumer<rdCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UxtbConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UxtbConsumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, UxtbConsumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                UxtbConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Uxtb {
        pub fn consumer(self) -> UxtbConsumer<false, false, false> {
            UxtbConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl UxtbConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uxtb {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uxtb",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uxtb {
        #[inline]
        fn clone(&self) -> Uxtb {
            Uxtb {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uxtb {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uxtb {
        #[inline]
        fn eq(&self, other: &Uxtb) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rotation == other.rotation
        }
    }
    impl From<Uxtb> for Operation {
        fn from(val: Uxtb) -> Operation {
            Operation::Uxtb(val)
        }
    }
    pub struct Uxtb16 {
        pub rd: Option<Register>,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct Uxtb16Builder<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmSET: bool,
        const rotationSET: bool,
    > Uxtb16Builder<false, rmSET, rotationSET> {
        pub fn set_rd(
            mut self,
            rd: Option<Register>,
        ) -> Uxtb16Builder<true, rmSET, rotationSET> {
            self.rd = Some(rd);
            Uxtb16Builder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rotationSET: bool,
    > Uxtb16Builder<rdSET, false, rotationSET> {
        pub fn set_rm(
            mut self,
            rm: Register,
        ) -> Uxtb16Builder<rdSET, true, rotationSET> {
            self.rm = Some(rm);
            Uxtb16Builder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> Uxtb16Builder<rdSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> Uxtb16Builder<rdSET, rmSET, true> {
            self.rotation = Some(rotation);
            Uxtb16Builder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl Uxtb16Builder<false, false, false> {
        pub fn new() -> Uxtb16Builder<false, false, false> {
            Uxtb16Builder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Uxtb16 {
        pub fn builder() -> Uxtb16Builder<false, false, false> {
            Uxtb16Builder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Uxtb16Builder<true, true, true> {
        pub fn complete(self) -> Uxtb16 {
            Uxtb16 {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct Uxtb16Consumer<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Option<Register>>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Uxtb16Consumer<false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Option<Register>, Uxtb16Consumer<true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                Uxtb16Consumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rotationCONSUMED: bool,
    > Uxtb16Consumer<rdCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, Uxtb16Consumer<rdCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                Uxtb16Consumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > Uxtb16Consumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, Uxtb16Consumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                Uxtb16Consumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Uxtb16 {
        pub fn consumer(self) -> Uxtb16Consumer<false, false, false> {
            Uxtb16Consumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl Uxtb16Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uxtb16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uxtb16",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uxtb16 {
        #[inline]
        fn clone(&self) -> Uxtb16 {
            Uxtb16 {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uxtb16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uxtb16 {
        #[inline]
        fn eq(&self, other: &Uxtb16) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rotation == other.rotation
        }
    }
    impl From<Uxtb16> for Operation {
        fn from(val: Uxtb16) -> Operation {
            Operation::Uxtb16(val)
        }
    }
    pub struct Uxth {
        pub rd: Register,
        pub rm: Register,
        pub rotation: Option<u32>,
    }
    pub struct UxthBuilder<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmSET: bool,
        const rotationSET: bool,
    > UxthBuilder<false, rmSET, rotationSET> {
        pub fn set_rd(mut self, rd: Register) -> UxthBuilder<true, rmSET, rotationSET> {
            self.rd = Some(rd);
            UxthBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<
        const rdSET: bool,
        const rotationSET: bool,
    > UxthBuilder<rdSET, false, rotationSET> {
        pub fn set_rm(mut self, rm: Register) -> UxthBuilder<rdSET, true, rotationSET> {
            self.rm = Some(rm);
            UxthBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl<const rdSET: bool, const rmSET: bool> UxthBuilder<rdSET, rmSET, false> {
        pub fn set_rotation(
            mut self,
            rotation: Option<u32>,
        ) -> UxthBuilder<rdSET, rmSET, true> {
            self.rotation = Some(rotation);
            UxthBuilder {
                rd: self.rd,
                rm: self.rm,
                rotation: self.rotation,
            }
        }
    }
    impl UxthBuilder<false, false, false> {
        pub fn new() -> UxthBuilder<false, false, false> {
            UxthBuilder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl Uxth {
        pub fn builder() -> UxthBuilder<false, false, false> {
            UxthBuilder {
                rd: None,
                rm: None,
                rotation: None,
            }
        }
    }
    impl UxthBuilder<true, true, true> {
        pub fn complete(self) -> Uxth {
            Uxth {
                rd: self.rd.unwrap(),
                rm: self.rm.unwrap(),
                rotation: self.rotation.unwrap(),
            }
        }
    }
    pub struct UxthConsumer<
        const rdSET: bool,
        const rmSET: bool,
        const rotationSET: bool,
    > {
        rd: Option<Register>,
        rm: Option<Register>,
        rotation: Option<Option<u32>>,
    }
    impl<
        const rmCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxthConsumer<false, rmCONSUMED, rotationCONSUMED> {
        pub fn consume_rd(
            mut self,
        ) -> (Register, UxthConsumer<true, rmCONSUMED, rotationCONSUMED>) {
            let ret = self.rd.unwrap();
            self.rd = None;
            (
                ret,
                UxthConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rotationCONSUMED: bool,
    > UxthConsumer<rdCONSUMED, false, rotationCONSUMED> {
        pub fn consume_rm(
            mut self,
        ) -> (Register, UxthConsumer<rdCONSUMED, true, rotationCONSUMED>) {
            let ret = self.rm.unwrap();
            self.rm = None;
            (
                ret,
                UxthConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl<
        const rdCONSUMED: bool,
        const rmCONSUMED: bool,
    > UxthConsumer<rdCONSUMED, rmCONSUMED, false> {
        pub fn consume_rotation(
            mut self,
        ) -> (Option<u32>, UxthConsumer<rdCONSUMED, rmCONSUMED, true>) {
            let ret = self.rotation.unwrap();
            self.rotation = None;
            (
                ret,
                UxthConsumer {
                    rd: self.rd,
                    rm: self.rm,
                    rotation: self.rotation,
                },
            )
        }
    }
    impl Uxth {
        pub fn consumer(self) -> UxthConsumer<false, false, false> {
            UxthConsumer {
                rd: Some(self.rd),
                rm: Some(self.rm),
                rotation: Some(self.rotation),
            }
        }
    }
    impl UxthConsumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uxth {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Uxth",
                "rd",
                &self.rd,
                "rm",
                &self.rm,
                "rotation",
                &&self.rotation,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uxth {
        #[inline]
        fn clone(&self) -> Uxth {
            Uxth {
                rd: ::core::clone::Clone::clone(&self.rd),
                rm: ::core::clone::Clone::clone(&self.rm),
                rotation: ::core::clone::Clone::clone(&self.rotation),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uxth {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uxth {
        #[inline]
        fn eq(&self, other: &Uxth) -> bool {
            self.rd == other.rd && self.rm == other.rm && self.rotation == other.rotation
        }
    }
    impl From<Uxth> for Operation {
        fn from(val: Uxth) -> Operation {
            Operation::Uxth(val)
        }
    }
    pub struct VselF32 {
        pub cond: Option<Condition>,
        pub sd: F32Register,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VselF32Builder<
        const condSET: bool,
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > {
        cond: Option<Option<Condition>>,
        sd: Option<F32Register>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > VselF32Builder<false, sdSET, snSET, smSET> {
        pub fn set_cond(
            mut self,
            cond: Option<Condition>,
        ) -> VselF32Builder<true, sdSET, snSET, smSET> {
            self.cond = Some(cond);
            VselF32Builder {
                cond: self.cond,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const condSET: bool,
        const snSET: bool,
        const smSET: bool,
    > VselF32Builder<condSET, false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: F32Register,
        ) -> VselF32Builder<condSET, true, snSET, smSET> {
            self.sd = Some(sd);
            VselF32Builder {
                cond: self.cond,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const condSET: bool,
        const sdSET: bool,
        const smSET: bool,
    > VselF32Builder<condSET, sdSET, false, smSET> {
        pub fn set_sn(
            mut self,
            sn: F32Register,
        ) -> VselF32Builder<condSET, sdSET, true, smSET> {
            self.sn = Some(sn);
            VselF32Builder {
                cond: self.cond,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const condSET: bool,
        const sdSET: bool,
        const snSET: bool,
    > VselF32Builder<condSET, sdSET, snSET, false> {
        pub fn set_sm(
            mut self,
            sm: F32Register,
        ) -> VselF32Builder<condSET, sdSET, snSET, true> {
            self.sm = Some(sm);
            VselF32Builder {
                cond: self.cond,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VselF32Builder<false, false, false, false> {
        pub fn new() -> VselF32Builder<false, false, false, false> {
            VselF32Builder {
                cond: None,
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VselF32 {
        pub fn builder() -> VselF32Builder<false, false, false, false> {
            VselF32Builder {
                cond: None,
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VselF32Builder<true, true, true, true> {
        pub fn complete(self) -> VselF32 {
            VselF32 {
                cond: self.cond.unwrap(),
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VselF32Consumer<
        const condSET: bool,
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > {
        cond: Option<Option<Condition>>,
        sd: Option<F32Register>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VselF32Consumer<false, sdCONSUMED, snCONSUMED, smCONSUMED> {
        pub fn consume_cond(
            mut self,
        ) -> (
            Option<Condition>,
            VselF32Consumer<true, sdCONSUMED, snCONSUMED, smCONSUMED>,
        ) {
            let ret = self.cond.unwrap();
            self.cond = None;
            (
                ret,
                VselF32Consumer {
                    cond: self.cond,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const condCONSUMED: bool,
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VselF32Consumer<condCONSUMED, false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VselF32Consumer<condCONSUMED, true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VselF32Consumer {
                    cond: self.cond,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const condCONSUMED: bool,
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VselF32Consumer<condCONSUMED, sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VselF32Consumer<condCONSUMED, sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VselF32Consumer {
                    cond: self.cond,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const condCONSUMED: bool,
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VselF32Consumer<condCONSUMED, sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VselF32Consumer<condCONSUMED, sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VselF32Consumer {
                    cond: self.cond,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VselF32 {
        pub fn consumer(self) -> VselF32Consumer<false, false, false, false> {
            VselF32Consumer {
                cond: Some(self.cond),
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VselF32Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VselF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "VselF32",
                "cond",
                &self.cond,
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VselF32 {
        #[inline]
        fn clone(&self) -> VselF32 {
            VselF32 {
                cond: ::core::clone::Clone::clone(&self.cond),
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VselF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VselF32 {
        #[inline]
        fn eq(&self, other: &VselF32) -> bool {
            self.cond == other.cond && self.sd == other.sd && self.sn == other.sn
                && self.sm == other.sm
        }
    }
    impl From<VselF32> for Operation {
        fn from(val: VselF32) -> Operation {
            Operation::VselF32(val)
        }
    }
    pub struct VselF64 {
        pub cond: Option<Condition>,
        pub dd: F64Register,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VselF64Builder<
        const condSET: bool,
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > {
        cond: Option<Option<Condition>>,
        dd: Option<F64Register>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > VselF64Builder<false, ddSET, dnSET, dmSET> {
        pub fn set_cond(
            mut self,
            cond: Option<Condition>,
        ) -> VselF64Builder<true, ddSET, dnSET, dmSET> {
            self.cond = Some(cond);
            VselF64Builder {
                cond: self.cond,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const condSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > VselF64Builder<condSET, false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: F64Register,
        ) -> VselF64Builder<condSET, true, dnSET, dmSET> {
            self.dd = Some(dd);
            VselF64Builder {
                cond: self.cond,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const condSET: bool,
        const ddSET: bool,
        const dmSET: bool,
    > VselF64Builder<condSET, ddSET, false, dmSET> {
        pub fn set_dn(
            mut self,
            dn: F64Register,
        ) -> VselF64Builder<condSET, ddSET, true, dmSET> {
            self.dn = Some(dn);
            VselF64Builder {
                cond: self.cond,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const condSET: bool,
        const ddSET: bool,
        const dnSET: bool,
    > VselF64Builder<condSET, ddSET, dnSET, false> {
        pub fn set_dm(
            mut self,
            dm: F64Register,
        ) -> VselF64Builder<condSET, ddSET, dnSET, true> {
            self.dm = Some(dm);
            VselF64Builder {
                cond: self.cond,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VselF64Builder<false, false, false, false> {
        pub fn new() -> VselF64Builder<false, false, false, false> {
            VselF64Builder {
                cond: None,
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VselF64 {
        pub fn builder() -> VselF64Builder<false, false, false, false> {
            VselF64Builder {
                cond: None,
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VselF64Builder<true, true, true, true> {
        pub fn complete(self) -> VselF64 {
            VselF64 {
                cond: self.cond.unwrap(),
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VselF64Consumer<
        const condSET: bool,
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > {
        cond: Option<Option<Condition>>,
        dd: Option<F64Register>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VselF64Consumer<false, ddCONSUMED, dnCONSUMED, dmCONSUMED> {
        pub fn consume_cond(
            mut self,
        ) -> (
            Option<Condition>,
            VselF64Consumer<true, ddCONSUMED, dnCONSUMED, dmCONSUMED>,
        ) {
            let ret = self.cond.unwrap();
            self.cond = None;
            (
                ret,
                VselF64Consumer {
                    cond: self.cond,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const condCONSUMED: bool,
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VselF64Consumer<condCONSUMED, false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VselF64Consumer<condCONSUMED, true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VselF64Consumer {
                    cond: self.cond,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const condCONSUMED: bool,
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VselF64Consumer<condCONSUMED, ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VselF64Consumer<condCONSUMED, ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VselF64Consumer {
                    cond: self.cond,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const condCONSUMED: bool,
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VselF64Consumer<condCONSUMED, ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VselF64Consumer<condCONSUMED, ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VselF64Consumer {
                    cond: self.cond,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VselF64 {
        pub fn consumer(self) -> VselF64Consumer<false, false, false, false> {
            VselF64Consumer {
                cond: Some(self.cond),
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VselF64Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VselF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "VselF64",
                "cond",
                &self.cond,
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VselF64 {
        #[inline]
        fn clone(&self) -> VselF64 {
            VselF64 {
                cond: ::core::clone::Clone::clone(&self.cond),
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VselF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VselF64 {
        #[inline]
        fn eq(&self, other: &VselF64) -> bool {
            self.cond == other.cond && self.dd == other.dd && self.dn == other.dn
                && self.dm == other.dm
        }
    }
    impl From<VselF64> for Operation {
        fn from(val: VselF64) -> Operation {
            Operation::VselF64(val)
        }
    }
    pub struct VmlF32 {
        pub y: bool,
        pub sd: F32Register,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VmlF32Builder<
        const ySET: bool,
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > {
        y: Option<bool>,
        sd: Option<F32Register>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > VmlF32Builder<false, sdSET, snSET, smSET> {
        pub fn set_y(mut self, y: bool) -> VmlF32Builder<true, sdSET, snSET, smSET> {
            self.y = Some(y);
            VmlF32Builder {
                y: self.y,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const ySET: bool,
        const snSET: bool,
        const smSET: bool,
    > VmlF32Builder<ySET, false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: F32Register,
        ) -> VmlF32Builder<ySET, true, snSET, smSET> {
            self.sd = Some(sd);
            VmlF32Builder {
                y: self.y,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const ySET: bool,
        const sdSET: bool,
        const smSET: bool,
    > VmlF32Builder<ySET, sdSET, false, smSET> {
        pub fn set_sn(
            mut self,
            sn: F32Register,
        ) -> VmlF32Builder<ySET, sdSET, true, smSET> {
            self.sn = Some(sn);
            VmlF32Builder {
                y: self.y,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const ySET: bool,
        const sdSET: bool,
        const snSET: bool,
    > VmlF32Builder<ySET, sdSET, snSET, false> {
        pub fn set_sm(
            mut self,
            sm: F32Register,
        ) -> VmlF32Builder<ySET, sdSET, snSET, true> {
            self.sm = Some(sm);
            VmlF32Builder {
                y: self.y,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VmlF32Builder<false, false, false, false> {
        pub fn new() -> VmlF32Builder<false, false, false, false> {
            VmlF32Builder {
                y: None,
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VmlF32 {
        pub fn builder() -> VmlF32Builder<false, false, false, false> {
            VmlF32Builder {
                y: None,
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VmlF32Builder<true, true, true, true> {
        pub fn complete(self) -> VmlF32 {
            VmlF32 {
                y: self.y.unwrap(),
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VmlF32Consumer<
        const ySET: bool,
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > {
        y: Option<bool>,
        sd: Option<F32Register>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VmlF32Consumer<false, sdCONSUMED, snCONSUMED, smCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (bool, VmlF32Consumer<true, sdCONSUMED, snCONSUMED, smCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VmlF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VmlF32Consumer<yCONSUMED, false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VmlF32Consumer<yCONSUMED, true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VmlF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VmlF32Consumer<yCONSUMED, sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VmlF32Consumer<yCONSUMED, sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VmlF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VmlF32Consumer<yCONSUMED, sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VmlF32Consumer<yCONSUMED, sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VmlF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VmlF32 {
        pub fn consumer(self) -> VmlF32Consumer<false, false, false, false> {
            VmlF32Consumer {
                y: Some(self.y),
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VmlF32Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmlF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "VmlF32",
                "y",
                &self.y,
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmlF32 {
        #[inline]
        fn clone(&self) -> VmlF32 {
            VmlF32 {
                y: ::core::clone::Clone::clone(&self.y),
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmlF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmlF32 {
        #[inline]
        fn eq(&self, other: &VmlF32) -> bool {
            self.y == other.y && self.sd == other.sd && self.sn == other.sn
                && self.sm == other.sm
        }
    }
    impl From<VmlF32> for Operation {
        fn from(val: VmlF32) -> Operation {
            Operation::VmlF32(val)
        }
    }
    pub struct VmlF64 {
        pub y: bool,
        pub dd: F64Register,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VmlF64Builder<
        const ySET: bool,
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > {
        y: Option<bool>,
        dd: Option<F64Register>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > VmlF64Builder<false, ddSET, dnSET, dmSET> {
        pub fn set_y(mut self, y: bool) -> VmlF64Builder<true, ddSET, dnSET, dmSET> {
            self.y = Some(y);
            VmlF64Builder {
                y: self.y,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const ySET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > VmlF64Builder<ySET, false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: F64Register,
        ) -> VmlF64Builder<ySET, true, dnSET, dmSET> {
            self.dd = Some(dd);
            VmlF64Builder {
                y: self.y,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const ySET: bool,
        const ddSET: bool,
        const dmSET: bool,
    > VmlF64Builder<ySET, ddSET, false, dmSET> {
        pub fn set_dn(
            mut self,
            dn: F64Register,
        ) -> VmlF64Builder<ySET, ddSET, true, dmSET> {
            self.dn = Some(dn);
            VmlF64Builder {
                y: self.y,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const ySET: bool,
        const ddSET: bool,
        const dnSET: bool,
    > VmlF64Builder<ySET, ddSET, dnSET, false> {
        pub fn set_dm(
            mut self,
            dm: F64Register,
        ) -> VmlF64Builder<ySET, ddSET, dnSET, true> {
            self.dm = Some(dm);
            VmlF64Builder {
                y: self.y,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VmlF64Builder<false, false, false, false> {
        pub fn new() -> VmlF64Builder<false, false, false, false> {
            VmlF64Builder {
                y: None,
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VmlF64 {
        pub fn builder() -> VmlF64Builder<false, false, false, false> {
            VmlF64Builder {
                y: None,
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VmlF64Builder<true, true, true, true> {
        pub fn complete(self) -> VmlF64 {
            VmlF64 {
                y: self.y.unwrap(),
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VmlF64Consumer<
        const ySET: bool,
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > {
        y: Option<bool>,
        dd: Option<F64Register>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VmlF64Consumer<false, ddCONSUMED, dnCONSUMED, dmCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (bool, VmlF64Consumer<true, ddCONSUMED, dnCONSUMED, dmCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VmlF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VmlF64Consumer<yCONSUMED, false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VmlF64Consumer<yCONSUMED, true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VmlF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VmlF64Consumer<yCONSUMED, ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VmlF64Consumer<yCONSUMED, ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VmlF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VmlF64Consumer<yCONSUMED, ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VmlF64Consumer<yCONSUMED, ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VmlF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VmlF64 {
        pub fn consumer(self) -> VmlF64Consumer<false, false, false, false> {
            VmlF64Consumer {
                y: Some(self.y),
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VmlF64Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmlF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "VmlF64",
                "y",
                &self.y,
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmlF64 {
        #[inline]
        fn clone(&self) -> VmlF64 {
            VmlF64 {
                y: ::core::clone::Clone::clone(&self.y),
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmlF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmlF64 {
        #[inline]
        fn eq(&self, other: &VmlF64) -> bool {
            self.y == other.y && self.dd == other.dd && self.dn == other.dn
                && self.dm == other.dm
        }
    }
    impl From<VmlF64> for Operation {
        fn from(val: VmlF64) -> Operation {
            Operation::VmlF64(val)
        }
    }
    pub struct VnmlF32 {
        pub y: bool,
        pub sd: F32Register,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VnmlF32Builder<
        const ySET: bool,
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > {
        y: Option<bool>,
        sd: Option<F32Register>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > VnmlF32Builder<false, sdSET, snSET, smSET> {
        pub fn set_y(mut self, y: bool) -> VnmlF32Builder<true, sdSET, snSET, smSET> {
            self.y = Some(y);
            VnmlF32Builder {
                y: self.y,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const ySET: bool,
        const snSET: bool,
        const smSET: bool,
    > VnmlF32Builder<ySET, false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: F32Register,
        ) -> VnmlF32Builder<ySET, true, snSET, smSET> {
            self.sd = Some(sd);
            VnmlF32Builder {
                y: self.y,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const ySET: bool,
        const sdSET: bool,
        const smSET: bool,
    > VnmlF32Builder<ySET, sdSET, false, smSET> {
        pub fn set_sn(
            mut self,
            sn: F32Register,
        ) -> VnmlF32Builder<ySET, sdSET, true, smSET> {
            self.sn = Some(sn);
            VnmlF32Builder {
                y: self.y,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<
        const ySET: bool,
        const sdSET: bool,
        const snSET: bool,
    > VnmlF32Builder<ySET, sdSET, snSET, false> {
        pub fn set_sm(
            mut self,
            sm: F32Register,
        ) -> VnmlF32Builder<ySET, sdSET, snSET, true> {
            self.sm = Some(sm);
            VnmlF32Builder {
                y: self.y,
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VnmlF32Builder<false, false, false, false> {
        pub fn new() -> VnmlF32Builder<false, false, false, false> {
            VnmlF32Builder {
                y: None,
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VnmlF32 {
        pub fn builder() -> VnmlF32Builder<false, false, false, false> {
            VnmlF32Builder {
                y: None,
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VnmlF32Builder<true, true, true, true> {
        pub fn complete(self) -> VnmlF32 {
            VnmlF32 {
                y: self.y.unwrap(),
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VnmlF32Consumer<
        const ySET: bool,
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > {
        y: Option<bool>,
        sd: Option<F32Register>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VnmlF32Consumer<false, sdCONSUMED, snCONSUMED, smCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (bool, VnmlF32Consumer<true, sdCONSUMED, snCONSUMED, smCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VnmlF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VnmlF32Consumer<yCONSUMED, false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VnmlF32Consumer<yCONSUMED, true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VnmlF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VnmlF32Consumer<yCONSUMED, sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VnmlF32Consumer<yCONSUMED, sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VnmlF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VnmlF32Consumer<yCONSUMED, sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VnmlF32Consumer<yCONSUMED, sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VnmlF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VnmlF32 {
        pub fn consumer(self) -> VnmlF32Consumer<false, false, false, false> {
            VnmlF32Consumer {
                y: Some(self.y),
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VnmlF32Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VnmlF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "VnmlF32",
                "y",
                &self.y,
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VnmlF32 {
        #[inline]
        fn clone(&self) -> VnmlF32 {
            VnmlF32 {
                y: ::core::clone::Clone::clone(&self.y),
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VnmlF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VnmlF32 {
        #[inline]
        fn eq(&self, other: &VnmlF32) -> bool {
            self.y == other.y && self.sd == other.sd && self.sn == other.sn
                && self.sm == other.sm
        }
    }
    impl From<VnmlF32> for Operation {
        fn from(val: VnmlF32) -> Operation {
            Operation::VnmlF32(val)
        }
    }
    pub struct VnmlF64 {
        pub y: bool,
        pub dd: F64Register,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VnmlF64Builder<
        const ySET: bool,
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > {
        y: Option<bool>,
        dd: Option<F64Register>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > VnmlF64Builder<false, ddSET, dnSET, dmSET> {
        pub fn set_y(mut self, y: bool) -> VnmlF64Builder<true, ddSET, dnSET, dmSET> {
            self.y = Some(y);
            VnmlF64Builder {
                y: self.y,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const ySET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > VnmlF64Builder<ySET, false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: F64Register,
        ) -> VnmlF64Builder<ySET, true, dnSET, dmSET> {
            self.dd = Some(dd);
            VnmlF64Builder {
                y: self.y,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const ySET: bool,
        const ddSET: bool,
        const dmSET: bool,
    > VnmlF64Builder<ySET, ddSET, false, dmSET> {
        pub fn set_dn(
            mut self,
            dn: F64Register,
        ) -> VnmlF64Builder<ySET, ddSET, true, dmSET> {
            self.dn = Some(dn);
            VnmlF64Builder {
                y: self.y,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<
        const ySET: bool,
        const ddSET: bool,
        const dnSET: bool,
    > VnmlF64Builder<ySET, ddSET, dnSET, false> {
        pub fn set_dm(
            mut self,
            dm: F64Register,
        ) -> VnmlF64Builder<ySET, ddSET, dnSET, true> {
            self.dm = Some(dm);
            VnmlF64Builder {
                y: self.y,
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VnmlF64Builder<false, false, false, false> {
        pub fn new() -> VnmlF64Builder<false, false, false, false> {
            VnmlF64Builder {
                y: None,
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VnmlF64 {
        pub fn builder() -> VnmlF64Builder<false, false, false, false> {
            VnmlF64Builder {
                y: None,
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VnmlF64Builder<true, true, true, true> {
        pub fn complete(self) -> VnmlF64 {
            VnmlF64 {
                y: self.y.unwrap(),
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VnmlF64Consumer<
        const ySET: bool,
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > {
        y: Option<bool>,
        dd: Option<F64Register>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VnmlF64Consumer<false, ddCONSUMED, dnCONSUMED, dmCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (bool, VnmlF64Consumer<true, ddCONSUMED, dnCONSUMED, dmCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VnmlF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VnmlF64Consumer<yCONSUMED, false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VnmlF64Consumer<yCONSUMED, true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VnmlF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VnmlF64Consumer<yCONSUMED, ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VnmlF64Consumer<yCONSUMED, ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VnmlF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VnmlF64Consumer<yCONSUMED, ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VnmlF64Consumer<yCONSUMED, ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VnmlF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VnmlF64 {
        pub fn consumer(self) -> VnmlF64Consumer<false, false, false, false> {
            VnmlF64Consumer {
                y: Some(self.y),
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VnmlF64Consumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VnmlF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "VnmlF64",
                "y",
                &self.y,
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VnmlF64 {
        #[inline]
        fn clone(&self) -> VnmlF64 {
            VnmlF64 {
                y: ::core::clone::Clone::clone(&self.y),
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VnmlF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VnmlF64 {
        #[inline]
        fn eq(&self, other: &VnmlF64) -> bool {
            self.y == other.y && self.dd == other.dd && self.dn == other.dn
                && self.dm == other.dm
        }
    }
    impl From<VnmlF64> for Operation {
        fn from(val: VnmlF64) -> Operation {
            Operation::VnmlF64(val)
        }
    }
    pub struct VnmulF32 {
        pub sd: Option<F32Register>,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VnmulF32Builder<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const snSET: bool, const smSET: bool> VnmulF32Builder<false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: Option<F32Register>,
        ) -> VnmulF32Builder<true, snSET, smSET> {
            self.sd = Some(sd);
            VnmulF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const smSET: bool> VnmulF32Builder<sdSET, false, smSET> {
        pub fn set_sn(mut self, sn: F32Register) -> VnmulF32Builder<sdSET, true, smSET> {
            self.sn = Some(sn);
            VnmulF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const snSET: bool> VnmulF32Builder<sdSET, snSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VnmulF32Builder<sdSET, snSET, true> {
            self.sm = Some(sm);
            VnmulF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VnmulF32Builder<false, false, false> {
        pub fn new() -> VnmulF32Builder<false, false, false> {
            VnmulF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VnmulF32 {
        pub fn builder() -> VnmulF32Builder<false, false, false> {
            VnmulF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VnmulF32Builder<true, true, true> {
        pub fn complete(self) -> VnmulF32 {
            VnmulF32 {
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VnmulF32Consumer<
        const sdSET: bool,
        const snSET: bool,
        const smSET: bool,
    > {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VnmulF32Consumer<false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (Option<F32Register>, VnmulF32Consumer<true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VnmulF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VnmulF32Consumer<sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VnmulF32Consumer<sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VnmulF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VnmulF32Consumer<sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VnmulF32Consumer<sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VnmulF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VnmulF32 {
        pub fn consumer(self) -> VnmulF32Consumer<false, false, false> {
            VnmulF32Consumer {
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VnmulF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VnmulF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VnmulF32",
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VnmulF32 {
        #[inline]
        fn clone(&self) -> VnmulF32 {
            VnmulF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VnmulF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VnmulF32 {
        #[inline]
        fn eq(&self, other: &VnmulF32) -> bool {
            self.sd == other.sd && self.sn == other.sn && self.sm == other.sm
        }
    }
    impl From<VnmulF32> for Operation {
        fn from(val: VnmulF32) -> Operation {
            Operation::VnmulF32(val)
        }
    }
    pub struct VnmulF64 {
        pub dd: Option<F64Register>,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VnmulF64Builder<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dnSET: bool, const dmSET: bool> VnmulF64Builder<false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: Option<F64Register>,
        ) -> VnmulF64Builder<true, dnSET, dmSET> {
            self.dd = Some(dd);
            VnmulF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dmSET: bool> VnmulF64Builder<ddSET, false, dmSET> {
        pub fn set_dn(mut self, dn: F64Register) -> VnmulF64Builder<ddSET, true, dmSET> {
            self.dn = Some(dn);
            VnmulF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dnSET: bool> VnmulF64Builder<ddSET, dnSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VnmulF64Builder<ddSET, dnSET, true> {
            self.dm = Some(dm);
            VnmulF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VnmulF64Builder<false, false, false> {
        pub fn new() -> VnmulF64Builder<false, false, false> {
            VnmulF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VnmulF64 {
        pub fn builder() -> VnmulF64Builder<false, false, false> {
            VnmulF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VnmulF64Builder<true, true, true> {
        pub fn complete(self) -> VnmulF64 {
            VnmulF64 {
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VnmulF64Consumer<
        const ddSET: bool,
        const dnSET: bool,
        const dmSET: bool,
    > {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VnmulF64Consumer<false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (Option<F64Register>, VnmulF64Consumer<true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VnmulF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VnmulF64Consumer<ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VnmulF64Consumer<ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VnmulF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VnmulF64Consumer<ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VnmulF64Consumer<ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VnmulF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VnmulF64 {
        pub fn consumer(self) -> VnmulF64Consumer<false, false, false> {
            VnmulF64Consumer {
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VnmulF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VnmulF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VnmulF64",
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VnmulF64 {
        #[inline]
        fn clone(&self) -> VnmulF64 {
            VnmulF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VnmulF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VnmulF64 {
        #[inline]
        fn eq(&self, other: &VnmulF64) -> bool {
            self.dd == other.dd && self.dn == other.dn && self.dm == other.dm
        }
    }
    impl From<VnmulF64> for Operation {
        fn from(val: VnmulF64) -> Operation {
            Operation::VnmulF64(val)
        }
    }
    pub struct VmulF32 {
        pub sd: Option<F32Register>,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VmulF32Builder<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const snSET: bool, const smSET: bool> VmulF32Builder<false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: Option<F32Register>,
        ) -> VmulF32Builder<true, snSET, smSET> {
            self.sd = Some(sd);
            VmulF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const smSET: bool> VmulF32Builder<sdSET, false, smSET> {
        pub fn set_sn(mut self, sn: F32Register) -> VmulF32Builder<sdSET, true, smSET> {
            self.sn = Some(sn);
            VmulF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const snSET: bool> VmulF32Builder<sdSET, snSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VmulF32Builder<sdSET, snSET, true> {
            self.sm = Some(sm);
            VmulF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VmulF32Builder<false, false, false> {
        pub fn new() -> VmulF32Builder<false, false, false> {
            VmulF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VmulF32 {
        pub fn builder() -> VmulF32Builder<false, false, false> {
            VmulF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VmulF32Builder<true, true, true> {
        pub fn complete(self) -> VmulF32 {
            VmulF32 {
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VmulF32Consumer<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VmulF32Consumer<false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (Option<F32Register>, VmulF32Consumer<true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VmulF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VmulF32Consumer<sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VmulF32Consumer<sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VmulF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VmulF32Consumer<sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VmulF32Consumer<sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VmulF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VmulF32 {
        pub fn consumer(self) -> VmulF32Consumer<false, false, false> {
            VmulF32Consumer {
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VmulF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmulF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VmulF32",
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmulF32 {
        #[inline]
        fn clone(&self) -> VmulF32 {
            VmulF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmulF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmulF32 {
        #[inline]
        fn eq(&self, other: &VmulF32) -> bool {
            self.sd == other.sd && self.sn == other.sn && self.sm == other.sm
        }
    }
    impl From<VmulF32> for Operation {
        fn from(val: VmulF32) -> Operation {
            Operation::VmulF32(val)
        }
    }
    pub struct VmulF64 {
        pub dd: Option<F64Register>,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VmulF64Builder<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dnSET: bool, const dmSET: bool> VmulF64Builder<false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: Option<F64Register>,
        ) -> VmulF64Builder<true, dnSET, dmSET> {
            self.dd = Some(dd);
            VmulF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dmSET: bool> VmulF64Builder<ddSET, false, dmSET> {
        pub fn set_dn(mut self, dn: F64Register) -> VmulF64Builder<ddSET, true, dmSET> {
            self.dn = Some(dn);
            VmulF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dnSET: bool> VmulF64Builder<ddSET, dnSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VmulF64Builder<ddSET, dnSET, true> {
            self.dm = Some(dm);
            VmulF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VmulF64Builder<false, false, false> {
        pub fn new() -> VmulF64Builder<false, false, false> {
            VmulF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VmulF64 {
        pub fn builder() -> VmulF64Builder<false, false, false> {
            VmulF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VmulF64Builder<true, true, true> {
        pub fn complete(self) -> VmulF64 {
            VmulF64 {
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VmulF64Consumer<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VmulF64Consumer<false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (Option<F64Register>, VmulF64Consumer<true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VmulF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VmulF64Consumer<ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VmulF64Consumer<ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VmulF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VmulF64Consumer<ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VmulF64Consumer<ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VmulF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VmulF64 {
        pub fn consumer(self) -> VmulF64Consumer<false, false, false> {
            VmulF64Consumer {
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VmulF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmulF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VmulF64",
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmulF64 {
        #[inline]
        fn clone(&self) -> VmulF64 {
            VmulF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmulF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmulF64 {
        #[inline]
        fn eq(&self, other: &VmulF64) -> bool {
            self.dd == other.dd && self.dn == other.dn && self.dm == other.dm
        }
    }
    impl From<VmulF64> for Operation {
        fn from(val: VmulF64) -> Operation {
            Operation::VmulF64(val)
        }
    }
    pub struct VaddF32 {
        pub sd: Option<F32Register>,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VaddF32Builder<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const snSET: bool, const smSET: bool> VaddF32Builder<false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: Option<F32Register>,
        ) -> VaddF32Builder<true, snSET, smSET> {
            self.sd = Some(sd);
            VaddF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const smSET: bool> VaddF32Builder<sdSET, false, smSET> {
        pub fn set_sn(mut self, sn: F32Register) -> VaddF32Builder<sdSET, true, smSET> {
            self.sn = Some(sn);
            VaddF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const snSET: bool> VaddF32Builder<sdSET, snSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VaddF32Builder<sdSET, snSET, true> {
            self.sm = Some(sm);
            VaddF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VaddF32Builder<false, false, false> {
        pub fn new() -> VaddF32Builder<false, false, false> {
            VaddF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VaddF32 {
        pub fn builder() -> VaddF32Builder<false, false, false> {
            VaddF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VaddF32Builder<true, true, true> {
        pub fn complete(self) -> VaddF32 {
            VaddF32 {
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VaddF32Consumer<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VaddF32Consumer<false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (Option<F32Register>, VaddF32Consumer<true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VaddF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VaddF32Consumer<sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VaddF32Consumer<sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VaddF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VaddF32Consumer<sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VaddF32Consumer<sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VaddF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VaddF32 {
        pub fn consumer(self) -> VaddF32Consumer<false, false, false> {
            VaddF32Consumer {
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VaddF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VaddF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VaddF32",
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VaddF32 {
        #[inline]
        fn clone(&self) -> VaddF32 {
            VaddF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VaddF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VaddF32 {
        #[inline]
        fn eq(&self, other: &VaddF32) -> bool {
            self.sd == other.sd && self.sn == other.sn && self.sm == other.sm
        }
    }
    impl From<VaddF32> for Operation {
        fn from(val: VaddF32) -> Operation {
            Operation::VaddF32(val)
        }
    }
    pub struct VaddF64 {
        pub dd: Option<F64Register>,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VaddF64Builder<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dnSET: bool, const dmSET: bool> VaddF64Builder<false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: Option<F64Register>,
        ) -> VaddF64Builder<true, dnSET, dmSET> {
            self.dd = Some(dd);
            VaddF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dmSET: bool> VaddF64Builder<ddSET, false, dmSET> {
        pub fn set_dn(mut self, dn: F64Register) -> VaddF64Builder<ddSET, true, dmSET> {
            self.dn = Some(dn);
            VaddF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dnSET: bool> VaddF64Builder<ddSET, dnSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VaddF64Builder<ddSET, dnSET, true> {
            self.dm = Some(dm);
            VaddF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VaddF64Builder<false, false, false> {
        pub fn new() -> VaddF64Builder<false, false, false> {
            VaddF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VaddF64 {
        pub fn builder() -> VaddF64Builder<false, false, false> {
            VaddF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VaddF64Builder<true, true, true> {
        pub fn complete(self) -> VaddF64 {
            VaddF64 {
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VaddF64Consumer<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VaddF64Consumer<false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (Option<F64Register>, VaddF64Consumer<true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VaddF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VaddF64Consumer<ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VaddF64Consumer<ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VaddF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VaddF64Consumer<ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VaddF64Consumer<ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VaddF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VaddF64 {
        pub fn consumer(self) -> VaddF64Consumer<false, false, false> {
            VaddF64Consumer {
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VaddF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VaddF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VaddF64",
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VaddF64 {
        #[inline]
        fn clone(&self) -> VaddF64 {
            VaddF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VaddF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VaddF64 {
        #[inline]
        fn eq(&self, other: &VaddF64) -> bool {
            self.dd == other.dd && self.dn == other.dn && self.dm == other.dm
        }
    }
    impl From<VaddF64> for Operation {
        fn from(val: VaddF64) -> Operation {
            Operation::VaddF64(val)
        }
    }
    pub struct VsubF32 {
        pub sd: Option<F32Register>,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VsubF32Builder<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const snSET: bool, const smSET: bool> VsubF32Builder<false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: Option<F32Register>,
        ) -> VsubF32Builder<true, snSET, smSET> {
            self.sd = Some(sd);
            VsubF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const smSET: bool> VsubF32Builder<sdSET, false, smSET> {
        pub fn set_sn(mut self, sn: F32Register) -> VsubF32Builder<sdSET, true, smSET> {
            self.sn = Some(sn);
            VsubF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const snSET: bool> VsubF32Builder<sdSET, snSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VsubF32Builder<sdSET, snSET, true> {
            self.sm = Some(sm);
            VsubF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VsubF32Builder<false, false, false> {
        pub fn new() -> VsubF32Builder<false, false, false> {
            VsubF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VsubF32 {
        pub fn builder() -> VsubF32Builder<false, false, false> {
            VsubF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VsubF32Builder<true, true, true> {
        pub fn complete(self) -> VsubF32 {
            VsubF32 {
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VsubF32Consumer<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VsubF32Consumer<false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (Option<F32Register>, VsubF32Consumer<true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VsubF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VsubF32Consumer<sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VsubF32Consumer<sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VsubF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VsubF32Consumer<sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VsubF32Consumer<sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VsubF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VsubF32 {
        pub fn consumer(self) -> VsubF32Consumer<false, false, false> {
            VsubF32Consumer {
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VsubF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VsubF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VsubF32",
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VsubF32 {
        #[inline]
        fn clone(&self) -> VsubF32 {
            VsubF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VsubF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VsubF32 {
        #[inline]
        fn eq(&self, other: &VsubF32) -> bool {
            self.sd == other.sd && self.sn == other.sn && self.sm == other.sm
        }
    }
    impl From<VsubF32> for Operation {
        fn from(val: VsubF32) -> Operation {
            Operation::VsubF32(val)
        }
    }
    pub struct VsubF64 {
        pub dd: Option<F64Register>,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VsubF64Builder<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dnSET: bool, const dmSET: bool> VsubF64Builder<false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: Option<F64Register>,
        ) -> VsubF64Builder<true, dnSET, dmSET> {
            self.dd = Some(dd);
            VsubF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dmSET: bool> VsubF64Builder<ddSET, false, dmSET> {
        pub fn set_dn(mut self, dn: F64Register) -> VsubF64Builder<ddSET, true, dmSET> {
            self.dn = Some(dn);
            VsubF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dnSET: bool> VsubF64Builder<ddSET, dnSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VsubF64Builder<ddSET, dnSET, true> {
            self.dm = Some(dm);
            VsubF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VsubF64Builder<false, false, false> {
        pub fn new() -> VsubF64Builder<false, false, false> {
            VsubF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VsubF64 {
        pub fn builder() -> VsubF64Builder<false, false, false> {
            VsubF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VsubF64Builder<true, true, true> {
        pub fn complete(self) -> VsubF64 {
            VsubF64 {
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VsubF64Consumer<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VsubF64Consumer<false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (Option<F64Register>, VsubF64Consumer<true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VsubF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VsubF64Consumer<ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VsubF64Consumer<ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VsubF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VsubF64Consumer<ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VsubF64Consumer<ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VsubF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VsubF64 {
        pub fn consumer(self) -> VsubF64Consumer<false, false, false> {
            VsubF64Consumer {
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VsubF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VsubF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VsubF64",
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VsubF64 {
        #[inline]
        fn clone(&self) -> VsubF64 {
            VsubF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VsubF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VsubF64 {
        #[inline]
        fn eq(&self, other: &VsubF64) -> bool {
            self.dd == other.dd && self.dn == other.dn && self.dm == other.dm
        }
    }
    impl From<VsubF64> for Operation {
        fn from(val: VsubF64) -> Operation {
            Operation::VsubF64(val)
        }
    }
    pub struct VdivF32 {
        pub sd: Option<F32Register>,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VdivF32Builder<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const snSET: bool, const smSET: bool> VdivF32Builder<false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: Option<F32Register>,
        ) -> VdivF32Builder<true, snSET, smSET> {
            self.sd = Some(sd);
            VdivF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const smSET: bool> VdivF32Builder<sdSET, false, smSET> {
        pub fn set_sn(mut self, sn: F32Register) -> VdivF32Builder<sdSET, true, smSET> {
            self.sn = Some(sn);
            VdivF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const snSET: bool> VdivF32Builder<sdSET, snSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VdivF32Builder<sdSET, snSET, true> {
            self.sm = Some(sm);
            VdivF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VdivF32Builder<false, false, false> {
        pub fn new() -> VdivF32Builder<false, false, false> {
            VdivF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VdivF32 {
        pub fn builder() -> VdivF32Builder<false, false, false> {
            VdivF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VdivF32Builder<true, true, true> {
        pub fn complete(self) -> VdivF32 {
            VdivF32 {
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VdivF32Consumer<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VdivF32Consumer<false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (Option<F32Register>, VdivF32Consumer<true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VdivF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VdivF32Consumer<sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VdivF32Consumer<sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VdivF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VdivF32Consumer<sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VdivF32Consumer<sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VdivF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VdivF32 {
        pub fn consumer(self) -> VdivF32Consumer<false, false, false> {
            VdivF32Consumer {
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VdivF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VdivF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VdivF32",
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VdivF32 {
        #[inline]
        fn clone(&self) -> VdivF32 {
            VdivF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VdivF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VdivF32 {
        #[inline]
        fn eq(&self, other: &VdivF32) -> bool {
            self.sd == other.sd && self.sn == other.sn && self.sm == other.sm
        }
    }
    impl From<VdivF32> for Operation {
        fn from(val: VdivF32) -> Operation {
            Operation::VdivF32(val)
        }
    }
    pub struct VdivF64 {
        pub dd: Option<F64Register>,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VdivF64Builder<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dnSET: bool, const dmSET: bool> VdivF64Builder<false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: Option<F64Register>,
        ) -> VdivF64Builder<true, dnSET, dmSET> {
            self.dd = Some(dd);
            VdivF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dmSET: bool> VdivF64Builder<ddSET, false, dmSET> {
        pub fn set_dn(mut self, dn: F64Register) -> VdivF64Builder<ddSET, true, dmSET> {
            self.dn = Some(dn);
            VdivF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dnSET: bool> VdivF64Builder<ddSET, dnSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VdivF64Builder<ddSET, dnSET, true> {
            self.dm = Some(dm);
            VdivF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VdivF64Builder<false, false, false> {
        pub fn new() -> VdivF64Builder<false, false, false> {
            VdivF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VdivF64 {
        pub fn builder() -> VdivF64Builder<false, false, false> {
            VdivF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VdivF64Builder<true, true, true> {
        pub fn complete(self) -> VdivF64 {
            VdivF64 {
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VdivF64Consumer<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VdivF64Consumer<false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (Option<F64Register>, VdivF64Consumer<true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VdivF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VdivF64Consumer<ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VdivF64Consumer<ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VdivF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VdivF64Consumer<ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VdivF64Consumer<ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VdivF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VdivF64 {
        pub fn consumer(self) -> VdivF64Consumer<false, false, false> {
            VdivF64Consumer {
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VdivF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VdivF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VdivF64",
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VdivF64 {
        #[inline]
        fn clone(&self) -> VdivF64 {
            VdivF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VdivF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VdivF64 {
        #[inline]
        fn eq(&self, other: &VdivF64) -> bool {
            self.dd == other.dd && self.dn == other.dn && self.dm == other.dm
        }
    }
    impl From<VdivF64> for Operation {
        fn from(val: VdivF64) -> Operation {
            Operation::VdivF64(val)
        }
    }
    pub struct VmaxF32 {
        pub sd: Option<F32Register>,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VmaxF32Builder<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const snSET: bool, const smSET: bool> VmaxF32Builder<false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: Option<F32Register>,
        ) -> VmaxF32Builder<true, snSET, smSET> {
            self.sd = Some(sd);
            VmaxF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const smSET: bool> VmaxF32Builder<sdSET, false, smSET> {
        pub fn set_sn(mut self, sn: F32Register) -> VmaxF32Builder<sdSET, true, smSET> {
            self.sn = Some(sn);
            VmaxF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const snSET: bool> VmaxF32Builder<sdSET, snSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VmaxF32Builder<sdSET, snSET, true> {
            self.sm = Some(sm);
            VmaxF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VmaxF32Builder<false, false, false> {
        pub fn new() -> VmaxF32Builder<false, false, false> {
            VmaxF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VmaxF32 {
        pub fn builder() -> VmaxF32Builder<false, false, false> {
            VmaxF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VmaxF32Builder<true, true, true> {
        pub fn complete(self) -> VmaxF32 {
            VmaxF32 {
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VmaxF32Consumer<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VmaxF32Consumer<false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (Option<F32Register>, VmaxF32Consumer<true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VmaxF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VmaxF32Consumer<sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VmaxF32Consumer<sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VmaxF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VmaxF32Consumer<sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VmaxF32Consumer<sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VmaxF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VmaxF32 {
        pub fn consumer(self) -> VmaxF32Consumer<false, false, false> {
            VmaxF32Consumer {
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VmaxF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmaxF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VmaxF32",
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmaxF32 {
        #[inline]
        fn clone(&self) -> VmaxF32 {
            VmaxF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmaxF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmaxF32 {
        #[inline]
        fn eq(&self, other: &VmaxF32) -> bool {
            self.sd == other.sd && self.sn == other.sn && self.sm == other.sm
        }
    }
    impl From<VmaxF32> for Operation {
        fn from(val: VmaxF32) -> Operation {
            Operation::VmaxF32(val)
        }
    }
    pub struct VmaxF64 {
        pub dd: Option<F64Register>,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VmaxF64Builder<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dnSET: bool, const dmSET: bool> VmaxF64Builder<false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: Option<F64Register>,
        ) -> VmaxF64Builder<true, dnSET, dmSET> {
            self.dd = Some(dd);
            VmaxF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dmSET: bool> VmaxF64Builder<ddSET, false, dmSET> {
        pub fn set_dn(mut self, dn: F64Register) -> VmaxF64Builder<ddSET, true, dmSET> {
            self.dn = Some(dn);
            VmaxF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dnSET: bool> VmaxF64Builder<ddSET, dnSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VmaxF64Builder<ddSET, dnSET, true> {
            self.dm = Some(dm);
            VmaxF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VmaxF64Builder<false, false, false> {
        pub fn new() -> VmaxF64Builder<false, false, false> {
            VmaxF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VmaxF64 {
        pub fn builder() -> VmaxF64Builder<false, false, false> {
            VmaxF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VmaxF64Builder<true, true, true> {
        pub fn complete(self) -> VmaxF64 {
            VmaxF64 {
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VmaxF64Consumer<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VmaxF64Consumer<false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (Option<F64Register>, VmaxF64Consumer<true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VmaxF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VmaxF64Consumer<ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VmaxF64Consumer<ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VmaxF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VmaxF64Consumer<ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VmaxF64Consumer<ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VmaxF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VmaxF64 {
        pub fn consumer(self) -> VmaxF64Consumer<false, false, false> {
            VmaxF64Consumer {
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VmaxF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmaxF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VmaxF64",
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmaxF64 {
        #[inline]
        fn clone(&self) -> VmaxF64 {
            VmaxF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmaxF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmaxF64 {
        #[inline]
        fn eq(&self, other: &VmaxF64) -> bool {
            self.dd == other.dd && self.dn == other.dn && self.dm == other.dm
        }
    }
    impl From<VmaxF64> for Operation {
        fn from(val: VmaxF64) -> Operation {
            Operation::VmaxF64(val)
        }
    }
    pub struct VminF32 {
        pub sd: Option<F32Register>,
        pub sn: F32Register,
        pub sm: F32Register,
    }
    pub struct VminF32Builder<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const snSET: bool, const smSET: bool> VminF32Builder<false, snSET, smSET> {
        pub fn set_sd(
            mut self,
            sd: Option<F32Register>,
        ) -> VminF32Builder<true, snSET, smSET> {
            self.sd = Some(sd);
            VminF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const smSET: bool> VminF32Builder<sdSET, false, smSET> {
        pub fn set_sn(mut self, sn: F32Register) -> VminF32Builder<sdSET, true, smSET> {
            self.sn = Some(sn);
            VminF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool, const snSET: bool> VminF32Builder<sdSET, snSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VminF32Builder<sdSET, snSET, true> {
            self.sm = Some(sm);
            VminF32Builder {
                sd: self.sd,
                sn: self.sn,
                sm: self.sm,
            }
        }
    }
    impl VminF32Builder<false, false, false> {
        pub fn new() -> VminF32Builder<false, false, false> {
            VminF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VminF32 {
        pub fn builder() -> VminF32Builder<false, false, false> {
            VminF32Builder {
                sd: None,
                sn: None,
                sm: None,
            }
        }
    }
    impl VminF32Builder<true, true, true> {
        pub fn complete(self) -> VminF32 {
            VminF32 {
                sd: self.sd.unwrap(),
                sn: self.sn.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VminF32Consumer<const sdSET: bool, const snSET: bool, const smSET: bool> {
        sd: Option<Option<F32Register>>,
        sn: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const snCONSUMED: bool,
        const smCONSUMED: bool,
    > VminF32Consumer<false, snCONSUMED, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (Option<F32Register>, VminF32Consumer<true, snCONSUMED, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VminF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VminF32Consumer<sdCONSUMED, false, smCONSUMED> {
        pub fn consume_sn(
            mut self,
        ) -> (F32Register, VminF32Consumer<sdCONSUMED, true, smCONSUMED>) {
            let ret = self.sn.unwrap();
            self.sn = None;
            (
                ret,
                VminF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const sdCONSUMED: bool,
        const snCONSUMED: bool,
    > VminF32Consumer<sdCONSUMED, snCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VminF32Consumer<sdCONSUMED, snCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VminF32Consumer {
                    sd: self.sd,
                    sn: self.sn,
                    sm: self.sm,
                },
            )
        }
    }
    impl VminF32 {
        pub fn consumer(self) -> VminF32Consumer<false, false, false> {
            VminF32Consumer {
                sd: Some(self.sd),
                sn: Some(self.sn),
                sm: Some(self.sm),
            }
        }
    }
    impl VminF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VminF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VminF32",
                "sd",
                &self.sd,
                "sn",
                &self.sn,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VminF32 {
        #[inline]
        fn clone(&self) -> VminF32 {
            VminF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sn: ::core::clone::Clone::clone(&self.sn),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VminF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VminF32 {
        #[inline]
        fn eq(&self, other: &VminF32) -> bool {
            self.sd == other.sd && self.sn == other.sn && self.sm == other.sm
        }
    }
    impl From<VminF32> for Operation {
        fn from(val: VminF32) -> Operation {
            Operation::VminF32(val)
        }
    }
    pub struct VminF64 {
        pub dd: Option<F64Register>,
        pub dn: F64Register,
        pub dm: F64Register,
    }
    pub struct VminF64Builder<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dnSET: bool, const dmSET: bool> VminF64Builder<false, dnSET, dmSET> {
        pub fn set_dd(
            mut self,
            dd: Option<F64Register>,
        ) -> VminF64Builder<true, dnSET, dmSET> {
            self.dd = Some(dd);
            VminF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dmSET: bool> VminF64Builder<ddSET, false, dmSET> {
        pub fn set_dn(mut self, dn: F64Register) -> VminF64Builder<ddSET, true, dmSET> {
            self.dn = Some(dn);
            VminF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool, const dnSET: bool> VminF64Builder<ddSET, dnSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VminF64Builder<ddSET, dnSET, true> {
            self.dm = Some(dm);
            VminF64Builder {
                dd: self.dd,
                dn: self.dn,
                dm: self.dm,
            }
        }
    }
    impl VminF64Builder<false, false, false> {
        pub fn new() -> VminF64Builder<false, false, false> {
            VminF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VminF64 {
        pub fn builder() -> VminF64Builder<false, false, false> {
            VminF64Builder {
                dd: None,
                dn: None,
                dm: None,
            }
        }
    }
    impl VminF64Builder<true, true, true> {
        pub fn complete(self) -> VminF64 {
            VminF64 {
                dd: self.dd.unwrap(),
                dn: self.dn.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VminF64Consumer<const ddSET: bool, const dnSET: bool, const dmSET: bool> {
        dd: Option<Option<F64Register>>,
        dn: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const dnCONSUMED: bool,
        const dmCONSUMED: bool,
    > VminF64Consumer<false, dnCONSUMED, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (Option<F64Register>, VminF64Consumer<true, dnCONSUMED, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VminF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VminF64Consumer<ddCONSUMED, false, dmCONSUMED> {
        pub fn consume_dn(
            mut self,
        ) -> (F64Register, VminF64Consumer<ddCONSUMED, true, dmCONSUMED>) {
            let ret = self.dn.unwrap();
            self.dn = None;
            (
                ret,
                VminF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const ddCONSUMED: bool,
        const dnCONSUMED: bool,
    > VminF64Consumer<ddCONSUMED, dnCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VminF64Consumer<ddCONSUMED, dnCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VminF64Consumer {
                    dd: self.dd,
                    dn: self.dn,
                    dm: self.dm,
                },
            )
        }
    }
    impl VminF64 {
        pub fn consumer(self) -> VminF64Consumer<false, false, false> {
            VminF64Consumer {
                dd: Some(self.dd),
                dn: Some(self.dn),
                dm: Some(self.dm),
            }
        }
    }
    impl VminF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VminF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VminF64",
                "dd",
                &self.dd,
                "dn",
                &self.dn,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VminF64 {
        #[inline]
        fn clone(&self) -> VminF64 {
            VminF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dn: ::core::clone::Clone::clone(&self.dn),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VminF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VminF64 {
        #[inline]
        fn eq(&self, other: &VminF64) -> bool {
            self.dd == other.dd && self.dn == other.dn && self.dm == other.dm
        }
    }
    impl From<VminF64> for Operation {
        fn from(val: VminF64) -> Operation {
            Operation::VminF64(val)
        }
    }
    pub struct VmovImmediateF32 {
        pub sd: F32Register,
        pub imm: u32,
    }
    pub struct VmovImmediateF32Builder<const sdSET: bool, const immSET: bool> {
        sd: Option<F32Register>,
        imm: Option<u32>,
    }
    impl<const immSET: bool> VmovImmediateF32Builder<false, immSET> {
        pub fn set_sd(
            mut self,
            sd: F32Register,
        ) -> VmovImmediateF32Builder<true, immSET> {
            self.sd = Some(sd);
            VmovImmediateF32Builder {
                sd: self.sd,
                imm: self.imm,
            }
        }
    }
    impl<const sdSET: bool> VmovImmediateF32Builder<sdSET, false> {
        pub fn set_imm(mut self, imm: u32) -> VmovImmediateF32Builder<sdSET, true> {
            self.imm = Some(imm);
            VmovImmediateF32Builder {
                sd: self.sd,
                imm: self.imm,
            }
        }
    }
    impl VmovImmediateF32Builder<false, false> {
        pub fn new() -> VmovImmediateF32Builder<false, false> {
            VmovImmediateF32Builder {
                sd: None,
                imm: None,
            }
        }
    }
    impl VmovImmediateF32 {
        pub fn builder() -> VmovImmediateF32Builder<false, false> {
            VmovImmediateF32Builder {
                sd: None,
                imm: None,
            }
        }
    }
    impl VmovImmediateF32Builder<true, true> {
        pub fn complete(self) -> VmovImmediateF32 {
            VmovImmediateF32 {
                sd: self.sd.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct VmovImmediateF32Consumer<const sdSET: bool, const immSET: bool> {
        sd: Option<F32Register>,
        imm: Option<u32>,
    }
    impl<const immCONSUMED: bool> VmovImmediateF32Consumer<false, immCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VmovImmediateF32Consumer<true, immCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VmovImmediateF32Consumer {
                    sd: self.sd,
                    imm: self.imm,
                },
            )
        }
    }
    impl<const sdCONSUMED: bool> VmovImmediateF32Consumer<sdCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, VmovImmediateF32Consumer<sdCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                VmovImmediateF32Consumer {
                    sd: self.sd,
                    imm: self.imm,
                },
            )
        }
    }
    impl VmovImmediateF32 {
        pub fn consumer(self) -> VmovImmediateF32Consumer<false, false> {
            VmovImmediateF32Consumer {
                sd: Some(self.sd),
                imm: Some(self.imm),
            }
        }
    }
    impl VmovImmediateF32Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmovImmediateF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VmovImmediateF32",
                "sd",
                &self.sd,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmovImmediateF32 {
        #[inline]
        fn clone(&self) -> VmovImmediateF32 {
            VmovImmediateF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmovImmediateF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmovImmediateF32 {
        #[inline]
        fn eq(&self, other: &VmovImmediateF32) -> bool {
            self.sd == other.sd && self.imm == other.imm
        }
    }
    impl From<VmovImmediateF32> for Operation {
        fn from(val: VmovImmediateF32) -> Operation {
            Operation::VmovImmediateF32(val)
        }
    }
    pub struct VmovImmediateF64 {
        pub dd: F64Register,
        pub imm: u32,
    }
    pub struct VmovImmediateF64Builder<const ddSET: bool, const immSET: bool> {
        dd: Option<F64Register>,
        imm: Option<u32>,
    }
    impl<const immSET: bool> VmovImmediateF64Builder<false, immSET> {
        pub fn set_dd(
            mut self,
            dd: F64Register,
        ) -> VmovImmediateF64Builder<true, immSET> {
            self.dd = Some(dd);
            VmovImmediateF64Builder {
                dd: self.dd,
                imm: self.imm,
            }
        }
    }
    impl<const ddSET: bool> VmovImmediateF64Builder<ddSET, false> {
        pub fn set_imm(mut self, imm: u32) -> VmovImmediateF64Builder<ddSET, true> {
            self.imm = Some(imm);
            VmovImmediateF64Builder {
                dd: self.dd,
                imm: self.imm,
            }
        }
    }
    impl VmovImmediateF64Builder<false, false> {
        pub fn new() -> VmovImmediateF64Builder<false, false> {
            VmovImmediateF64Builder {
                dd: None,
                imm: None,
            }
        }
    }
    impl VmovImmediateF64 {
        pub fn builder() -> VmovImmediateF64Builder<false, false> {
            VmovImmediateF64Builder {
                dd: None,
                imm: None,
            }
        }
    }
    impl VmovImmediateF64Builder<true, true> {
        pub fn complete(self) -> VmovImmediateF64 {
            VmovImmediateF64 {
                dd: self.dd.unwrap(),
                imm: self.imm.unwrap(),
            }
        }
    }
    pub struct VmovImmediateF64Consumer<const ddSET: bool, const immSET: bool> {
        dd: Option<F64Register>,
        imm: Option<u32>,
    }
    impl<const immCONSUMED: bool> VmovImmediateF64Consumer<false, immCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VmovImmediateF64Consumer<true, immCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VmovImmediateF64Consumer {
                    dd: self.dd,
                    imm: self.imm,
                },
            )
        }
    }
    impl<const ddCONSUMED: bool> VmovImmediateF64Consumer<ddCONSUMED, false> {
        pub fn consume_imm(
            mut self,
        ) -> (u32, VmovImmediateF64Consumer<ddCONSUMED, true>) {
            let ret = self.imm.unwrap();
            self.imm = None;
            (
                ret,
                VmovImmediateF64Consumer {
                    dd: self.dd,
                    imm: self.imm,
                },
            )
        }
    }
    impl VmovImmediateF64 {
        pub fn consumer(self) -> VmovImmediateF64Consumer<false, false> {
            VmovImmediateF64Consumer {
                dd: Some(self.dd),
                imm: Some(self.imm),
            }
        }
    }
    impl VmovImmediateF64Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmovImmediateF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VmovImmediateF64",
                "dd",
                &self.dd,
                "imm",
                &&self.imm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmovImmediateF64 {
        #[inline]
        fn clone(&self) -> VmovImmediateF64 {
            VmovImmediateF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                imm: ::core::clone::Clone::clone(&self.imm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmovImmediateF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmovImmediateF64 {
        #[inline]
        fn eq(&self, other: &VmovImmediateF64) -> bool {
            self.dd == other.dd && self.imm == other.imm
        }
    }
    impl From<VmovImmediateF64> for Operation {
        fn from(val: VmovImmediateF64) -> Operation {
            Operation::VmovImmediateF64(val)
        }
    }
    pub struct VmovRegisterF32 {
        pub sd: F32Register,
        pub dm: u32,
    }
    pub struct VmovRegisterF32Builder<const sdSET: bool, const dmSET: bool> {
        sd: Option<F32Register>,
        dm: Option<u32>,
    }
    impl<const dmSET: bool> VmovRegisterF32Builder<false, dmSET> {
        pub fn set_sd(mut self, sd: F32Register) -> VmovRegisterF32Builder<true, dmSET> {
            self.sd = Some(sd);
            VmovRegisterF32Builder {
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl<const sdSET: bool> VmovRegisterF32Builder<sdSET, false> {
        pub fn set_dm(mut self, dm: u32) -> VmovRegisterF32Builder<sdSET, true> {
            self.dm = Some(dm);
            VmovRegisterF32Builder {
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl VmovRegisterF32Builder<false, false> {
        pub fn new() -> VmovRegisterF32Builder<false, false> {
            VmovRegisterF32Builder {
                sd: None,
                dm: None,
            }
        }
    }
    impl VmovRegisterF32 {
        pub fn builder() -> VmovRegisterF32Builder<false, false> {
            VmovRegisterF32Builder {
                sd: None,
                dm: None,
            }
        }
    }
    impl VmovRegisterF32Builder<true, true> {
        pub fn complete(self) -> VmovRegisterF32 {
            VmovRegisterF32 {
                sd: self.sd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VmovRegisterF32Consumer<const sdSET: bool, const dmSET: bool> {
        sd: Option<F32Register>,
        dm: Option<u32>,
    }
    impl<const dmCONSUMED: bool> VmovRegisterF32Consumer<false, dmCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VmovRegisterF32Consumer<true, dmCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VmovRegisterF32Consumer {
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<const sdCONSUMED: bool> VmovRegisterF32Consumer<sdCONSUMED, false> {
        pub fn consume_dm(mut self) -> (u32, VmovRegisterF32Consumer<sdCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VmovRegisterF32Consumer {
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VmovRegisterF32 {
        pub fn consumer(self) -> VmovRegisterF32Consumer<false, false> {
            VmovRegisterF32Consumer {
                sd: Some(self.sd),
                dm: Some(self.dm),
            }
        }
    }
    impl VmovRegisterF32Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmovRegisterF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VmovRegisterF32",
                "sd",
                &self.sd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmovRegisterF32 {
        #[inline]
        fn clone(&self) -> VmovRegisterF32 {
            VmovRegisterF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmovRegisterF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmovRegisterF32 {
        #[inline]
        fn eq(&self, other: &VmovRegisterF32) -> bool {
            self.sd == other.sd && self.dm == other.dm
        }
    }
    impl From<VmovRegisterF32> for Operation {
        fn from(val: VmovRegisterF32) -> Operation {
            Operation::VmovRegisterF32(val)
        }
    }
    pub struct VmovRegisterF64 {
        pub dd: F64Register,
        pub dm: u32,
    }
    pub struct VmovRegisterF64Builder<const ddSET: bool, const dmSET: bool> {
        dd: Option<F64Register>,
        dm: Option<u32>,
    }
    impl<const dmSET: bool> VmovRegisterF64Builder<false, dmSET> {
        pub fn set_dd(mut self, dd: F64Register) -> VmovRegisterF64Builder<true, dmSET> {
            self.dd = Some(dd);
            VmovRegisterF64Builder {
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool> VmovRegisterF64Builder<ddSET, false> {
        pub fn set_dm(mut self, dm: u32) -> VmovRegisterF64Builder<ddSET, true> {
            self.dm = Some(dm);
            VmovRegisterF64Builder {
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl VmovRegisterF64Builder<false, false> {
        pub fn new() -> VmovRegisterF64Builder<false, false> {
            VmovRegisterF64Builder {
                dd: None,
                dm: None,
            }
        }
    }
    impl VmovRegisterF64 {
        pub fn builder() -> VmovRegisterF64Builder<false, false> {
            VmovRegisterF64Builder {
                dd: None,
                dm: None,
            }
        }
    }
    impl VmovRegisterF64Builder<true, true> {
        pub fn complete(self) -> VmovRegisterF64 {
            VmovRegisterF64 {
                dd: self.dd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VmovRegisterF64Consumer<const ddSET: bool, const dmSET: bool> {
        dd: Option<F64Register>,
        dm: Option<u32>,
    }
    impl<const dmCONSUMED: bool> VmovRegisterF64Consumer<false, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VmovRegisterF64Consumer<true, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VmovRegisterF64Consumer {
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<const ddCONSUMED: bool> VmovRegisterF64Consumer<ddCONSUMED, false> {
        pub fn consume_dm(mut self) -> (u32, VmovRegisterF64Consumer<ddCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VmovRegisterF64Consumer {
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VmovRegisterF64 {
        pub fn consumer(self) -> VmovRegisterF64Consumer<false, false> {
            VmovRegisterF64Consumer {
                dd: Some(self.dd),
                dm: Some(self.dm),
            }
        }
    }
    impl VmovRegisterF64Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VmovRegisterF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VmovRegisterF64",
                "dd",
                &self.dd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VmovRegisterF64 {
        #[inline]
        fn clone(&self) -> VmovRegisterF64 {
            VmovRegisterF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VmovRegisterF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VmovRegisterF64 {
        #[inline]
        fn eq(&self, other: &VmovRegisterF64) -> bool {
            self.dd == other.dd && self.dm == other.dm
        }
    }
    impl From<VmovRegisterF64> for Operation {
        fn from(val: VmovRegisterF64) -> Operation {
            Operation::VmovRegisterF64(val)
        }
    }
    pub struct VabsF32 {
        pub sd: F32Register,
        pub sm: F32Register,
    }
    pub struct VabsF32Builder<const sdSET: bool, const smSET: bool> {
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const smSET: bool> VabsF32Builder<false, smSET> {
        pub fn set_sd(mut self, sd: F32Register) -> VabsF32Builder<true, smSET> {
            self.sd = Some(sd);
            VabsF32Builder {
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool> VabsF32Builder<sdSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VabsF32Builder<sdSET, true> {
            self.sm = Some(sm);
            VabsF32Builder {
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl VabsF32Builder<false, false> {
        pub fn new() -> VabsF32Builder<false, false> {
            VabsF32Builder {
                sd: None,
                sm: None,
            }
        }
    }
    impl VabsF32 {
        pub fn builder() -> VabsF32Builder<false, false> {
            VabsF32Builder {
                sd: None,
                sm: None,
            }
        }
    }
    impl VabsF32Builder<true, true> {
        pub fn complete(self) -> VabsF32 {
            VabsF32 {
                sd: self.sd.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VabsF32Consumer<const sdSET: bool, const smSET: bool> {
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const smCONSUMED: bool> VabsF32Consumer<false, smCONSUMED> {
        pub fn consume_sd(mut self) -> (F32Register, VabsF32Consumer<true, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VabsF32Consumer {
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<const sdCONSUMED: bool> VabsF32Consumer<sdCONSUMED, false> {
        pub fn consume_sm(mut self) -> (F32Register, VabsF32Consumer<sdCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VabsF32Consumer {
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl VabsF32 {
        pub fn consumer(self) -> VabsF32Consumer<false, false> {
            VabsF32Consumer {
                sd: Some(self.sd),
                sm: Some(self.sm),
            }
        }
    }
    impl VabsF32Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VabsF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VabsF32",
                "sd",
                &self.sd,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VabsF32 {
        #[inline]
        fn clone(&self) -> VabsF32 {
            VabsF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VabsF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VabsF32 {
        #[inline]
        fn eq(&self, other: &VabsF32) -> bool {
            self.sd == other.sd && self.sm == other.sm
        }
    }
    impl From<VabsF32> for Operation {
        fn from(val: VabsF32) -> Operation {
            Operation::VabsF32(val)
        }
    }
    pub struct VabsF64 {
        pub dd: F64Register,
        pub dm: F64Register,
    }
    pub struct VabsF64Builder<const ddSET: bool, const dmSET: bool> {
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dmSET: bool> VabsF64Builder<false, dmSET> {
        pub fn set_dd(mut self, dd: F64Register) -> VabsF64Builder<true, dmSET> {
            self.dd = Some(dd);
            VabsF64Builder {
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool> VabsF64Builder<ddSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VabsF64Builder<ddSET, true> {
            self.dm = Some(dm);
            VabsF64Builder {
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl VabsF64Builder<false, false> {
        pub fn new() -> VabsF64Builder<false, false> {
            VabsF64Builder {
                dd: None,
                dm: None,
            }
        }
    }
    impl VabsF64 {
        pub fn builder() -> VabsF64Builder<false, false> {
            VabsF64Builder {
                dd: None,
                dm: None,
            }
        }
    }
    impl VabsF64Builder<true, true> {
        pub fn complete(self) -> VabsF64 {
            VabsF64 {
                dd: self.dd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VabsF64Consumer<const ddSET: bool, const dmSET: bool> {
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dmCONSUMED: bool> VabsF64Consumer<false, dmCONSUMED> {
        pub fn consume_dd(mut self) -> (F64Register, VabsF64Consumer<true, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VabsF64Consumer {
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<const ddCONSUMED: bool> VabsF64Consumer<ddCONSUMED, false> {
        pub fn consume_dm(mut self) -> (F64Register, VabsF64Consumer<ddCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VabsF64Consumer {
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VabsF64 {
        pub fn consumer(self) -> VabsF64Consumer<false, false> {
            VabsF64Consumer {
                dd: Some(self.dd),
                dm: Some(self.dm),
            }
        }
    }
    impl VabsF64Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VabsF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VabsF64",
                "dd",
                &self.dd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VabsF64 {
        #[inline]
        fn clone(&self) -> VabsF64 {
            VabsF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VabsF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VabsF64 {
        #[inline]
        fn eq(&self, other: &VabsF64) -> bool {
            self.dd == other.dd && self.dm == other.dm
        }
    }
    impl From<VabsF64> for Operation {
        fn from(val: VabsF64) -> Operation {
            Operation::VabsF64(val)
        }
    }
    pub struct VnegF32 {
        pub sd: F32Register,
        pub sm: F32Register,
    }
    pub struct VnegF32Builder<const sdSET: bool, const smSET: bool> {
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const smSET: bool> VnegF32Builder<false, smSET> {
        pub fn set_sd(mut self, sd: F32Register) -> VnegF32Builder<true, smSET> {
            self.sd = Some(sd);
            VnegF32Builder {
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool> VnegF32Builder<sdSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VnegF32Builder<sdSET, true> {
            self.sm = Some(sm);
            VnegF32Builder {
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl VnegF32Builder<false, false> {
        pub fn new() -> VnegF32Builder<false, false> {
            VnegF32Builder {
                sd: None,
                sm: None,
            }
        }
    }
    impl VnegF32 {
        pub fn builder() -> VnegF32Builder<false, false> {
            VnegF32Builder {
                sd: None,
                sm: None,
            }
        }
    }
    impl VnegF32Builder<true, true> {
        pub fn complete(self) -> VnegF32 {
            VnegF32 {
                sd: self.sd.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VnegF32Consumer<const sdSET: bool, const smSET: bool> {
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const smCONSUMED: bool> VnegF32Consumer<false, smCONSUMED> {
        pub fn consume_sd(mut self) -> (F32Register, VnegF32Consumer<true, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VnegF32Consumer {
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<const sdCONSUMED: bool> VnegF32Consumer<sdCONSUMED, false> {
        pub fn consume_sm(mut self) -> (F32Register, VnegF32Consumer<sdCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VnegF32Consumer {
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl VnegF32 {
        pub fn consumer(self) -> VnegF32Consumer<false, false> {
            VnegF32Consumer {
                sd: Some(self.sd),
                sm: Some(self.sm),
            }
        }
    }
    impl VnegF32Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VnegF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VnegF32",
                "sd",
                &self.sd,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VnegF32 {
        #[inline]
        fn clone(&self) -> VnegF32 {
            VnegF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VnegF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VnegF32 {
        #[inline]
        fn eq(&self, other: &VnegF32) -> bool {
            self.sd == other.sd && self.sm == other.sm
        }
    }
    impl From<VnegF32> for Operation {
        fn from(val: VnegF32) -> Operation {
            Operation::VnegF32(val)
        }
    }
    pub struct VnegF64 {
        pub dd: F64Register,
        pub dm: F64Register,
    }
    pub struct VnegF64Builder<const ddSET: bool, const dmSET: bool> {
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dmSET: bool> VnegF64Builder<false, dmSET> {
        pub fn set_dd(mut self, dd: F64Register) -> VnegF64Builder<true, dmSET> {
            self.dd = Some(dd);
            VnegF64Builder {
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool> VnegF64Builder<ddSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VnegF64Builder<ddSET, true> {
            self.dm = Some(dm);
            VnegF64Builder {
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl VnegF64Builder<false, false> {
        pub fn new() -> VnegF64Builder<false, false> {
            VnegF64Builder {
                dd: None,
                dm: None,
            }
        }
    }
    impl VnegF64 {
        pub fn builder() -> VnegF64Builder<false, false> {
            VnegF64Builder {
                dd: None,
                dm: None,
            }
        }
    }
    impl VnegF64Builder<true, true> {
        pub fn complete(self) -> VnegF64 {
            VnegF64 {
                dd: self.dd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VnegF64Consumer<const ddSET: bool, const dmSET: bool> {
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dmCONSUMED: bool> VnegF64Consumer<false, dmCONSUMED> {
        pub fn consume_dd(mut self) -> (F64Register, VnegF64Consumer<true, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VnegF64Consumer {
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<const ddCONSUMED: bool> VnegF64Consumer<ddCONSUMED, false> {
        pub fn consume_dm(mut self) -> (F64Register, VnegF64Consumer<ddCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VnegF64Consumer {
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VnegF64 {
        pub fn consumer(self) -> VnegF64Consumer<false, false> {
            VnegF64Consumer {
                dd: Some(self.dd),
                dm: Some(self.dm),
            }
        }
    }
    impl VnegF64Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VnegF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VnegF64",
                "dd",
                &self.dd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VnegF64 {
        #[inline]
        fn clone(&self) -> VnegF64 {
            VnegF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VnegF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VnegF64 {
        #[inline]
        fn eq(&self, other: &VnegF64) -> bool {
            self.dd == other.dd && self.dm == other.dm
        }
    }
    impl From<VnegF64> for Operation {
        fn from(val: VnegF64) -> Operation {
            Operation::VnegF64(val)
        }
    }
    pub struct VsqrtF32 {
        pub sd: F32Register,
        pub sm: F32Register,
    }
    pub struct VsqrtF32Builder<const sdSET: bool, const smSET: bool> {
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const smSET: bool> VsqrtF32Builder<false, smSET> {
        pub fn set_sd(mut self, sd: F32Register) -> VsqrtF32Builder<true, smSET> {
            self.sd = Some(sd);
            VsqrtF32Builder {
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl<const sdSET: bool> VsqrtF32Builder<sdSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VsqrtF32Builder<sdSET, true> {
            self.sm = Some(sm);
            VsqrtF32Builder {
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl VsqrtF32Builder<false, false> {
        pub fn new() -> VsqrtF32Builder<false, false> {
            VsqrtF32Builder {
                sd: None,
                sm: None,
            }
        }
    }
    impl VsqrtF32 {
        pub fn builder() -> VsqrtF32Builder<false, false> {
            VsqrtF32Builder {
                sd: None,
                sm: None,
            }
        }
    }
    impl VsqrtF32Builder<true, true> {
        pub fn complete(self) -> VsqrtF32 {
            VsqrtF32 {
                sd: self.sd.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VsqrtF32Consumer<const sdSET: bool, const smSET: bool> {
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const smCONSUMED: bool> VsqrtF32Consumer<false, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VsqrtF32Consumer<true, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VsqrtF32Consumer {
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<const sdCONSUMED: bool> VsqrtF32Consumer<sdCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VsqrtF32Consumer<sdCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VsqrtF32Consumer {
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl VsqrtF32 {
        pub fn consumer(self) -> VsqrtF32Consumer<false, false> {
            VsqrtF32Consumer {
                sd: Some(self.sd),
                sm: Some(self.sm),
            }
        }
    }
    impl VsqrtF32Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VsqrtF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VsqrtF32",
                "sd",
                &self.sd,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VsqrtF32 {
        #[inline]
        fn clone(&self) -> VsqrtF32 {
            VsqrtF32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VsqrtF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VsqrtF32 {
        #[inline]
        fn eq(&self, other: &VsqrtF32) -> bool {
            self.sd == other.sd && self.sm == other.sm
        }
    }
    impl From<VsqrtF32> for Operation {
        fn from(val: VsqrtF32) -> Operation {
            Operation::VsqrtF32(val)
        }
    }
    pub struct VsqrtF64 {
        pub dd: F64Register,
        pub dm: F64Register,
    }
    pub struct VsqrtF64Builder<const ddSET: bool, const dmSET: bool> {
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dmSET: bool> VsqrtF64Builder<false, dmSET> {
        pub fn set_dd(mut self, dd: F64Register) -> VsqrtF64Builder<true, dmSET> {
            self.dd = Some(dd);
            VsqrtF64Builder {
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<const ddSET: bool> VsqrtF64Builder<ddSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VsqrtF64Builder<ddSET, true> {
            self.dm = Some(dm);
            VsqrtF64Builder {
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl VsqrtF64Builder<false, false> {
        pub fn new() -> VsqrtF64Builder<false, false> {
            VsqrtF64Builder {
                dd: None,
                dm: None,
            }
        }
    }
    impl VsqrtF64 {
        pub fn builder() -> VsqrtF64Builder<false, false> {
            VsqrtF64Builder {
                dd: None,
                dm: None,
            }
        }
    }
    impl VsqrtF64Builder<true, true> {
        pub fn complete(self) -> VsqrtF64 {
            VsqrtF64 {
                dd: self.dd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VsqrtF64Consumer<const ddSET: bool, const dmSET: bool> {
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const dmCONSUMED: bool> VsqrtF64Consumer<false, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VsqrtF64Consumer<true, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VsqrtF64Consumer {
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<const ddCONSUMED: bool> VsqrtF64Consumer<ddCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VsqrtF64Consumer<ddCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VsqrtF64Consumer {
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VsqrtF64 {
        pub fn consumer(self) -> VsqrtF64Consumer<false, false> {
            VsqrtF64Consumer {
                dd: Some(self.dd),
                dm: Some(self.dm),
            }
        }
    }
    impl VsqrtF64Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VsqrtF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VsqrtF64",
                "dd",
                &self.dd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VsqrtF64 {
        #[inline]
        fn clone(&self) -> VsqrtF64 {
            VsqrtF64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VsqrtF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VsqrtF64 {
        #[inline]
        fn eq(&self, other: &VsqrtF64) -> bool {
            self.dd == other.dd && self.dm == other.dm
        }
    }
    impl From<VsqrtF64> for Operation {
        fn from(val: VsqrtF64) -> Operation {
            Operation::VsqrtF64(val)
        }
    }
    pub struct VcvtF32 {
        pub y: bool,
        pub sd: F32Register,
        pub sm: F32Register,
    }
    pub struct VcvtF32Builder<const ySET: bool, const sdSET: bool, const smSET: bool> {
        y: Option<bool>,
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<const sdSET: bool, const smSET: bool> VcvtF32Builder<false, sdSET, smSET> {
        pub fn set_y(mut self, y: bool) -> VcvtF32Builder<true, sdSET, smSET> {
            self.y = Some(y);
            VcvtF32Builder {
                y: self.y,
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl<const ySET: bool, const smSET: bool> VcvtF32Builder<ySET, false, smSET> {
        pub fn set_sd(mut self, sd: F32Register) -> VcvtF32Builder<ySET, true, smSET> {
            self.sd = Some(sd);
            VcvtF32Builder {
                y: self.y,
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl<const ySET: bool, const sdSET: bool> VcvtF32Builder<ySET, sdSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VcvtF32Builder<ySET, sdSET, true> {
            self.sm = Some(sm);
            VcvtF32Builder {
                y: self.y,
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl VcvtF32Builder<false, false, false> {
        pub fn new() -> VcvtF32Builder<false, false, false> {
            VcvtF32Builder {
                y: None,
                sd: None,
                sm: None,
            }
        }
    }
    impl VcvtF32 {
        pub fn builder() -> VcvtF32Builder<false, false, false> {
            VcvtF32Builder {
                y: None,
                sd: None,
                sm: None,
            }
        }
    }
    impl VcvtF32Builder<true, true, true> {
        pub fn complete(self) -> VcvtF32 {
            VcvtF32 {
                y: self.y.unwrap(),
                sd: self.sd.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VcvtF32Consumer<const ySET: bool, const sdSET: bool, const smSET: bool> {
        y: Option<bool>,
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VcvtF32Consumer<false, sdCONSUMED, smCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (bool, VcvtF32Consumer<true, sdCONSUMED, smCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VcvtF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const smCONSUMED: bool,
    > VcvtF32Consumer<yCONSUMED, false, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VcvtF32Consumer<yCONSUMED, true, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VcvtF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const sdCONSUMED: bool,
    > VcvtF32Consumer<yCONSUMED, sdCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VcvtF32Consumer<yCONSUMED, sdCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VcvtF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl VcvtF32 {
        pub fn consumer(self) -> VcvtF32Consumer<false, false, false> {
            VcvtF32Consumer {
                y: Some(self.y),
                sd: Some(self.sd),
                sm: Some(self.sm),
            }
        }
    }
    impl VcvtF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcvtF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VcvtF32",
                "y",
                &self.y,
                "sd",
                &self.sd,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcvtF32 {
        #[inline]
        fn clone(&self) -> VcvtF32 {
            VcvtF32 {
                y: ::core::clone::Clone::clone(&self.y),
                sd: ::core::clone::Clone::clone(&self.sd),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcvtF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcvtF32 {
        #[inline]
        fn eq(&self, other: &VcvtF32) -> bool {
            self.y == other.y && self.sd == other.sd && self.sm == other.sm
        }
    }
    impl From<VcvtF32> for Operation {
        fn from(val: VcvtF32) -> Operation {
            Operation::VcvtF32(val)
        }
    }
    pub struct VcvtF64 {
        pub y: bool,
        pub dd: F64Register,
        pub dm: F64Register,
    }
    pub struct VcvtF64Builder<const ySET: bool, const ddSET: bool, const dmSET: bool> {
        y: Option<bool>,
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const ddSET: bool, const dmSET: bool> VcvtF64Builder<false, ddSET, dmSET> {
        pub fn set_y(mut self, y: bool) -> VcvtF64Builder<true, ddSET, dmSET> {
            self.y = Some(y);
            VcvtF64Builder {
                y: self.y,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<const ySET: bool, const dmSET: bool> VcvtF64Builder<ySET, false, dmSET> {
        pub fn set_dd(mut self, dd: F64Register) -> VcvtF64Builder<ySET, true, dmSET> {
            self.dd = Some(dd);
            VcvtF64Builder {
                y: self.y,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<const ySET: bool, const ddSET: bool> VcvtF64Builder<ySET, ddSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VcvtF64Builder<ySET, ddSET, true> {
            self.dm = Some(dm);
            VcvtF64Builder {
                y: self.y,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl VcvtF64Builder<false, false, false> {
        pub fn new() -> VcvtF64Builder<false, false, false> {
            VcvtF64Builder {
                y: None,
                dd: None,
                dm: None,
            }
        }
    }
    impl VcvtF64 {
        pub fn builder() -> VcvtF64Builder<false, false, false> {
            VcvtF64Builder {
                y: None,
                dd: None,
                dm: None,
            }
        }
    }
    impl VcvtF64Builder<true, true, true> {
        pub fn complete(self) -> VcvtF64 {
            VcvtF64 {
                y: self.y.unwrap(),
                dd: self.dd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VcvtF64Consumer<const ySET: bool, const ddSET: bool, const dmSET: bool> {
        y: Option<bool>,
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VcvtF64Consumer<false, ddCONSUMED, dmCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (bool, VcvtF64Consumer<true, ddCONSUMED, dmCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VcvtF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const dmCONSUMED: bool,
    > VcvtF64Consumer<yCONSUMED, false, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VcvtF64Consumer<yCONSUMED, true, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VcvtF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const ddCONSUMED: bool,
    > VcvtF64Consumer<yCONSUMED, ddCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VcvtF64Consumer<yCONSUMED, ddCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VcvtF64Consumer {
                    y: self.y,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VcvtF64 {
        pub fn consumer(self) -> VcvtF64Consumer<false, false, false> {
            VcvtF64Consumer {
                y: Some(self.y),
                dd: Some(self.dd),
                dm: Some(self.dm),
            }
        }
    }
    impl VcvtF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcvtF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VcvtF64",
                "y",
                &self.y,
                "dd",
                &self.dd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcvtF64 {
        #[inline]
        fn clone(&self) -> VcvtF64 {
            VcvtF64 {
                y: ::core::clone::Clone::clone(&self.y),
                dd: ::core::clone::Clone::clone(&self.dd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcvtF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcvtF64 {
        #[inline]
        fn eq(&self, other: &VcvtF64) -> bool {
            self.y == other.y && self.dd == other.dd && self.dm == other.dm
        }
    }
    impl From<VcvtF64> for Operation {
        fn from(val: VcvtF64) -> Operation {
            Operation::VcvtF64(val)
        }
    }
    pub struct VcmpF32 {
        pub y: Option<bool>,
        pub sd: F32Register,
        pub dm: F32Register,
    }
    pub struct VcmpF32Builder<const ySET: bool, const sdSET: bool, const dmSET: bool> {
        y: Option<Option<bool>>,
        sd: Option<F32Register>,
        dm: Option<F32Register>,
    }
    impl<const sdSET: bool, const dmSET: bool> VcmpF32Builder<false, sdSET, dmSET> {
        pub fn set_y(mut self, y: Option<bool>) -> VcmpF32Builder<true, sdSET, dmSET> {
            self.y = Some(y);
            VcmpF32Builder {
                y: self.y,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl<const ySET: bool, const dmSET: bool> VcmpF32Builder<ySET, false, dmSET> {
        pub fn set_sd(mut self, sd: F32Register) -> VcmpF32Builder<ySET, true, dmSET> {
            self.sd = Some(sd);
            VcmpF32Builder {
                y: self.y,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl<const ySET: bool, const sdSET: bool> VcmpF32Builder<ySET, sdSET, false> {
        pub fn set_dm(mut self, dm: F32Register) -> VcmpF32Builder<ySET, sdSET, true> {
            self.dm = Some(dm);
            VcmpF32Builder {
                y: self.y,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl VcmpF32Builder<false, false, false> {
        pub fn new() -> VcmpF32Builder<false, false, false> {
            VcmpF32Builder {
                y: None,
                sd: None,
                dm: None,
            }
        }
    }
    impl VcmpF32 {
        pub fn builder() -> VcmpF32Builder<false, false, false> {
            VcmpF32Builder {
                y: None,
                sd: None,
                dm: None,
            }
        }
    }
    impl VcmpF32Builder<true, true, true> {
        pub fn complete(self) -> VcmpF32 {
            VcmpF32 {
                y: self.y.unwrap(),
                sd: self.sd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VcmpF32Consumer<const ySET: bool, const sdSET: bool, const dmSET: bool> {
        y: Option<Option<bool>>,
        sd: Option<F32Register>,
        dm: Option<F32Register>,
    }
    impl<
        const sdCONSUMED: bool,
        const dmCONSUMED: bool,
    > VcmpF32Consumer<false, sdCONSUMED, dmCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (Option<bool>, VcmpF32Consumer<true, sdCONSUMED, dmCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VcmpF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const dmCONSUMED: bool,
    > VcmpF32Consumer<yCONSUMED, false, dmCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VcmpF32Consumer<yCONSUMED, true, dmCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VcmpF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const yCONSUMED: bool,
        const sdCONSUMED: bool,
    > VcmpF32Consumer<yCONSUMED, sdCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F32Register, VcmpF32Consumer<yCONSUMED, sdCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VcmpF32Consumer {
                    y: self.y,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VcmpF32 {
        pub fn consumer(self) -> VcmpF32Consumer<false, false, false> {
            VcmpF32Consumer {
                y: Some(self.y),
                sd: Some(self.sd),
                dm: Some(self.dm),
            }
        }
    }
    impl VcmpF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcmpF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VcmpF32",
                "y",
                &self.y,
                "sd",
                &self.sd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcmpF32 {
        #[inline]
        fn clone(&self) -> VcmpF32 {
            VcmpF32 {
                y: ::core::clone::Clone::clone(&self.y),
                sd: ::core::clone::Clone::clone(&self.sd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcmpF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcmpF32 {
        #[inline]
        fn eq(&self, other: &VcmpF32) -> bool {
            self.y == other.y && self.sd == other.sd && self.dm == other.dm
        }
    }
    impl From<VcmpF32> for Operation {
        fn from(val: VcmpF32) -> Operation {
            Operation::VcmpF32(val)
        }
    }
    pub struct VcmpZeroF32 {
        pub y: Option<bool>,
        pub sd: F32Register,
    }
    pub struct VcmpZeroF32Builder<const ySET: bool, const sdSET: bool> {
        y: Option<Option<bool>>,
        sd: Option<F32Register>,
    }
    impl<const sdSET: bool> VcmpZeroF32Builder<false, sdSET> {
        pub fn set_y(mut self, y: Option<bool>) -> VcmpZeroF32Builder<true, sdSET> {
            self.y = Some(y);
            VcmpZeroF32Builder {
                y: self.y,
                sd: self.sd,
            }
        }
    }
    impl<const ySET: bool> VcmpZeroF32Builder<ySET, false> {
        pub fn set_sd(mut self, sd: F32Register) -> VcmpZeroF32Builder<ySET, true> {
            self.sd = Some(sd);
            VcmpZeroF32Builder {
                y: self.y,
                sd: self.sd,
            }
        }
    }
    impl VcmpZeroF32Builder<false, false> {
        pub fn new() -> VcmpZeroF32Builder<false, false> {
            VcmpZeroF32Builder {
                y: None,
                sd: None,
            }
        }
    }
    impl VcmpZeroF32 {
        pub fn builder() -> VcmpZeroF32Builder<false, false> {
            VcmpZeroF32Builder {
                y: None,
                sd: None,
            }
        }
    }
    impl VcmpZeroF32Builder<true, true> {
        pub fn complete(self) -> VcmpZeroF32 {
            VcmpZeroF32 {
                y: self.y.unwrap(),
                sd: self.sd.unwrap(),
            }
        }
    }
    pub struct VcmpZeroF32Consumer<const ySET: bool, const sdSET: bool> {
        y: Option<Option<bool>>,
        sd: Option<F32Register>,
    }
    impl<const sdCONSUMED: bool> VcmpZeroF32Consumer<false, sdCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (Option<bool>, VcmpZeroF32Consumer<true, sdCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VcmpZeroF32Consumer {
                    y: self.y,
                    sd: self.sd,
                },
            )
        }
    }
    impl<const yCONSUMED: bool> VcmpZeroF32Consumer<yCONSUMED, false> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VcmpZeroF32Consumer<yCONSUMED, true>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VcmpZeroF32Consumer {
                    y: self.y,
                    sd: self.sd,
                },
            )
        }
    }
    impl VcmpZeroF32 {
        pub fn consumer(self) -> VcmpZeroF32Consumer<false, false> {
            VcmpZeroF32Consumer {
                y: Some(self.y),
                sd: Some(self.sd),
            }
        }
    }
    impl VcmpZeroF32Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcmpZeroF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VcmpZeroF32",
                "y",
                &self.y,
                "sd",
                &&self.sd,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcmpZeroF32 {
        #[inline]
        fn clone(&self) -> VcmpZeroF32 {
            VcmpZeroF32 {
                y: ::core::clone::Clone::clone(&self.y),
                sd: ::core::clone::Clone::clone(&self.sd),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcmpZeroF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcmpZeroF32 {
        #[inline]
        fn eq(&self, other: &VcmpZeroF32) -> bool {
            self.y == other.y && self.sd == other.sd
        }
    }
    impl From<VcmpZeroF32> for Operation {
        fn from(val: VcmpZeroF32) -> Operation {
            Operation::VcmpZeroF32(val)
        }
    }
    pub struct VcmpZeroF64 {
        pub y: Option<bool>,
        pub sd: F64Register,
    }
    pub struct VcmpZeroF64Builder<const ySET: bool, const sdSET: bool> {
        y: Option<Option<bool>>,
        sd: Option<F64Register>,
    }
    impl<const sdSET: bool> VcmpZeroF64Builder<false, sdSET> {
        pub fn set_y(mut self, y: Option<bool>) -> VcmpZeroF64Builder<true, sdSET> {
            self.y = Some(y);
            VcmpZeroF64Builder {
                y: self.y,
                sd: self.sd,
            }
        }
    }
    impl<const ySET: bool> VcmpZeroF64Builder<ySET, false> {
        pub fn set_sd(mut self, sd: F64Register) -> VcmpZeroF64Builder<ySET, true> {
            self.sd = Some(sd);
            VcmpZeroF64Builder {
                y: self.y,
                sd: self.sd,
            }
        }
    }
    impl VcmpZeroF64Builder<false, false> {
        pub fn new() -> VcmpZeroF64Builder<false, false> {
            VcmpZeroF64Builder {
                y: None,
                sd: None,
            }
        }
    }
    impl VcmpZeroF64 {
        pub fn builder() -> VcmpZeroF64Builder<false, false> {
            VcmpZeroF64Builder {
                y: None,
                sd: None,
            }
        }
    }
    impl VcmpZeroF64Builder<true, true> {
        pub fn complete(self) -> VcmpZeroF64 {
            VcmpZeroF64 {
                y: self.y.unwrap(),
                sd: self.sd.unwrap(),
            }
        }
    }
    pub struct VcmpZeroF64Consumer<const ySET: bool, const sdSET: bool> {
        y: Option<Option<bool>>,
        sd: Option<F64Register>,
    }
    impl<const sdCONSUMED: bool> VcmpZeroF64Consumer<false, sdCONSUMED> {
        pub fn consume_y(
            mut self,
        ) -> (Option<bool>, VcmpZeroF64Consumer<true, sdCONSUMED>) {
            let ret = self.y.unwrap();
            self.y = None;
            (
                ret,
                VcmpZeroF64Consumer {
                    y: self.y,
                    sd: self.sd,
                },
            )
        }
    }
    impl<const yCONSUMED: bool> VcmpZeroF64Consumer<yCONSUMED, false> {
        pub fn consume_sd(
            mut self,
        ) -> (F64Register, VcmpZeroF64Consumer<yCONSUMED, true>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VcmpZeroF64Consumer {
                    y: self.y,
                    sd: self.sd,
                },
            )
        }
    }
    impl VcmpZeroF64 {
        pub fn consumer(self) -> VcmpZeroF64Consumer<false, false> {
            VcmpZeroF64Consumer {
                y: Some(self.y),
                sd: Some(self.sd),
            }
        }
    }
    impl VcmpZeroF64Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcmpZeroF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VcmpZeroF64",
                "y",
                &self.y,
                "sd",
                &&self.sd,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcmpZeroF64 {
        #[inline]
        fn clone(&self) -> VcmpZeroF64 {
            VcmpZeroF64 {
                y: ::core::clone::Clone::clone(&self.y),
                sd: ::core::clone::Clone::clone(&self.sd),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcmpZeroF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcmpZeroF64 {
        #[inline]
        fn eq(&self, other: &VcmpZeroF64) -> bool {
            self.y == other.y && self.sd == other.sd
        }
    }
    impl From<VcmpZeroF64> for Operation {
        fn from(val: VcmpZeroF64) -> Operation {
            Operation::VcmpZeroF64(val)
        }
    }
    pub struct VrintF32 {
        pub r: Option<bool>,
        pub sd: F32Register,
        pub dm: F32Register,
    }
    pub struct VrintF32Builder<const rSET: bool, const sdSET: bool, const dmSET: bool> {
        r: Option<Option<bool>>,
        sd: Option<F32Register>,
        dm: Option<F32Register>,
    }
    impl<const sdSET: bool, const dmSET: bool> VrintF32Builder<false, sdSET, dmSET> {
        pub fn set_r(mut self, r: Option<bool>) -> VrintF32Builder<true, sdSET, dmSET> {
            self.r = Some(r);
            VrintF32Builder {
                r: self.r,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl<const rSET: bool, const dmSET: bool> VrintF32Builder<rSET, false, dmSET> {
        pub fn set_sd(mut self, sd: F32Register) -> VrintF32Builder<rSET, true, dmSET> {
            self.sd = Some(sd);
            VrintF32Builder {
                r: self.r,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl<const rSET: bool, const sdSET: bool> VrintF32Builder<rSET, sdSET, false> {
        pub fn set_dm(mut self, dm: F32Register) -> VrintF32Builder<rSET, sdSET, true> {
            self.dm = Some(dm);
            VrintF32Builder {
                r: self.r,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl VrintF32Builder<false, false, false> {
        pub fn new() -> VrintF32Builder<false, false, false> {
            VrintF32Builder {
                r: None,
                sd: None,
                dm: None,
            }
        }
    }
    impl VrintF32 {
        pub fn builder() -> VrintF32Builder<false, false, false> {
            VrintF32Builder {
                r: None,
                sd: None,
                dm: None,
            }
        }
    }
    impl VrintF32Builder<true, true, true> {
        pub fn complete(self) -> VrintF32 {
            VrintF32 {
                r: self.r.unwrap(),
                sd: self.sd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VrintF32Consumer<const rSET: bool, const sdSET: bool, const dmSET: bool> {
        r: Option<Option<bool>>,
        sd: Option<F32Register>,
        dm: Option<F32Register>,
    }
    impl<
        const sdCONSUMED: bool,
        const dmCONSUMED: bool,
    > VrintF32Consumer<false, sdCONSUMED, dmCONSUMED> {
        pub fn consume_r(
            mut self,
        ) -> (Option<bool>, VrintF32Consumer<true, sdCONSUMED, dmCONSUMED>) {
            let ret = self.r.unwrap();
            self.r = None;
            (
                ret,
                VrintF32Consumer {
                    r: self.r,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const dmCONSUMED: bool,
    > VrintF32Consumer<rCONSUMED, false, dmCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VrintF32Consumer<rCONSUMED, true, dmCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VrintF32Consumer {
                    r: self.r,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const sdCONSUMED: bool,
    > VrintF32Consumer<rCONSUMED, sdCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F32Register, VrintF32Consumer<rCONSUMED, sdCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VrintF32Consumer {
                    r: self.r,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VrintF32 {
        pub fn consumer(self) -> VrintF32Consumer<false, false, false> {
            VrintF32Consumer {
                r: Some(self.r),
                sd: Some(self.sd),
                dm: Some(self.dm),
            }
        }
    }
    impl VrintF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VrintF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VrintF32",
                "r",
                &self.r,
                "sd",
                &self.sd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VrintF32 {
        #[inline]
        fn clone(&self) -> VrintF32 {
            VrintF32 {
                r: ::core::clone::Clone::clone(&self.r),
                sd: ::core::clone::Clone::clone(&self.sd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VrintF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VrintF32 {
        #[inline]
        fn eq(&self, other: &VrintF32) -> bool {
            self.r == other.r && self.sd == other.sd && self.dm == other.dm
        }
    }
    impl From<VrintF32> for Operation {
        fn from(val: VrintF32) -> Operation {
            Operation::VrintF32(val)
        }
    }
    pub struct VrintF64 {
        pub r: Option<bool>,
        pub dd: F64Register,
        pub dm: F64Register,
    }
    pub struct VrintF64Builder<const rSET: bool, const ddSET: bool, const dmSET: bool> {
        r: Option<Option<bool>>,
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<const ddSET: bool, const dmSET: bool> VrintF64Builder<false, ddSET, dmSET> {
        pub fn set_r(mut self, r: Option<bool>) -> VrintF64Builder<true, ddSET, dmSET> {
            self.r = Some(r);
            VrintF64Builder {
                r: self.r,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<const rSET: bool, const dmSET: bool> VrintF64Builder<rSET, false, dmSET> {
        pub fn set_dd(mut self, dd: F64Register) -> VrintF64Builder<rSET, true, dmSET> {
            self.dd = Some(dd);
            VrintF64Builder {
                r: self.r,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<const rSET: bool, const ddSET: bool> VrintF64Builder<rSET, ddSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VrintF64Builder<rSET, ddSET, true> {
            self.dm = Some(dm);
            VrintF64Builder {
                r: self.r,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl VrintF64Builder<false, false, false> {
        pub fn new() -> VrintF64Builder<false, false, false> {
            VrintF64Builder {
                r: None,
                dd: None,
                dm: None,
            }
        }
    }
    impl VrintF64 {
        pub fn builder() -> VrintF64Builder<false, false, false> {
            VrintF64Builder {
                r: None,
                dd: None,
                dm: None,
            }
        }
    }
    impl VrintF64Builder<true, true, true> {
        pub fn complete(self) -> VrintF64 {
            VrintF64 {
                r: self.r.unwrap(),
                dd: self.dd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VrintF64Consumer<const rSET: bool, const ddSET: bool, const dmSET: bool> {
        r: Option<Option<bool>>,
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VrintF64Consumer<false, ddCONSUMED, dmCONSUMED> {
        pub fn consume_r(
            mut self,
        ) -> (Option<bool>, VrintF64Consumer<true, ddCONSUMED, dmCONSUMED>) {
            let ret = self.r.unwrap();
            self.r = None;
            (
                ret,
                VrintF64Consumer {
                    r: self.r,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const dmCONSUMED: bool,
    > VrintF64Consumer<rCONSUMED, false, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VrintF64Consumer<rCONSUMED, true, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VrintF64Consumer {
                    r: self.r,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const ddCONSUMED: bool,
    > VrintF64Consumer<rCONSUMED, ddCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VrintF64Consumer<rCONSUMED, ddCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VrintF64Consumer {
                    r: self.r,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VrintF64 {
        pub fn consumer(self) -> VrintF64Consumer<false, false, false> {
            VrintF64Consumer {
                r: Some(self.r),
                dd: Some(self.dd),
                dm: Some(self.dm),
            }
        }
    }
    impl VrintF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VrintF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VrintF64",
                "r",
                &self.r,
                "dd",
                &self.dd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VrintF64 {
        #[inline]
        fn clone(&self) -> VrintF64 {
            VrintF64 {
                r: ::core::clone::Clone::clone(&self.r),
                dd: ::core::clone::Clone::clone(&self.dd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VrintF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VrintF64 {
        #[inline]
        fn eq(&self, other: &VrintF64) -> bool {
            self.r == other.r && self.dd == other.dd && self.dm == other.dm
        }
    }
    impl From<VrintF64> for Operation {
        fn from(val: VrintF64) -> Operation {
            Operation::VrintF64(val)
        }
    }
    pub struct VcvtF64F32 {
        pub sd: F32Register,
        pub dm: F64Register,
    }
    pub struct VcvtF64F32Builder<const sdSET: bool, const dmSET: bool> {
        sd: Option<F32Register>,
        dm: Option<F64Register>,
    }
    impl<const dmSET: bool> VcvtF64F32Builder<false, dmSET> {
        pub fn set_sd(mut self, sd: F32Register) -> VcvtF64F32Builder<true, dmSET> {
            self.sd = Some(sd);
            VcvtF64F32Builder {
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl<const sdSET: bool> VcvtF64F32Builder<sdSET, false> {
        pub fn set_dm(mut self, dm: F64Register) -> VcvtF64F32Builder<sdSET, true> {
            self.dm = Some(dm);
            VcvtF64F32Builder {
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl VcvtF64F32Builder<false, false> {
        pub fn new() -> VcvtF64F32Builder<false, false> {
            VcvtF64F32Builder {
                sd: None,
                dm: None,
            }
        }
    }
    impl VcvtF64F32 {
        pub fn builder() -> VcvtF64F32Builder<false, false> {
            VcvtF64F32Builder {
                sd: None,
                dm: None,
            }
        }
    }
    impl VcvtF64F32Builder<true, true> {
        pub fn complete(self) -> VcvtF64F32 {
            VcvtF64F32 {
                sd: self.sd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VcvtF64F32Consumer<const sdSET: bool, const dmSET: bool> {
        sd: Option<F32Register>,
        dm: Option<F64Register>,
    }
    impl<const dmCONSUMED: bool> VcvtF64F32Consumer<false, dmCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VcvtF64F32Consumer<true, dmCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VcvtF64F32Consumer {
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<const sdCONSUMED: bool> VcvtF64F32Consumer<sdCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VcvtF64F32Consumer<sdCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VcvtF64F32Consumer {
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VcvtF64F32 {
        pub fn consumer(self) -> VcvtF64F32Consumer<false, false> {
            VcvtF64F32Consumer {
                sd: Some(self.sd),
                dm: Some(self.dm),
            }
        }
    }
    impl VcvtF64F32Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcvtF64F32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VcvtF64F32",
                "sd",
                &self.sd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcvtF64F32 {
        #[inline]
        fn clone(&self) -> VcvtF64F32 {
            VcvtF64F32 {
                sd: ::core::clone::Clone::clone(&self.sd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcvtF64F32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcvtF64F32 {
        #[inline]
        fn eq(&self, other: &VcvtF64F32) -> bool {
            self.sd == other.sd && self.dm == other.dm
        }
    }
    impl From<VcvtF64F32> for Operation {
        fn from(val: VcvtF64F32) -> Operation {
            Operation::VcvtF64F32(val)
        }
    }
    pub struct VcvtF32F64 {
        pub dd: F64Register,
        pub sm: F32Register,
    }
    pub struct VcvtF32F64Builder<const ddSET: bool, const smSET: bool> {
        dd: Option<F64Register>,
        sm: Option<F32Register>,
    }
    impl<const smSET: bool> VcvtF32F64Builder<false, smSET> {
        pub fn set_dd(mut self, dd: F64Register) -> VcvtF32F64Builder<true, smSET> {
            self.dd = Some(dd);
            VcvtF32F64Builder {
                dd: self.dd,
                sm: self.sm,
            }
        }
    }
    impl<const ddSET: bool> VcvtF32F64Builder<ddSET, false> {
        pub fn set_sm(mut self, sm: F32Register) -> VcvtF32F64Builder<ddSET, true> {
            self.sm = Some(sm);
            VcvtF32F64Builder {
                dd: self.dd,
                sm: self.sm,
            }
        }
    }
    impl VcvtF32F64Builder<false, false> {
        pub fn new() -> VcvtF32F64Builder<false, false> {
            VcvtF32F64Builder {
                dd: None,
                sm: None,
            }
        }
    }
    impl VcvtF32F64 {
        pub fn builder() -> VcvtF32F64Builder<false, false> {
            VcvtF32F64Builder {
                dd: None,
                sm: None,
            }
        }
    }
    impl VcvtF32F64Builder<true, true> {
        pub fn complete(self) -> VcvtF32F64 {
            VcvtF32F64 {
                dd: self.dd.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VcvtF32F64Consumer<const ddSET: bool, const smSET: bool> {
        dd: Option<F64Register>,
        sm: Option<F32Register>,
    }
    impl<const smCONSUMED: bool> VcvtF32F64Consumer<false, smCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VcvtF32F64Consumer<true, smCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VcvtF32F64Consumer {
                    dd: self.dd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<const ddCONSUMED: bool> VcvtF32F64Consumer<ddCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VcvtF32F64Consumer<ddCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VcvtF32F64Consumer {
                    dd: self.dd,
                    sm: self.sm,
                },
            )
        }
    }
    impl VcvtF32F64 {
        pub fn consumer(self) -> VcvtF32F64Consumer<false, false> {
            VcvtF32F64Consumer {
                dd: Some(self.dd),
                sm: Some(self.sm),
            }
        }
    }
    impl VcvtF32F64Consumer<true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcvtF32F64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "VcvtF32F64",
                "dd",
                &self.dd,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcvtF32F64 {
        #[inline]
        fn clone(&self) -> VcvtF32F64 {
            VcvtF32F64 {
                dd: ::core::clone::Clone::clone(&self.dd),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcvtF32F64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcvtF32F64 {
        #[inline]
        fn eq(&self, other: &VcvtF32F64) -> bool {
            self.dd == other.dd && self.sm == other.sm
        }
    }
    impl From<VcvtF32F64> for Operation {
        fn from(val: VcvtF32F64) -> Operation {
            Operation::VcvtF32F64(val)
        }
    }
    pub struct Vcvt {
        pub r: Option<bool>,
        pub dest: ConversionArgument,
        pub sm: ConversionArgument,
        pub fbits: Option<u32>,
    }
    pub struct VcvtBuilder<
        const rSET: bool,
        const destSET: bool,
        const smSET: bool,
        const fbitsSET: bool,
    > {
        r: Option<Option<bool>>,
        dest: Option<ConversionArgument>,
        sm: Option<ConversionArgument>,
        fbits: Option<Option<u32>>,
    }
    impl<
        const destSET: bool,
        const smSET: bool,
        const fbitsSET: bool,
    > VcvtBuilder<false, destSET, smSET, fbitsSET> {
        pub fn set_r(
            mut self,
            r: Option<bool>,
        ) -> VcvtBuilder<true, destSET, smSET, fbitsSET> {
            self.r = Some(r);
            VcvtBuilder {
                r: self.r,
                dest: self.dest,
                sm: self.sm,
                fbits: self.fbits,
            }
        }
    }
    impl<
        const rSET: bool,
        const smSET: bool,
        const fbitsSET: bool,
    > VcvtBuilder<rSET, false, smSET, fbitsSET> {
        pub fn set_dest(
            mut self,
            dest: ConversionArgument,
        ) -> VcvtBuilder<rSET, true, smSET, fbitsSET> {
            self.dest = Some(dest);
            VcvtBuilder {
                r: self.r,
                dest: self.dest,
                sm: self.sm,
                fbits: self.fbits,
            }
        }
    }
    impl<
        const rSET: bool,
        const destSET: bool,
        const fbitsSET: bool,
    > VcvtBuilder<rSET, destSET, false, fbitsSET> {
        pub fn set_sm(
            mut self,
            sm: ConversionArgument,
        ) -> VcvtBuilder<rSET, destSET, true, fbitsSET> {
            self.sm = Some(sm);
            VcvtBuilder {
                r: self.r,
                dest: self.dest,
                sm: self.sm,
                fbits: self.fbits,
            }
        }
    }
    impl<
        const rSET: bool,
        const destSET: bool,
        const smSET: bool,
    > VcvtBuilder<rSET, destSET, smSET, false> {
        pub fn set_fbits(
            mut self,
            fbits: Option<u32>,
        ) -> VcvtBuilder<rSET, destSET, smSET, true> {
            self.fbits = Some(fbits);
            VcvtBuilder {
                r: self.r,
                dest: self.dest,
                sm: self.sm,
                fbits: self.fbits,
            }
        }
    }
    impl VcvtBuilder<false, false, false, false> {
        pub fn new() -> VcvtBuilder<false, false, false, false> {
            VcvtBuilder {
                r: None,
                dest: None,
                sm: None,
                fbits: None,
            }
        }
    }
    impl Vcvt {
        pub fn builder() -> VcvtBuilder<false, false, false, false> {
            VcvtBuilder {
                r: None,
                dest: None,
                sm: None,
                fbits: None,
            }
        }
    }
    impl VcvtBuilder<true, true, true, true> {
        pub fn complete(self) -> Vcvt {
            Vcvt {
                r: self.r.unwrap(),
                dest: self.dest.unwrap(),
                sm: self.sm.unwrap(),
                fbits: self.fbits.unwrap(),
            }
        }
    }
    pub struct VcvtConsumer<
        const rSET: bool,
        const destSET: bool,
        const smSET: bool,
        const fbitsSET: bool,
    > {
        r: Option<Option<bool>>,
        dest: Option<ConversionArgument>,
        sm: Option<ConversionArgument>,
        fbits: Option<Option<u32>>,
    }
    impl<
        const destCONSUMED: bool,
        const smCONSUMED: bool,
        const fbitsCONSUMED: bool,
    > VcvtConsumer<false, destCONSUMED, smCONSUMED, fbitsCONSUMED> {
        pub fn consume_r(
            mut self,
        ) -> (
            Option<bool>,
            VcvtConsumer<true, destCONSUMED, smCONSUMED, fbitsCONSUMED>,
        ) {
            let ret = self.r.unwrap();
            self.r = None;
            (
                ret,
                VcvtConsumer {
                    r: self.r,
                    dest: self.dest,
                    sm: self.sm,
                    fbits: self.fbits,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const smCONSUMED: bool,
        const fbitsCONSUMED: bool,
    > VcvtConsumer<rCONSUMED, false, smCONSUMED, fbitsCONSUMED> {
        pub fn consume_dest(
            mut self,
        ) -> (
            ConversionArgument,
            VcvtConsumer<rCONSUMED, true, smCONSUMED, fbitsCONSUMED>,
        ) {
            let ret = self.dest.unwrap();
            self.dest = None;
            (
                ret,
                VcvtConsumer {
                    r: self.r,
                    dest: self.dest,
                    sm: self.sm,
                    fbits: self.fbits,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const destCONSUMED: bool,
        const fbitsCONSUMED: bool,
    > VcvtConsumer<rCONSUMED, destCONSUMED, false, fbitsCONSUMED> {
        pub fn consume_sm(
            mut self,
        ) -> (
            ConversionArgument,
            VcvtConsumer<rCONSUMED, destCONSUMED, true, fbitsCONSUMED>,
        ) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VcvtConsumer {
                    r: self.r,
                    dest: self.dest,
                    sm: self.sm,
                    fbits: self.fbits,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const destCONSUMED: bool,
        const smCONSUMED: bool,
    > VcvtConsumer<rCONSUMED, destCONSUMED, smCONSUMED, false> {
        pub fn consume_fbits(
            mut self,
        ) -> (Option<u32>, VcvtConsumer<rCONSUMED, destCONSUMED, smCONSUMED, true>) {
            let ret = self.fbits.unwrap();
            self.fbits = None;
            (
                ret,
                VcvtConsumer {
                    r: self.r,
                    dest: self.dest,
                    sm: self.sm,
                    fbits: self.fbits,
                },
            )
        }
    }
    impl Vcvt {
        pub fn consumer(self) -> VcvtConsumer<false, false, false, false> {
            VcvtConsumer {
                r: Some(self.r),
                dest: Some(self.dest),
                sm: Some(self.sm),
                fbits: Some(self.fbits),
            }
        }
    }
    impl VcvtConsumer<true, true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Vcvt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Vcvt",
                "r",
                &self.r,
                "dest",
                &self.dest,
                "sm",
                &self.sm,
                "fbits",
                &&self.fbits,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Vcvt {
        #[inline]
        fn clone(&self) -> Vcvt {
            Vcvt {
                r: ::core::clone::Clone::clone(&self.r),
                dest: ::core::clone::Clone::clone(&self.dest),
                sm: ::core::clone::Clone::clone(&self.sm),
                fbits: ::core::clone::Clone::clone(&self.fbits),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Vcvt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Vcvt {
        #[inline]
        fn eq(&self, other: &Vcvt) -> bool {
            self.r == other.r && self.dest == other.dest && self.sm == other.sm
                && self.fbits == other.fbits
        }
    }
    impl From<Vcvt> for Operation {
        fn from(val: Vcvt) -> Operation {
            Operation::Vcvt(val)
        }
    }
    pub struct VrintCustomRoundingF32 {
        pub r: IEEE754RoundingMode,
        pub sd: F32Register,
        pub sm: F32Register,
    }
    pub struct VrintCustomRoundingF32Builder<
        const rSET: bool,
        const sdSET: bool,
        const smSET: bool,
    > {
        r: Option<IEEE754RoundingMode>,
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdSET: bool,
        const smSET: bool,
    > VrintCustomRoundingF32Builder<false, sdSET, smSET> {
        pub fn set_r(
            mut self,
            r: IEEE754RoundingMode,
        ) -> VrintCustomRoundingF32Builder<true, sdSET, smSET> {
            self.r = Some(r);
            VrintCustomRoundingF32Builder {
                r: self.r,
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl<
        const rSET: bool,
        const smSET: bool,
    > VrintCustomRoundingF32Builder<rSET, false, smSET> {
        pub fn set_sd(
            mut self,
            sd: F32Register,
        ) -> VrintCustomRoundingF32Builder<rSET, true, smSET> {
            self.sd = Some(sd);
            VrintCustomRoundingF32Builder {
                r: self.r,
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl<
        const rSET: bool,
        const sdSET: bool,
    > VrintCustomRoundingF32Builder<rSET, sdSET, false> {
        pub fn set_sm(
            mut self,
            sm: F32Register,
        ) -> VrintCustomRoundingF32Builder<rSET, sdSET, true> {
            self.sm = Some(sm);
            VrintCustomRoundingF32Builder {
                r: self.r,
                sd: self.sd,
                sm: self.sm,
            }
        }
    }
    impl VrintCustomRoundingF32Builder<false, false, false> {
        pub fn new() -> VrintCustomRoundingF32Builder<false, false, false> {
            VrintCustomRoundingF32Builder {
                r: None,
                sd: None,
                sm: None,
            }
        }
    }
    impl VrintCustomRoundingF32 {
        pub fn builder() -> VrintCustomRoundingF32Builder<false, false, false> {
            VrintCustomRoundingF32Builder {
                r: None,
                sd: None,
                sm: None,
            }
        }
    }
    impl VrintCustomRoundingF32Builder<true, true, true> {
        pub fn complete(self) -> VrintCustomRoundingF32 {
            VrintCustomRoundingF32 {
                r: self.r.unwrap(),
                sd: self.sd.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VrintCustomRoundingF32Consumer<
        const rSET: bool,
        const sdSET: bool,
        const smSET: bool,
    > {
        r: Option<IEEE754RoundingMode>,
        sd: Option<F32Register>,
        sm: Option<F32Register>,
    }
    impl<
        const sdCONSUMED: bool,
        const smCONSUMED: bool,
    > VrintCustomRoundingF32Consumer<false, sdCONSUMED, smCONSUMED> {
        pub fn consume_r(
            mut self,
        ) -> (
            IEEE754RoundingMode,
            VrintCustomRoundingF32Consumer<true, sdCONSUMED, smCONSUMED>,
        ) {
            let ret = self.r.unwrap();
            self.r = None;
            (
                ret,
                VrintCustomRoundingF32Consumer {
                    r: self.r,
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const smCONSUMED: bool,
    > VrintCustomRoundingF32Consumer<rCONSUMED, false, smCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (F32Register, VrintCustomRoundingF32Consumer<rCONSUMED, true, smCONSUMED>) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VrintCustomRoundingF32Consumer {
                    r: self.r,
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const sdCONSUMED: bool,
    > VrintCustomRoundingF32Consumer<rCONSUMED, sdCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (F32Register, VrintCustomRoundingF32Consumer<rCONSUMED, sdCONSUMED, true>) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VrintCustomRoundingF32Consumer {
                    r: self.r,
                    sd: self.sd,
                    sm: self.sm,
                },
            )
        }
    }
    impl VrintCustomRoundingF32 {
        pub fn consumer(self) -> VrintCustomRoundingF32Consumer<false, false, false> {
            VrintCustomRoundingF32Consumer {
                r: Some(self.r),
                sd: Some(self.sd),
                sm: Some(self.sm),
            }
        }
    }
    impl VrintCustomRoundingF32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VrintCustomRoundingF32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VrintCustomRoundingF32",
                "r",
                &self.r,
                "sd",
                &self.sd,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VrintCustomRoundingF32 {
        #[inline]
        fn clone(&self) -> VrintCustomRoundingF32 {
            VrintCustomRoundingF32 {
                r: ::core::clone::Clone::clone(&self.r),
                sd: ::core::clone::Clone::clone(&self.sd),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VrintCustomRoundingF32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VrintCustomRoundingF32 {
        #[inline]
        fn eq(&self, other: &VrintCustomRoundingF32) -> bool {
            self.r == other.r && self.sd == other.sd && self.sm == other.sm
        }
    }
    impl From<VrintCustomRoundingF32> for Operation {
        fn from(val: VrintCustomRoundingF32) -> Operation {
            Operation::VrintCustomRoundingF32(val)
        }
    }
    pub struct VrintCustomRoundingF64 {
        pub r: IEEE754RoundingMode,
        pub dd: F64Register,
        pub dm: F64Register,
    }
    pub struct VrintCustomRoundingF64Builder<
        const rSET: bool,
        const ddSET: bool,
        const dmSET: bool,
    > {
        r: Option<IEEE754RoundingMode>,
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddSET: bool,
        const dmSET: bool,
    > VrintCustomRoundingF64Builder<false, ddSET, dmSET> {
        pub fn set_r(
            mut self,
            r: IEEE754RoundingMode,
        ) -> VrintCustomRoundingF64Builder<true, ddSET, dmSET> {
            self.r = Some(r);
            VrintCustomRoundingF64Builder {
                r: self.r,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<
        const rSET: bool,
        const dmSET: bool,
    > VrintCustomRoundingF64Builder<rSET, false, dmSET> {
        pub fn set_dd(
            mut self,
            dd: F64Register,
        ) -> VrintCustomRoundingF64Builder<rSET, true, dmSET> {
            self.dd = Some(dd);
            VrintCustomRoundingF64Builder {
                r: self.r,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl<
        const rSET: bool,
        const ddSET: bool,
    > VrintCustomRoundingF64Builder<rSET, ddSET, false> {
        pub fn set_dm(
            mut self,
            dm: F64Register,
        ) -> VrintCustomRoundingF64Builder<rSET, ddSET, true> {
            self.dm = Some(dm);
            VrintCustomRoundingF64Builder {
                r: self.r,
                dd: self.dd,
                dm: self.dm,
            }
        }
    }
    impl VrintCustomRoundingF64Builder<false, false, false> {
        pub fn new() -> VrintCustomRoundingF64Builder<false, false, false> {
            VrintCustomRoundingF64Builder {
                r: None,
                dd: None,
                dm: None,
            }
        }
    }
    impl VrintCustomRoundingF64 {
        pub fn builder() -> VrintCustomRoundingF64Builder<false, false, false> {
            VrintCustomRoundingF64Builder {
                r: None,
                dd: None,
                dm: None,
            }
        }
    }
    impl VrintCustomRoundingF64Builder<true, true, true> {
        pub fn complete(self) -> VrintCustomRoundingF64 {
            VrintCustomRoundingF64 {
                r: self.r.unwrap(),
                dd: self.dd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VrintCustomRoundingF64Consumer<
        const rSET: bool,
        const ddSET: bool,
        const dmSET: bool,
    > {
        r: Option<IEEE754RoundingMode>,
        dd: Option<F64Register>,
        dm: Option<F64Register>,
    }
    impl<
        const ddCONSUMED: bool,
        const dmCONSUMED: bool,
    > VrintCustomRoundingF64Consumer<false, ddCONSUMED, dmCONSUMED> {
        pub fn consume_r(
            mut self,
        ) -> (
            IEEE754RoundingMode,
            VrintCustomRoundingF64Consumer<true, ddCONSUMED, dmCONSUMED>,
        ) {
            let ret = self.r.unwrap();
            self.r = None;
            (
                ret,
                VrintCustomRoundingF64Consumer {
                    r: self.r,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const dmCONSUMED: bool,
    > VrintCustomRoundingF64Consumer<rCONSUMED, false, dmCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (F64Register, VrintCustomRoundingF64Consumer<rCONSUMED, true, dmCONSUMED>) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VrintCustomRoundingF64Consumer {
                    r: self.r,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const ddCONSUMED: bool,
    > VrintCustomRoundingF64Consumer<rCONSUMED, ddCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (F64Register, VrintCustomRoundingF64Consumer<rCONSUMED, ddCONSUMED, true>) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VrintCustomRoundingF64Consumer {
                    r: self.r,
                    dd: self.dd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VrintCustomRoundingF64 {
        pub fn consumer(self) -> VrintCustomRoundingF64Consumer<false, false, false> {
            VrintCustomRoundingF64Consumer {
                r: Some(self.r),
                dd: Some(self.dd),
                dm: Some(self.dm),
            }
        }
    }
    impl VrintCustomRoundingF64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VrintCustomRoundingF64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VrintCustomRoundingF64",
                "r",
                &self.r,
                "dd",
                &self.dd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VrintCustomRoundingF64 {
        #[inline]
        fn clone(&self) -> VrintCustomRoundingF64 {
            VrintCustomRoundingF64 {
                r: ::core::clone::Clone::clone(&self.r),
                dd: ::core::clone::Clone::clone(&self.dd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VrintCustomRoundingF64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VrintCustomRoundingF64 {
        #[inline]
        fn eq(&self, other: &VrintCustomRoundingF64) -> bool {
            self.r == other.r && self.dd == other.dd && self.dm == other.dm
        }
    }
    impl From<VrintCustomRoundingF64> for Operation {
        fn from(val: VrintCustomRoundingF64) -> Operation {
            Operation::VrintCustomRoundingF64(val)
        }
    }
    pub struct VcvtCustomRoundingF64F32 {
        pub r: IEEE754RoundingMode,
        pub sd: F32Register,
        pub dm: F64Register,
    }
    pub struct VcvtCustomRoundingF64F32Builder<
        const rSET: bool,
        const sdSET: bool,
        const dmSET: bool,
    > {
        r: Option<IEEE754RoundingMode>,
        sd: Option<F32Register>,
        dm: Option<F64Register>,
    }
    impl<
        const sdSET: bool,
        const dmSET: bool,
    > VcvtCustomRoundingF64F32Builder<false, sdSET, dmSET> {
        pub fn set_r(
            mut self,
            r: IEEE754RoundingMode,
        ) -> VcvtCustomRoundingF64F32Builder<true, sdSET, dmSET> {
            self.r = Some(r);
            VcvtCustomRoundingF64F32Builder {
                r: self.r,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl<
        const rSET: bool,
        const dmSET: bool,
    > VcvtCustomRoundingF64F32Builder<rSET, false, dmSET> {
        pub fn set_sd(
            mut self,
            sd: F32Register,
        ) -> VcvtCustomRoundingF64F32Builder<rSET, true, dmSET> {
            self.sd = Some(sd);
            VcvtCustomRoundingF64F32Builder {
                r: self.r,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl<
        const rSET: bool,
        const sdSET: bool,
    > VcvtCustomRoundingF64F32Builder<rSET, sdSET, false> {
        pub fn set_dm(
            mut self,
            dm: F64Register,
        ) -> VcvtCustomRoundingF64F32Builder<rSET, sdSET, true> {
            self.dm = Some(dm);
            VcvtCustomRoundingF64F32Builder {
                r: self.r,
                sd: self.sd,
                dm: self.dm,
            }
        }
    }
    impl VcvtCustomRoundingF64F32Builder<false, false, false> {
        pub fn new() -> VcvtCustomRoundingF64F32Builder<false, false, false> {
            VcvtCustomRoundingF64F32Builder {
                r: None,
                sd: None,
                dm: None,
            }
        }
    }
    impl VcvtCustomRoundingF64F32 {
        pub fn builder() -> VcvtCustomRoundingF64F32Builder<false, false, false> {
            VcvtCustomRoundingF64F32Builder {
                r: None,
                sd: None,
                dm: None,
            }
        }
    }
    impl VcvtCustomRoundingF64F32Builder<true, true, true> {
        pub fn complete(self) -> VcvtCustomRoundingF64F32 {
            VcvtCustomRoundingF64F32 {
                r: self.r.unwrap(),
                sd: self.sd.unwrap(),
                dm: self.dm.unwrap(),
            }
        }
    }
    pub struct VcvtCustomRoundingF64F32Consumer<
        const rSET: bool,
        const sdSET: bool,
        const dmSET: bool,
    > {
        r: Option<IEEE754RoundingMode>,
        sd: Option<F32Register>,
        dm: Option<F64Register>,
    }
    impl<
        const sdCONSUMED: bool,
        const dmCONSUMED: bool,
    > VcvtCustomRoundingF64F32Consumer<false, sdCONSUMED, dmCONSUMED> {
        pub fn consume_r(
            mut self,
        ) -> (
            IEEE754RoundingMode,
            VcvtCustomRoundingF64F32Consumer<true, sdCONSUMED, dmCONSUMED>,
        ) {
            let ret = self.r.unwrap();
            self.r = None;
            (
                ret,
                VcvtCustomRoundingF64F32Consumer {
                    r: self.r,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const dmCONSUMED: bool,
    > VcvtCustomRoundingF64F32Consumer<rCONSUMED, false, dmCONSUMED> {
        pub fn consume_sd(
            mut self,
        ) -> (
            F32Register,
            VcvtCustomRoundingF64F32Consumer<rCONSUMED, true, dmCONSUMED>,
        ) {
            let ret = self.sd.unwrap();
            self.sd = None;
            (
                ret,
                VcvtCustomRoundingF64F32Consumer {
                    r: self.r,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const sdCONSUMED: bool,
    > VcvtCustomRoundingF64F32Consumer<rCONSUMED, sdCONSUMED, false> {
        pub fn consume_dm(
            mut self,
        ) -> (
            F64Register,
            VcvtCustomRoundingF64F32Consumer<rCONSUMED, sdCONSUMED, true>,
        ) {
            let ret = self.dm.unwrap();
            self.dm = None;
            (
                ret,
                VcvtCustomRoundingF64F32Consumer {
                    r: self.r,
                    sd: self.sd,
                    dm: self.dm,
                },
            )
        }
    }
    impl VcvtCustomRoundingF64F32 {
        pub fn consumer(self) -> VcvtCustomRoundingF64F32Consumer<false, false, false> {
            VcvtCustomRoundingF64F32Consumer {
                r: Some(self.r),
                sd: Some(self.sd),
                dm: Some(self.dm),
            }
        }
    }
    impl VcvtCustomRoundingF64F32Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcvtCustomRoundingF64F32 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VcvtCustomRoundingF64F32",
                "r",
                &self.r,
                "sd",
                &self.sd,
                "dm",
                &&self.dm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcvtCustomRoundingF64F32 {
        #[inline]
        fn clone(&self) -> VcvtCustomRoundingF64F32 {
            VcvtCustomRoundingF64F32 {
                r: ::core::clone::Clone::clone(&self.r),
                sd: ::core::clone::Clone::clone(&self.sd),
                dm: ::core::clone::Clone::clone(&self.dm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcvtCustomRoundingF64F32 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcvtCustomRoundingF64F32 {
        #[inline]
        fn eq(&self, other: &VcvtCustomRoundingF64F32) -> bool {
            self.r == other.r && self.sd == other.sd && self.dm == other.dm
        }
    }
    impl From<VcvtCustomRoundingF64F32> for Operation {
        fn from(val: VcvtCustomRoundingF64F32) -> Operation {
            Operation::VcvtCustomRoundingF64F32(val)
        }
    }
    pub struct VcvtCustomRoundingF32F64 {
        pub r: IEEE754RoundingMode,
        pub dd: F64Register,
        pub sm: F32Register,
    }
    pub struct VcvtCustomRoundingF32F64Builder<
        const rSET: bool,
        const ddSET: bool,
        const smSET: bool,
    > {
        r: Option<IEEE754RoundingMode>,
        dd: Option<F64Register>,
        sm: Option<F32Register>,
    }
    impl<
        const ddSET: bool,
        const smSET: bool,
    > VcvtCustomRoundingF32F64Builder<false, ddSET, smSET> {
        pub fn set_r(
            mut self,
            r: IEEE754RoundingMode,
        ) -> VcvtCustomRoundingF32F64Builder<true, ddSET, smSET> {
            self.r = Some(r);
            VcvtCustomRoundingF32F64Builder {
                r: self.r,
                dd: self.dd,
                sm: self.sm,
            }
        }
    }
    impl<
        const rSET: bool,
        const smSET: bool,
    > VcvtCustomRoundingF32F64Builder<rSET, false, smSET> {
        pub fn set_dd(
            mut self,
            dd: F64Register,
        ) -> VcvtCustomRoundingF32F64Builder<rSET, true, smSET> {
            self.dd = Some(dd);
            VcvtCustomRoundingF32F64Builder {
                r: self.r,
                dd: self.dd,
                sm: self.sm,
            }
        }
    }
    impl<
        const rSET: bool,
        const ddSET: bool,
    > VcvtCustomRoundingF32F64Builder<rSET, ddSET, false> {
        pub fn set_sm(
            mut self,
            sm: F32Register,
        ) -> VcvtCustomRoundingF32F64Builder<rSET, ddSET, true> {
            self.sm = Some(sm);
            VcvtCustomRoundingF32F64Builder {
                r: self.r,
                dd: self.dd,
                sm: self.sm,
            }
        }
    }
    impl VcvtCustomRoundingF32F64Builder<false, false, false> {
        pub fn new() -> VcvtCustomRoundingF32F64Builder<false, false, false> {
            VcvtCustomRoundingF32F64Builder {
                r: None,
                dd: None,
                sm: None,
            }
        }
    }
    impl VcvtCustomRoundingF32F64 {
        pub fn builder() -> VcvtCustomRoundingF32F64Builder<false, false, false> {
            VcvtCustomRoundingF32F64Builder {
                r: None,
                dd: None,
                sm: None,
            }
        }
    }
    impl VcvtCustomRoundingF32F64Builder<true, true, true> {
        pub fn complete(self) -> VcvtCustomRoundingF32F64 {
            VcvtCustomRoundingF32F64 {
                r: self.r.unwrap(),
                dd: self.dd.unwrap(),
                sm: self.sm.unwrap(),
            }
        }
    }
    pub struct VcvtCustomRoundingF32F64Consumer<
        const rSET: bool,
        const ddSET: bool,
        const smSET: bool,
    > {
        r: Option<IEEE754RoundingMode>,
        dd: Option<F64Register>,
        sm: Option<F32Register>,
    }
    impl<
        const ddCONSUMED: bool,
        const smCONSUMED: bool,
    > VcvtCustomRoundingF32F64Consumer<false, ddCONSUMED, smCONSUMED> {
        pub fn consume_r(
            mut self,
        ) -> (
            IEEE754RoundingMode,
            VcvtCustomRoundingF32F64Consumer<true, ddCONSUMED, smCONSUMED>,
        ) {
            let ret = self.r.unwrap();
            self.r = None;
            (
                ret,
                VcvtCustomRoundingF32F64Consumer {
                    r: self.r,
                    dd: self.dd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const smCONSUMED: bool,
    > VcvtCustomRoundingF32F64Consumer<rCONSUMED, false, smCONSUMED> {
        pub fn consume_dd(
            mut self,
        ) -> (
            F64Register,
            VcvtCustomRoundingF32F64Consumer<rCONSUMED, true, smCONSUMED>,
        ) {
            let ret = self.dd.unwrap();
            self.dd = None;
            (
                ret,
                VcvtCustomRoundingF32F64Consumer {
                    r: self.r,
                    dd: self.dd,
                    sm: self.sm,
                },
            )
        }
    }
    impl<
        const rCONSUMED: bool,
        const ddCONSUMED: bool,
    > VcvtCustomRoundingF32F64Consumer<rCONSUMED, ddCONSUMED, false> {
        pub fn consume_sm(
            mut self,
        ) -> (
            F32Register,
            VcvtCustomRoundingF32F64Consumer<rCONSUMED, ddCONSUMED, true>,
        ) {
            let ret = self.sm.unwrap();
            self.sm = None;
            (
                ret,
                VcvtCustomRoundingF32F64Consumer {
                    r: self.r,
                    dd: self.dd,
                    sm: self.sm,
                },
            )
        }
    }
    impl VcvtCustomRoundingF32F64 {
        pub fn consumer(self) -> VcvtCustomRoundingF32F64Consumer<false, false, false> {
            VcvtCustomRoundingF32F64Consumer {
                r: Some(self.r),
                dd: Some(self.dd),
                sm: Some(self.sm),
            }
        }
    }
    impl VcvtCustomRoundingF32F64Consumer<true, true, true> {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VcvtCustomRoundingF32F64 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "VcvtCustomRoundingF32F64",
                "r",
                &self.r,
                "dd",
                &self.dd,
                "sm",
                &&self.sm,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VcvtCustomRoundingF32F64 {
        #[inline]
        fn clone(&self) -> VcvtCustomRoundingF32F64 {
            VcvtCustomRoundingF32F64 {
                r: ::core::clone::Clone::clone(&self.r),
                dd: ::core::clone::Clone::clone(&self.dd),
                sm: ::core::clone::Clone::clone(&self.sm),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VcvtCustomRoundingF32F64 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VcvtCustomRoundingF32F64 {
        #[inline]
        fn eq(&self, other: &VcvtCustomRoundingF32F64) -> bool {
            self.r == other.r && self.dd == other.dd && self.sm == other.sm
        }
    }
    impl From<VcvtCustomRoundingF32F64> for Operation {
        fn from(val: VcvtCustomRoundingF32F64) -> Operation {
            Operation::VcvtCustomRoundingF32F64(val)
        }
    }
    pub struct Wfe {}
    pub struct WfeBuilder {}
    impl WfeBuilder {
        pub fn new() -> WfeBuilder {
            WfeBuilder {}
        }
    }
    impl Wfe {
        pub fn builder() -> WfeBuilder {
            WfeBuilder {}
        }
    }
    impl WfeBuilder {
        pub fn complete(self) -> Wfe {
            Wfe {}
        }
    }
    pub struct WfeConsumer {}
    impl Wfe {
        pub fn consumer(self) -> WfeConsumer {
            WfeConsumer {}
        }
    }
    impl WfeConsumer {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Wfe {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Wfe")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Wfe {
        #[inline]
        fn clone(&self) -> Wfe {
            Wfe {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Wfe {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Wfe {
        #[inline]
        fn eq(&self, other: &Wfe) -> bool {
            true
        }
    }
    impl From<Wfe> for Operation {
        fn from(val: Wfe) -> Operation {
            Operation::Wfe(val)
        }
    }
    pub struct Wfi {}
    pub struct WfiBuilder {}
    impl WfiBuilder {
        pub fn new() -> WfiBuilder {
            WfiBuilder {}
        }
    }
    impl Wfi {
        pub fn builder() -> WfiBuilder {
            WfiBuilder {}
        }
    }
    impl WfiBuilder {
        pub fn complete(self) -> Wfi {
            Wfi {}
        }
    }
    pub struct WfiConsumer {}
    impl Wfi {
        pub fn consumer(self) -> WfiConsumer {
            WfiConsumer {}
        }
    }
    impl WfiConsumer {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Wfi {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Wfi")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Wfi {
        #[inline]
        fn clone(&self) -> Wfi {
            Wfi {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Wfi {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Wfi {
        #[inline]
        fn eq(&self, other: &Wfi) -> bool {
            true
        }
    }
    impl From<Wfi> for Operation {
        fn from(val: Wfi) -> Operation {
            Operation::Wfi(val)
        }
    }
    pub struct Yield {}
    pub struct YieldBuilder {}
    impl YieldBuilder {
        pub fn new() -> YieldBuilder {
            YieldBuilder {}
        }
    }
    impl Yield {
        pub fn builder() -> YieldBuilder {
            YieldBuilder {}
        }
    }
    impl YieldBuilder {
        pub fn complete(self) -> Yield {
            Yield {}
        }
    }
    pub struct YieldConsumer {}
    impl Yield {
        pub fn consumer(self) -> YieldConsumer {
            YieldConsumer {}
        }
    }
    impl YieldConsumer {
        pub fn consume(self) {}
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Yield {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Yield")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Yield {
        #[inline]
        fn clone(&self) -> Yield {
            Yield {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Yield {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Yield {
        #[inline]
        fn eq(&self, other: &Yield) -> bool {
            true
        }
    }
    impl From<Yield> for Operation {
        fn from(val: Yield) -> Operation {
            Operation::Yield(val)
        }
    }
    /// All of the instructions available in the armv7 instruction set.
    pub enum Operation {
        AdcImmediate(AdcImmediate),
        AdcRegister(AdcRegister),
        AddImmediate(AddImmediate),
        AddRegister(AddRegister),
        AddSPImmediate(AddSPImmediate),
        AddSPRegister(AddSPRegister),
        Adr(Adr),
        AndImmediate(AndImmediate),
        AndRegister(AndRegister),
        AsrImmediate(AsrImmediate),
        AsrRegister(AsrRegister),
        B(B),
        Bfc(Bfc),
        Bfi(Bfi),
        BicImmediate(BicImmediate),
        BicRegister(BicRegister),
        Bkpt(Bkpt),
        Bl(Bl),
        Blx(Blx),
        Bx(Bx),
        Cbz(Cbz),
        Cdp(Cdp),
        Clrex(Clrex),
        Clz(Clz),
        CmnImmediate(CmnImmediate),
        CmnRegister(CmnRegister),
        CmpImmediate(CmpImmediate),
        CmpRegister(CmpRegister),
        Cps(Cps),
        Dbg(Dbg),
        Dmb(Dmb),
        Dsb(Dsb),
        EorImmediate(EorImmediate),
        EorRegister(EorRegister),
        Isb(Isb),
        It(It),
        Ldm(Ldm),
        Ldmdb(Ldmdb),
        LdrImmediate(LdrImmediate),
        LdrLiteral(LdrLiteral),
        LdrRegister(LdrRegister),
        LdrbImmediate(LdrbImmediate),
        LdrbLiteral(LdrbLiteral),
        LdrbRegister(LdrbRegister),
        Ldrbt(Ldrbt),
        LdrdImmediate(LdrdImmediate),
        LdrdLiteral(LdrdLiteral),
        Ldrex(Ldrex),
        Ldrexb(Ldrexb),
        Ldrexh(Ldrexh),
        LdrhImmediate(LdrhImmediate),
        LdrhLiteral(LdrhLiteral),
        LdrhRegister(LdrhRegister),
        Ldrht(Ldrht),
        LdrsbImmediate(LdrsbImmediate),
        LdrsbLiteral(LdrsbLiteral),
        LdrsbRegister(LdrsbRegister),
        Ldrsbt(Ldrsbt),
        LdrshImmediate(LdrshImmediate),
        LdrshLiteral(LdrshLiteral),
        LdrshRegister(LdrshRegister),
        Ldrsht(Ldrsht),
        Ldrt(Ldrt),
        LdcImmediate(LdcImmediate),
        LdcLiteral(LdcLiteral),
        LslImmediate(LslImmediate),
        LslRegister(LslRegister),
        LsrImmediate(LsrImmediate),
        LsrRegister(LsrRegister),
        Mcrr(Mcrr),
        Mcr(Mcr),
        Mla(Mla),
        Mls(Mls),
        MovImmediate(MovImmediate),
        MovRegister(MovRegister),
        Movt(Movt),
        Mrrc(Mrrc),
        Mrc(Mrc),
        Mrs(Mrs),
        Msr(Msr),
        Mul(Mul),
        MvnImmediate(MvnImmediate),
        MvnRegister(MvnRegister),
        Nop(Nop),
        OrnImmediate(OrnImmediate),
        OrnRegister(OrnRegister),
        OrrImmediate(OrrImmediate),
        OrrRegister(OrrRegister),
        Pkh(Pkh),
        PldImmediate(PldImmediate),
        PldLiteral(PldLiteral),
        PldRegister(PldRegister),
        PliImmediate(PliImmediate),
        PliRegister(PliRegister),
        Pop(Pop),
        Push(Push),
        Qadd(Qadd),
        Qadd16(Qadd16),
        Qadd8(Qadd8),
        Qasx(Qasx),
        Qdadd(Qdadd),
        Qdsub(Qdsub),
        Qsax(Qsax),
        Qsub(Qsub),
        Qsub16(Qsub16),
        Qsub8(Qsub8),
        Rbit(Rbit),
        Rev(Rev),
        Rev16(Rev16),
        Revsh(Revsh),
        RorImmediate(RorImmediate),
        RorRegister(RorRegister),
        Rrx(Rrx),
        RsbImmediate(RsbImmediate),
        RsbRegister(RsbRegister),
        Sadd16(Sadd16),
        Sadd8(Sadd8),
        Sasx(Sasx),
        SbcImmediate(SbcImmediate),
        SbcRegister(SbcRegister),
        Sbfx(Sbfx),
        Sdiv(Sdiv),
        Sel(Sel),
        Sev(Sev),
        Svc(Svc),
        Shadd16(Shadd16),
        Shadd8(Shadd8),
        Shasx(Shasx),
        Shsax(Shsax),
        Shsub16(Shsub16),
        Shsub8(Shsub8),
        Smla(Smla),
        Smlad(Smlad),
        Smlal(Smlal),
        SmlalSelective(SmlalSelective),
        Smlald(Smlald),
        Smlaw(Smlaw),
        Smlsd(Smlsd),
        Smlsld(Smlsld),
        Smmla(Smmla),
        Smmls(Smmls),
        Smmul(Smmul),
        Smuad(Smuad),
        Smul(Smul),
        Smull(Smull),
        Smulw(Smulw),
        Smusd(Smusd),
        Ssat(Ssat),
        Ssat16(Ssat16),
        Ssax(Ssax),
        Ssub16(Ssub16),
        Ssub8(Ssub8),
        Stm(Stm),
        Stmdb(Stmdb),
        StrImmediate(StrImmediate),
        StrRegister(StrRegister),
        StrbImmediate(StrbImmediate),
        StrbRegister(StrbRegister),
        Strbt(Strbt),
        StrdImmediate(StrdImmediate),
        Strex(Strex),
        Strexb(Strexb),
        Strexh(Strexh),
        StrhImmediate(StrhImmediate),
        StrhRegister(StrhRegister),
        Strht(Strht),
        Strt(Strt),
        SubImmediate(SubImmediate),
        SubRegister(SubRegister),
        Stc(Stc),
        SubSpMinusImmediate(SubSpMinusImmediate),
        SubSpMinusRegister(SubSpMinusRegister),
        Sxtab(Sxtab),
        Sxtab16(Sxtab16),
        Sxtah(Sxtah),
        Sxtb(Sxtb),
        Sxtb16(Sxtb16),
        Sxth(Sxth),
        Tb(Tb),
        TeqImmediate(TeqImmediate),
        TeqRegister(TeqRegister),
        TstImmediate(TstImmediate),
        TstRegister(TstRegister),
        Uadd16(Uadd16),
        Uadd8(Uadd8),
        Uasx(Uasx),
        Ubfx(Ubfx),
        Udf(Udf),
        Udiv(Udiv),
        Uhadd16(Uhadd16),
        Uhadd8(Uhadd8),
        Uhasx(Uhasx),
        Uhsax(Uhsax),
        Uhsub16(Uhsub16),
        Uhsub8(Uhsub8),
        Umaal(Umaal),
        Umlal(Umlal),
        Umull(Umull),
        Uqadd16(Uqadd16),
        Uqadd8(Uqadd8),
        Uqasx(Uqasx),
        Uqsax(Uqsax),
        Uqsub16(Uqsub16),
        Uqsub8(Uqsub8),
        Uqsad8(Uqsad8),
        Usada8(Usada8),
        Usad8(Usad8),
        Usat(Usat),
        Usat16(Usat16),
        Usax(Usax),
        Usub16(Usub16),
        Usub8(Usub8),
        Uxtab(Uxtab),
        Uxtab16(Uxtab16),
        Uxtah(Uxtah),
        Uxtb(Uxtb),
        Uxtb16(Uxtb16),
        Uxth(Uxth),
        VselF32(VselF32),
        VselF64(VselF64),
        VmlF32(VmlF32),
        VmlF64(VmlF64),
        VnmlF32(VnmlF32),
        VnmlF64(VnmlF64),
        VnmulF32(VnmulF32),
        VnmulF64(VnmulF64),
        VmulF32(VmulF32),
        VmulF64(VmulF64),
        VaddF32(VaddF32),
        VaddF64(VaddF64),
        VsubF32(VsubF32),
        VsubF64(VsubF64),
        VdivF32(VdivF32),
        VdivF64(VdivF64),
        VmaxF32(VmaxF32),
        VmaxF64(VmaxF64),
        VminF32(VminF32),
        VminF64(VminF64),
        VmovImmediateF32(VmovImmediateF32),
        VmovImmediateF64(VmovImmediateF64),
        VmovRegisterF32(VmovRegisterF32),
        VmovRegisterF64(VmovRegisterF64),
        VabsF32(VabsF32),
        VabsF64(VabsF64),
        VnegF32(VnegF32),
        VnegF64(VnegF64),
        VsqrtF32(VsqrtF32),
        VsqrtF64(VsqrtF64),
        VcvtF32(VcvtF32),
        VcvtF64(VcvtF64),
        VcmpF32(VcmpF32),
        VcmpZeroF32(VcmpZeroF32),
        VcmpZeroF64(VcmpZeroF64),
        VrintF32(VrintF32),
        VrintF64(VrintF64),
        VcvtF64F32(VcvtF64F32),
        VcvtF32F64(VcvtF32F64),
        Vcvt(Vcvt),
        VrintCustomRoundingF32(VrintCustomRoundingF32),
        VrintCustomRoundingF64(VrintCustomRoundingF64),
        VcvtCustomRoundingF64F32(VcvtCustomRoundingF64F32),
        VcvtCustomRoundingF32F64(VcvtCustomRoundingF32F64),
        Wfe(Wfe),
        Wfi(Wfi),
        Yield(Yield),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Operation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Operation::AdcImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AdcImmediate",
                        &__self_0,
                    )
                }
                Operation::AdcRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AdcRegister",
                        &__self_0,
                    )
                }
                Operation::AddImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AddImmediate",
                        &__self_0,
                    )
                }
                Operation::AddRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AddRegister",
                        &__self_0,
                    )
                }
                Operation::AddSPImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AddSPImmediate",
                        &__self_0,
                    )
                }
                Operation::AddSPRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AddSPRegister",
                        &__self_0,
                    )
                }
                Operation::Adr(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Adr",
                        &__self_0,
                    )
                }
                Operation::AndImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AndImmediate",
                        &__self_0,
                    )
                }
                Operation::AndRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AndRegister",
                        &__self_0,
                    )
                }
                Operation::AsrImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AsrImmediate",
                        &__self_0,
                    )
                }
                Operation::AsrRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AsrRegister",
                        &__self_0,
                    )
                }
                Operation::B(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "B", &__self_0)
                }
                Operation::Bfc(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bfc",
                        &__self_0,
                    )
                }
                Operation::Bfi(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bfi",
                        &__self_0,
                    )
                }
                Operation::BicImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BicImmediate",
                        &__self_0,
                    )
                }
                Operation::BicRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BicRegister",
                        &__self_0,
                    )
                }
                Operation::Bkpt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bkpt",
                        &__self_0,
                    )
                }
                Operation::Bl(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Bl", &__self_0)
                }
                Operation::Blx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Blx",
                        &__self_0,
                    )
                }
                Operation::Bx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Bx", &__self_0)
                }
                Operation::Cbz(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Cbz",
                        &__self_0,
                    )
                }
                Operation::Cdp(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Cdp",
                        &__self_0,
                    )
                }
                Operation::Clrex(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Clrex",
                        &__self_0,
                    )
                }
                Operation::Clz(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Clz",
                        &__self_0,
                    )
                }
                Operation::CmnImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CmnImmediate",
                        &__self_0,
                    )
                }
                Operation::CmnRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CmnRegister",
                        &__self_0,
                    )
                }
                Operation::CmpImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CmpImmediate",
                        &__self_0,
                    )
                }
                Operation::CmpRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CmpRegister",
                        &__self_0,
                    )
                }
                Operation::Cps(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Cps",
                        &__self_0,
                    )
                }
                Operation::Dbg(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dbg",
                        &__self_0,
                    )
                }
                Operation::Dmb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dmb",
                        &__self_0,
                    )
                }
                Operation::Dsb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dsb",
                        &__self_0,
                    )
                }
                Operation::EorImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EorImmediate",
                        &__self_0,
                    )
                }
                Operation::EorRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EorRegister",
                        &__self_0,
                    )
                }
                Operation::Isb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Isb",
                        &__self_0,
                    )
                }
                Operation::It(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "It", &__self_0)
                }
                Operation::Ldm(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldm",
                        &__self_0,
                    )
                }
                Operation::Ldmdb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldmdb",
                        &__self_0,
                    )
                }
                Operation::LdrImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrImmediate",
                        &__self_0,
                    )
                }
                Operation::LdrLiteral(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrLiteral",
                        &__self_0,
                    )
                }
                Operation::LdrRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrRegister",
                        &__self_0,
                    )
                }
                Operation::LdrbImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrbImmediate",
                        &__self_0,
                    )
                }
                Operation::LdrbLiteral(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrbLiteral",
                        &__self_0,
                    )
                }
                Operation::LdrbRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrbRegister",
                        &__self_0,
                    )
                }
                Operation::Ldrbt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldrbt",
                        &__self_0,
                    )
                }
                Operation::LdrdImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrdImmediate",
                        &__self_0,
                    )
                }
                Operation::LdrdLiteral(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrdLiteral",
                        &__self_0,
                    )
                }
                Operation::Ldrex(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldrex",
                        &__self_0,
                    )
                }
                Operation::Ldrexb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldrexb",
                        &__self_0,
                    )
                }
                Operation::Ldrexh(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldrexh",
                        &__self_0,
                    )
                }
                Operation::LdrhImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrhImmediate",
                        &__self_0,
                    )
                }
                Operation::LdrhLiteral(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrhLiteral",
                        &__self_0,
                    )
                }
                Operation::LdrhRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrhRegister",
                        &__self_0,
                    )
                }
                Operation::Ldrht(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldrht",
                        &__self_0,
                    )
                }
                Operation::LdrsbImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrsbImmediate",
                        &__self_0,
                    )
                }
                Operation::LdrsbLiteral(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrsbLiteral",
                        &__self_0,
                    )
                }
                Operation::LdrsbRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrsbRegister",
                        &__self_0,
                    )
                }
                Operation::Ldrsbt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldrsbt",
                        &__self_0,
                    )
                }
                Operation::LdrshImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrshImmediate",
                        &__self_0,
                    )
                }
                Operation::LdrshLiteral(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrshLiteral",
                        &__self_0,
                    )
                }
                Operation::LdrshRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdrshRegister",
                        &__self_0,
                    )
                }
                Operation::Ldrsht(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldrsht",
                        &__self_0,
                    )
                }
                Operation::Ldrt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ldrt",
                        &__self_0,
                    )
                }
                Operation::LdcImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdcImmediate",
                        &__self_0,
                    )
                }
                Operation::LdcLiteral(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LdcLiteral",
                        &__self_0,
                    )
                }
                Operation::LslImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LslImmediate",
                        &__self_0,
                    )
                }
                Operation::LslRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LslRegister",
                        &__self_0,
                    )
                }
                Operation::LsrImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LsrImmediate",
                        &__self_0,
                    )
                }
                Operation::LsrRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LsrRegister",
                        &__self_0,
                    )
                }
                Operation::Mcrr(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mcrr",
                        &__self_0,
                    )
                }
                Operation::Mcr(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mcr",
                        &__self_0,
                    )
                }
                Operation::Mla(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mla",
                        &__self_0,
                    )
                }
                Operation::Mls(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mls",
                        &__self_0,
                    )
                }
                Operation::MovImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MovImmediate",
                        &__self_0,
                    )
                }
                Operation::MovRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MovRegister",
                        &__self_0,
                    )
                }
                Operation::Movt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Movt",
                        &__self_0,
                    )
                }
                Operation::Mrrc(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mrrc",
                        &__self_0,
                    )
                }
                Operation::Mrc(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mrc",
                        &__self_0,
                    )
                }
                Operation::Mrs(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mrs",
                        &__self_0,
                    )
                }
                Operation::Msr(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Msr",
                        &__self_0,
                    )
                }
                Operation::Mul(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mul",
                        &__self_0,
                    )
                }
                Operation::MvnImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MvnImmediate",
                        &__self_0,
                    )
                }
                Operation::MvnRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MvnRegister",
                        &__self_0,
                    )
                }
                Operation::Nop(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Nop",
                        &__self_0,
                    )
                }
                Operation::OrnImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OrnImmediate",
                        &__self_0,
                    )
                }
                Operation::OrnRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OrnRegister",
                        &__self_0,
                    )
                }
                Operation::OrrImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OrrImmediate",
                        &__self_0,
                    )
                }
                Operation::OrrRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OrrRegister",
                        &__self_0,
                    )
                }
                Operation::Pkh(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Pkh",
                        &__self_0,
                    )
                }
                Operation::PldImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PldImmediate",
                        &__self_0,
                    )
                }
                Operation::PldLiteral(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PldLiteral",
                        &__self_0,
                    )
                }
                Operation::PldRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PldRegister",
                        &__self_0,
                    )
                }
                Operation::PliImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PliImmediate",
                        &__self_0,
                    )
                }
                Operation::PliRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PliRegister",
                        &__self_0,
                    )
                }
                Operation::Pop(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Pop",
                        &__self_0,
                    )
                }
                Operation::Push(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Push",
                        &__self_0,
                    )
                }
                Operation::Qadd(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qadd",
                        &__self_0,
                    )
                }
                Operation::Qadd16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qadd16",
                        &__self_0,
                    )
                }
                Operation::Qadd8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qadd8",
                        &__self_0,
                    )
                }
                Operation::Qasx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qasx",
                        &__self_0,
                    )
                }
                Operation::Qdadd(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qdadd",
                        &__self_0,
                    )
                }
                Operation::Qdsub(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qdsub",
                        &__self_0,
                    )
                }
                Operation::Qsax(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qsax",
                        &__self_0,
                    )
                }
                Operation::Qsub(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qsub",
                        &__self_0,
                    )
                }
                Operation::Qsub16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qsub16",
                        &__self_0,
                    )
                }
                Operation::Qsub8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Qsub8",
                        &__self_0,
                    )
                }
                Operation::Rbit(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Rbit",
                        &__self_0,
                    )
                }
                Operation::Rev(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Rev",
                        &__self_0,
                    )
                }
                Operation::Rev16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Rev16",
                        &__self_0,
                    )
                }
                Operation::Revsh(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Revsh",
                        &__self_0,
                    )
                }
                Operation::RorImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RorImmediate",
                        &__self_0,
                    )
                }
                Operation::RorRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RorRegister",
                        &__self_0,
                    )
                }
                Operation::Rrx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Rrx",
                        &__self_0,
                    )
                }
                Operation::RsbImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RsbImmediate",
                        &__self_0,
                    )
                }
                Operation::RsbRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RsbRegister",
                        &__self_0,
                    )
                }
                Operation::Sadd16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sadd16",
                        &__self_0,
                    )
                }
                Operation::Sadd8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sadd8",
                        &__self_0,
                    )
                }
                Operation::Sasx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sasx",
                        &__self_0,
                    )
                }
                Operation::SbcImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SbcImmediate",
                        &__self_0,
                    )
                }
                Operation::SbcRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SbcRegister",
                        &__self_0,
                    )
                }
                Operation::Sbfx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sbfx",
                        &__self_0,
                    )
                }
                Operation::Sdiv(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sdiv",
                        &__self_0,
                    )
                }
                Operation::Sel(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sel",
                        &__self_0,
                    )
                }
                Operation::Sev(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sev",
                        &__self_0,
                    )
                }
                Operation::Svc(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Svc",
                        &__self_0,
                    )
                }
                Operation::Shadd16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Shadd16",
                        &__self_0,
                    )
                }
                Operation::Shadd8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Shadd8",
                        &__self_0,
                    )
                }
                Operation::Shasx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Shasx",
                        &__self_0,
                    )
                }
                Operation::Shsax(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Shsax",
                        &__self_0,
                    )
                }
                Operation::Shsub16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Shsub16",
                        &__self_0,
                    )
                }
                Operation::Shsub8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Shsub8",
                        &__self_0,
                    )
                }
                Operation::Smla(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smla",
                        &__self_0,
                    )
                }
                Operation::Smlad(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smlad",
                        &__self_0,
                    )
                }
                Operation::Smlal(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smlal",
                        &__self_0,
                    )
                }
                Operation::SmlalSelective(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SmlalSelective",
                        &__self_0,
                    )
                }
                Operation::Smlald(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smlald",
                        &__self_0,
                    )
                }
                Operation::Smlaw(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smlaw",
                        &__self_0,
                    )
                }
                Operation::Smlsd(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smlsd",
                        &__self_0,
                    )
                }
                Operation::Smlsld(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smlsld",
                        &__self_0,
                    )
                }
                Operation::Smmla(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smmla",
                        &__self_0,
                    )
                }
                Operation::Smmls(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smmls",
                        &__self_0,
                    )
                }
                Operation::Smmul(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smmul",
                        &__self_0,
                    )
                }
                Operation::Smuad(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smuad",
                        &__self_0,
                    )
                }
                Operation::Smul(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smul",
                        &__self_0,
                    )
                }
                Operation::Smull(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smull",
                        &__self_0,
                    )
                }
                Operation::Smulw(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smulw",
                        &__self_0,
                    )
                }
                Operation::Smusd(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Smusd",
                        &__self_0,
                    )
                }
                Operation::Ssat(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ssat",
                        &__self_0,
                    )
                }
                Operation::Ssat16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ssat16",
                        &__self_0,
                    )
                }
                Operation::Ssax(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ssax",
                        &__self_0,
                    )
                }
                Operation::Ssub16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ssub16",
                        &__self_0,
                    )
                }
                Operation::Ssub8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ssub8",
                        &__self_0,
                    )
                }
                Operation::Stm(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stm",
                        &__self_0,
                    )
                }
                Operation::Stmdb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stmdb",
                        &__self_0,
                    )
                }
                Operation::StrImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StrImmediate",
                        &__self_0,
                    )
                }
                Operation::StrRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StrRegister",
                        &__self_0,
                    )
                }
                Operation::StrbImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StrbImmediate",
                        &__self_0,
                    )
                }
                Operation::StrbRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StrbRegister",
                        &__self_0,
                    )
                }
                Operation::Strbt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Strbt",
                        &__self_0,
                    )
                }
                Operation::StrdImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StrdImmediate",
                        &__self_0,
                    )
                }
                Operation::Strex(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Strex",
                        &__self_0,
                    )
                }
                Operation::Strexb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Strexb",
                        &__self_0,
                    )
                }
                Operation::Strexh(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Strexh",
                        &__self_0,
                    )
                }
                Operation::StrhImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StrhImmediate",
                        &__self_0,
                    )
                }
                Operation::StrhRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StrhRegister",
                        &__self_0,
                    )
                }
                Operation::Strht(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Strht",
                        &__self_0,
                    )
                }
                Operation::Strt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Strt",
                        &__self_0,
                    )
                }
                Operation::SubImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SubImmediate",
                        &__self_0,
                    )
                }
                Operation::SubRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SubRegister",
                        &__self_0,
                    )
                }
                Operation::Stc(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stc",
                        &__self_0,
                    )
                }
                Operation::SubSpMinusImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SubSpMinusImmediate",
                        &__self_0,
                    )
                }
                Operation::SubSpMinusRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SubSpMinusRegister",
                        &__self_0,
                    )
                }
                Operation::Sxtab(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sxtab",
                        &__self_0,
                    )
                }
                Operation::Sxtab16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sxtab16",
                        &__self_0,
                    )
                }
                Operation::Sxtah(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sxtah",
                        &__self_0,
                    )
                }
                Operation::Sxtb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sxtb",
                        &__self_0,
                    )
                }
                Operation::Sxtb16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sxtb16",
                        &__self_0,
                    )
                }
                Operation::Sxth(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sxth",
                        &__self_0,
                    )
                }
                Operation::Tb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Tb", &__self_0)
                }
                Operation::TeqImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TeqImmediate",
                        &__self_0,
                    )
                }
                Operation::TeqRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TeqRegister",
                        &__self_0,
                    )
                }
                Operation::TstImmediate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TstImmediate",
                        &__self_0,
                    )
                }
                Operation::TstRegister(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TstRegister",
                        &__self_0,
                    )
                }
                Operation::Uadd16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uadd16",
                        &__self_0,
                    )
                }
                Operation::Uadd8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uadd8",
                        &__self_0,
                    )
                }
                Operation::Uasx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uasx",
                        &__self_0,
                    )
                }
                Operation::Ubfx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ubfx",
                        &__self_0,
                    )
                }
                Operation::Udf(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Udf",
                        &__self_0,
                    )
                }
                Operation::Udiv(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Udiv",
                        &__self_0,
                    )
                }
                Operation::Uhadd16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uhadd16",
                        &__self_0,
                    )
                }
                Operation::Uhadd8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uhadd8",
                        &__self_0,
                    )
                }
                Operation::Uhasx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uhasx",
                        &__self_0,
                    )
                }
                Operation::Uhsax(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uhsax",
                        &__self_0,
                    )
                }
                Operation::Uhsub16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uhsub16",
                        &__self_0,
                    )
                }
                Operation::Uhsub8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uhsub8",
                        &__self_0,
                    )
                }
                Operation::Umaal(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Umaal",
                        &__self_0,
                    )
                }
                Operation::Umlal(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Umlal",
                        &__self_0,
                    )
                }
                Operation::Umull(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Umull",
                        &__self_0,
                    )
                }
                Operation::Uqadd16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uqadd16",
                        &__self_0,
                    )
                }
                Operation::Uqadd8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uqadd8",
                        &__self_0,
                    )
                }
                Operation::Uqasx(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uqasx",
                        &__self_0,
                    )
                }
                Operation::Uqsax(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uqsax",
                        &__self_0,
                    )
                }
                Operation::Uqsub16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uqsub16",
                        &__self_0,
                    )
                }
                Operation::Uqsub8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uqsub8",
                        &__self_0,
                    )
                }
                Operation::Uqsad8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uqsad8",
                        &__self_0,
                    )
                }
                Operation::Usada8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Usada8",
                        &__self_0,
                    )
                }
                Operation::Usad8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Usad8",
                        &__self_0,
                    )
                }
                Operation::Usat(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Usat",
                        &__self_0,
                    )
                }
                Operation::Usat16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Usat16",
                        &__self_0,
                    )
                }
                Operation::Usax(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Usax",
                        &__self_0,
                    )
                }
                Operation::Usub16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Usub16",
                        &__self_0,
                    )
                }
                Operation::Usub8(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Usub8",
                        &__self_0,
                    )
                }
                Operation::Uxtab(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uxtab",
                        &__self_0,
                    )
                }
                Operation::Uxtab16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uxtab16",
                        &__self_0,
                    )
                }
                Operation::Uxtah(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uxtah",
                        &__self_0,
                    )
                }
                Operation::Uxtb(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uxtb",
                        &__self_0,
                    )
                }
                Operation::Uxtb16(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uxtb16",
                        &__self_0,
                    )
                }
                Operation::Uxth(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uxth",
                        &__self_0,
                    )
                }
                Operation::VselF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VselF32",
                        &__self_0,
                    )
                }
                Operation::VselF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VselF64",
                        &__self_0,
                    )
                }
                Operation::VmlF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmlF32",
                        &__self_0,
                    )
                }
                Operation::VmlF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmlF64",
                        &__self_0,
                    )
                }
                Operation::VnmlF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VnmlF32",
                        &__self_0,
                    )
                }
                Operation::VnmlF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VnmlF64",
                        &__self_0,
                    )
                }
                Operation::VnmulF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VnmulF32",
                        &__self_0,
                    )
                }
                Operation::VnmulF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VnmulF64",
                        &__self_0,
                    )
                }
                Operation::VmulF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmulF32",
                        &__self_0,
                    )
                }
                Operation::VmulF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmulF64",
                        &__self_0,
                    )
                }
                Operation::VaddF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VaddF32",
                        &__self_0,
                    )
                }
                Operation::VaddF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VaddF64",
                        &__self_0,
                    )
                }
                Operation::VsubF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VsubF32",
                        &__self_0,
                    )
                }
                Operation::VsubF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VsubF64",
                        &__self_0,
                    )
                }
                Operation::VdivF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VdivF32",
                        &__self_0,
                    )
                }
                Operation::VdivF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VdivF64",
                        &__self_0,
                    )
                }
                Operation::VmaxF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmaxF32",
                        &__self_0,
                    )
                }
                Operation::VmaxF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmaxF64",
                        &__self_0,
                    )
                }
                Operation::VminF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VminF32",
                        &__self_0,
                    )
                }
                Operation::VminF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VminF64",
                        &__self_0,
                    )
                }
                Operation::VmovImmediateF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmovImmediateF32",
                        &__self_0,
                    )
                }
                Operation::VmovImmediateF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmovImmediateF64",
                        &__self_0,
                    )
                }
                Operation::VmovRegisterF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmovRegisterF32",
                        &__self_0,
                    )
                }
                Operation::VmovRegisterF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VmovRegisterF64",
                        &__self_0,
                    )
                }
                Operation::VabsF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VabsF32",
                        &__self_0,
                    )
                }
                Operation::VabsF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VabsF64",
                        &__self_0,
                    )
                }
                Operation::VnegF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VnegF32",
                        &__self_0,
                    )
                }
                Operation::VnegF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VnegF64",
                        &__self_0,
                    )
                }
                Operation::VsqrtF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VsqrtF32",
                        &__self_0,
                    )
                }
                Operation::VsqrtF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VsqrtF64",
                        &__self_0,
                    )
                }
                Operation::VcvtF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcvtF32",
                        &__self_0,
                    )
                }
                Operation::VcvtF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcvtF64",
                        &__self_0,
                    )
                }
                Operation::VcmpF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcmpF32",
                        &__self_0,
                    )
                }
                Operation::VcmpZeroF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcmpZeroF32",
                        &__self_0,
                    )
                }
                Operation::VcmpZeroF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcmpZeroF64",
                        &__self_0,
                    )
                }
                Operation::VrintF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VrintF32",
                        &__self_0,
                    )
                }
                Operation::VrintF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VrintF64",
                        &__self_0,
                    )
                }
                Operation::VcvtF64F32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcvtF64F32",
                        &__self_0,
                    )
                }
                Operation::VcvtF32F64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcvtF32F64",
                        &__self_0,
                    )
                }
                Operation::Vcvt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Vcvt",
                        &__self_0,
                    )
                }
                Operation::VrintCustomRoundingF32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VrintCustomRoundingF32",
                        &__self_0,
                    )
                }
                Operation::VrintCustomRoundingF64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VrintCustomRoundingF64",
                        &__self_0,
                    )
                }
                Operation::VcvtCustomRoundingF64F32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcvtCustomRoundingF64F32",
                        &__self_0,
                    )
                }
                Operation::VcvtCustomRoundingF32F64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VcvtCustomRoundingF32F64",
                        &__self_0,
                    )
                }
                Operation::Wfe(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Wfe",
                        &__self_0,
                    )
                }
                Operation::Wfi(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Wfi",
                        &__self_0,
                    )
                }
                Operation::Yield(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Yield",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Operation {
        #[inline]
        fn clone(&self) -> Operation {
            match self {
                Operation::AdcImmediate(__self_0) => {
                    Operation::AdcImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::AdcRegister(__self_0) => {
                    Operation::AdcRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::AddImmediate(__self_0) => {
                    Operation::AddImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::AddRegister(__self_0) => {
                    Operation::AddRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::AddSPImmediate(__self_0) => {
                    Operation::AddSPImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::AddSPRegister(__self_0) => {
                    Operation::AddSPRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Adr(__self_0) => {
                    Operation::Adr(::core::clone::Clone::clone(__self_0))
                }
                Operation::AndImmediate(__self_0) => {
                    Operation::AndImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::AndRegister(__self_0) => {
                    Operation::AndRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::AsrImmediate(__self_0) => {
                    Operation::AsrImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::AsrRegister(__self_0) => {
                    Operation::AsrRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::B(__self_0) => {
                    Operation::B(::core::clone::Clone::clone(__self_0))
                }
                Operation::Bfc(__self_0) => {
                    Operation::Bfc(::core::clone::Clone::clone(__self_0))
                }
                Operation::Bfi(__self_0) => {
                    Operation::Bfi(::core::clone::Clone::clone(__self_0))
                }
                Operation::BicImmediate(__self_0) => {
                    Operation::BicImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::BicRegister(__self_0) => {
                    Operation::BicRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Bkpt(__self_0) => {
                    Operation::Bkpt(::core::clone::Clone::clone(__self_0))
                }
                Operation::Bl(__self_0) => {
                    Operation::Bl(::core::clone::Clone::clone(__self_0))
                }
                Operation::Blx(__self_0) => {
                    Operation::Blx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Bx(__self_0) => {
                    Operation::Bx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Cbz(__self_0) => {
                    Operation::Cbz(::core::clone::Clone::clone(__self_0))
                }
                Operation::Cdp(__self_0) => {
                    Operation::Cdp(::core::clone::Clone::clone(__self_0))
                }
                Operation::Clrex(__self_0) => {
                    Operation::Clrex(::core::clone::Clone::clone(__self_0))
                }
                Operation::Clz(__self_0) => {
                    Operation::Clz(::core::clone::Clone::clone(__self_0))
                }
                Operation::CmnImmediate(__self_0) => {
                    Operation::CmnImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::CmnRegister(__self_0) => {
                    Operation::CmnRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::CmpImmediate(__self_0) => {
                    Operation::CmpImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::CmpRegister(__self_0) => {
                    Operation::CmpRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Cps(__self_0) => {
                    Operation::Cps(::core::clone::Clone::clone(__self_0))
                }
                Operation::Dbg(__self_0) => {
                    Operation::Dbg(::core::clone::Clone::clone(__self_0))
                }
                Operation::Dmb(__self_0) => {
                    Operation::Dmb(::core::clone::Clone::clone(__self_0))
                }
                Operation::Dsb(__self_0) => {
                    Operation::Dsb(::core::clone::Clone::clone(__self_0))
                }
                Operation::EorImmediate(__self_0) => {
                    Operation::EorImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::EorRegister(__self_0) => {
                    Operation::EorRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Isb(__self_0) => {
                    Operation::Isb(::core::clone::Clone::clone(__self_0))
                }
                Operation::It(__self_0) => {
                    Operation::It(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldm(__self_0) => {
                    Operation::Ldm(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldmdb(__self_0) => {
                    Operation::Ldmdb(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrImmediate(__self_0) => {
                    Operation::LdrImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrLiteral(__self_0) => {
                    Operation::LdrLiteral(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrRegister(__self_0) => {
                    Operation::LdrRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrbImmediate(__self_0) => {
                    Operation::LdrbImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrbLiteral(__self_0) => {
                    Operation::LdrbLiteral(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrbRegister(__self_0) => {
                    Operation::LdrbRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldrbt(__self_0) => {
                    Operation::Ldrbt(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrdImmediate(__self_0) => {
                    Operation::LdrdImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrdLiteral(__self_0) => {
                    Operation::LdrdLiteral(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldrex(__self_0) => {
                    Operation::Ldrex(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldrexb(__self_0) => {
                    Operation::Ldrexb(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldrexh(__self_0) => {
                    Operation::Ldrexh(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrhImmediate(__self_0) => {
                    Operation::LdrhImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrhLiteral(__self_0) => {
                    Operation::LdrhLiteral(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrhRegister(__self_0) => {
                    Operation::LdrhRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldrht(__self_0) => {
                    Operation::Ldrht(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrsbImmediate(__self_0) => {
                    Operation::LdrsbImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrsbLiteral(__self_0) => {
                    Operation::LdrsbLiteral(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrsbRegister(__self_0) => {
                    Operation::LdrsbRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldrsbt(__self_0) => {
                    Operation::Ldrsbt(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrshImmediate(__self_0) => {
                    Operation::LdrshImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrshLiteral(__self_0) => {
                    Operation::LdrshLiteral(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdrshRegister(__self_0) => {
                    Operation::LdrshRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldrsht(__self_0) => {
                    Operation::Ldrsht(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ldrt(__self_0) => {
                    Operation::Ldrt(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdcImmediate(__self_0) => {
                    Operation::LdcImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LdcLiteral(__self_0) => {
                    Operation::LdcLiteral(::core::clone::Clone::clone(__self_0))
                }
                Operation::LslImmediate(__self_0) => {
                    Operation::LslImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LslRegister(__self_0) => {
                    Operation::LslRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::LsrImmediate(__self_0) => {
                    Operation::LsrImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::LsrRegister(__self_0) => {
                    Operation::LsrRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Mcrr(__self_0) => {
                    Operation::Mcrr(::core::clone::Clone::clone(__self_0))
                }
                Operation::Mcr(__self_0) => {
                    Operation::Mcr(::core::clone::Clone::clone(__self_0))
                }
                Operation::Mla(__self_0) => {
                    Operation::Mla(::core::clone::Clone::clone(__self_0))
                }
                Operation::Mls(__self_0) => {
                    Operation::Mls(::core::clone::Clone::clone(__self_0))
                }
                Operation::MovImmediate(__self_0) => {
                    Operation::MovImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::MovRegister(__self_0) => {
                    Operation::MovRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Movt(__self_0) => {
                    Operation::Movt(::core::clone::Clone::clone(__self_0))
                }
                Operation::Mrrc(__self_0) => {
                    Operation::Mrrc(::core::clone::Clone::clone(__self_0))
                }
                Operation::Mrc(__self_0) => {
                    Operation::Mrc(::core::clone::Clone::clone(__self_0))
                }
                Operation::Mrs(__self_0) => {
                    Operation::Mrs(::core::clone::Clone::clone(__self_0))
                }
                Operation::Msr(__self_0) => {
                    Operation::Msr(::core::clone::Clone::clone(__self_0))
                }
                Operation::Mul(__self_0) => {
                    Operation::Mul(::core::clone::Clone::clone(__self_0))
                }
                Operation::MvnImmediate(__self_0) => {
                    Operation::MvnImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::MvnRegister(__self_0) => {
                    Operation::MvnRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Nop(__self_0) => {
                    Operation::Nop(::core::clone::Clone::clone(__self_0))
                }
                Operation::OrnImmediate(__self_0) => {
                    Operation::OrnImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::OrnRegister(__self_0) => {
                    Operation::OrnRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::OrrImmediate(__self_0) => {
                    Operation::OrrImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::OrrRegister(__self_0) => {
                    Operation::OrrRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Pkh(__self_0) => {
                    Operation::Pkh(::core::clone::Clone::clone(__self_0))
                }
                Operation::PldImmediate(__self_0) => {
                    Operation::PldImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::PldLiteral(__self_0) => {
                    Operation::PldLiteral(::core::clone::Clone::clone(__self_0))
                }
                Operation::PldRegister(__self_0) => {
                    Operation::PldRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::PliImmediate(__self_0) => {
                    Operation::PliImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::PliRegister(__self_0) => {
                    Operation::PliRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Pop(__self_0) => {
                    Operation::Pop(::core::clone::Clone::clone(__self_0))
                }
                Operation::Push(__self_0) => {
                    Operation::Push(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qadd(__self_0) => {
                    Operation::Qadd(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qadd16(__self_0) => {
                    Operation::Qadd16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qadd8(__self_0) => {
                    Operation::Qadd8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qasx(__self_0) => {
                    Operation::Qasx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qdadd(__self_0) => {
                    Operation::Qdadd(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qdsub(__self_0) => {
                    Operation::Qdsub(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qsax(__self_0) => {
                    Operation::Qsax(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qsub(__self_0) => {
                    Operation::Qsub(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qsub16(__self_0) => {
                    Operation::Qsub16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Qsub8(__self_0) => {
                    Operation::Qsub8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Rbit(__self_0) => {
                    Operation::Rbit(::core::clone::Clone::clone(__self_0))
                }
                Operation::Rev(__self_0) => {
                    Operation::Rev(::core::clone::Clone::clone(__self_0))
                }
                Operation::Rev16(__self_0) => {
                    Operation::Rev16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Revsh(__self_0) => {
                    Operation::Revsh(::core::clone::Clone::clone(__self_0))
                }
                Operation::RorImmediate(__self_0) => {
                    Operation::RorImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::RorRegister(__self_0) => {
                    Operation::RorRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Rrx(__self_0) => {
                    Operation::Rrx(::core::clone::Clone::clone(__self_0))
                }
                Operation::RsbImmediate(__self_0) => {
                    Operation::RsbImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::RsbRegister(__self_0) => {
                    Operation::RsbRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sadd16(__self_0) => {
                    Operation::Sadd16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sadd8(__self_0) => {
                    Operation::Sadd8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sasx(__self_0) => {
                    Operation::Sasx(::core::clone::Clone::clone(__self_0))
                }
                Operation::SbcImmediate(__self_0) => {
                    Operation::SbcImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::SbcRegister(__self_0) => {
                    Operation::SbcRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sbfx(__self_0) => {
                    Operation::Sbfx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sdiv(__self_0) => {
                    Operation::Sdiv(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sel(__self_0) => {
                    Operation::Sel(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sev(__self_0) => {
                    Operation::Sev(::core::clone::Clone::clone(__self_0))
                }
                Operation::Svc(__self_0) => {
                    Operation::Svc(::core::clone::Clone::clone(__self_0))
                }
                Operation::Shadd16(__self_0) => {
                    Operation::Shadd16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Shadd8(__self_0) => {
                    Operation::Shadd8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Shasx(__self_0) => {
                    Operation::Shasx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Shsax(__self_0) => {
                    Operation::Shsax(::core::clone::Clone::clone(__self_0))
                }
                Operation::Shsub16(__self_0) => {
                    Operation::Shsub16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Shsub8(__self_0) => {
                    Operation::Shsub8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smla(__self_0) => {
                    Operation::Smla(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smlad(__self_0) => {
                    Operation::Smlad(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smlal(__self_0) => {
                    Operation::Smlal(::core::clone::Clone::clone(__self_0))
                }
                Operation::SmlalSelective(__self_0) => {
                    Operation::SmlalSelective(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smlald(__self_0) => {
                    Operation::Smlald(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smlaw(__self_0) => {
                    Operation::Smlaw(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smlsd(__self_0) => {
                    Operation::Smlsd(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smlsld(__self_0) => {
                    Operation::Smlsld(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smmla(__self_0) => {
                    Operation::Smmla(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smmls(__self_0) => {
                    Operation::Smmls(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smmul(__self_0) => {
                    Operation::Smmul(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smuad(__self_0) => {
                    Operation::Smuad(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smul(__self_0) => {
                    Operation::Smul(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smull(__self_0) => {
                    Operation::Smull(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smulw(__self_0) => {
                    Operation::Smulw(::core::clone::Clone::clone(__self_0))
                }
                Operation::Smusd(__self_0) => {
                    Operation::Smusd(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ssat(__self_0) => {
                    Operation::Ssat(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ssat16(__self_0) => {
                    Operation::Ssat16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ssax(__self_0) => {
                    Operation::Ssax(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ssub16(__self_0) => {
                    Operation::Ssub16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ssub8(__self_0) => {
                    Operation::Ssub8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Stm(__self_0) => {
                    Operation::Stm(::core::clone::Clone::clone(__self_0))
                }
                Operation::Stmdb(__self_0) => {
                    Operation::Stmdb(::core::clone::Clone::clone(__self_0))
                }
                Operation::StrImmediate(__self_0) => {
                    Operation::StrImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::StrRegister(__self_0) => {
                    Operation::StrRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::StrbImmediate(__self_0) => {
                    Operation::StrbImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::StrbRegister(__self_0) => {
                    Operation::StrbRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Strbt(__self_0) => {
                    Operation::Strbt(::core::clone::Clone::clone(__self_0))
                }
                Operation::StrdImmediate(__self_0) => {
                    Operation::StrdImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::Strex(__self_0) => {
                    Operation::Strex(::core::clone::Clone::clone(__self_0))
                }
                Operation::Strexb(__self_0) => {
                    Operation::Strexb(::core::clone::Clone::clone(__self_0))
                }
                Operation::Strexh(__self_0) => {
                    Operation::Strexh(::core::clone::Clone::clone(__self_0))
                }
                Operation::StrhImmediate(__self_0) => {
                    Operation::StrhImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::StrhRegister(__self_0) => {
                    Operation::StrhRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Strht(__self_0) => {
                    Operation::Strht(::core::clone::Clone::clone(__self_0))
                }
                Operation::Strt(__self_0) => {
                    Operation::Strt(::core::clone::Clone::clone(__self_0))
                }
                Operation::SubImmediate(__self_0) => {
                    Operation::SubImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::SubRegister(__self_0) => {
                    Operation::SubRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Stc(__self_0) => {
                    Operation::Stc(::core::clone::Clone::clone(__self_0))
                }
                Operation::SubSpMinusImmediate(__self_0) => {
                    Operation::SubSpMinusImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::SubSpMinusRegister(__self_0) => {
                    Operation::SubSpMinusRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sxtab(__self_0) => {
                    Operation::Sxtab(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sxtab16(__self_0) => {
                    Operation::Sxtab16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sxtah(__self_0) => {
                    Operation::Sxtah(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sxtb(__self_0) => {
                    Operation::Sxtb(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sxtb16(__self_0) => {
                    Operation::Sxtb16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Sxth(__self_0) => {
                    Operation::Sxth(::core::clone::Clone::clone(__self_0))
                }
                Operation::Tb(__self_0) => {
                    Operation::Tb(::core::clone::Clone::clone(__self_0))
                }
                Operation::TeqImmediate(__self_0) => {
                    Operation::TeqImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::TeqRegister(__self_0) => {
                    Operation::TeqRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::TstImmediate(__self_0) => {
                    Operation::TstImmediate(::core::clone::Clone::clone(__self_0))
                }
                Operation::TstRegister(__self_0) => {
                    Operation::TstRegister(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uadd16(__self_0) => {
                    Operation::Uadd16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uadd8(__self_0) => {
                    Operation::Uadd8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uasx(__self_0) => {
                    Operation::Uasx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Ubfx(__self_0) => {
                    Operation::Ubfx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Udf(__self_0) => {
                    Operation::Udf(::core::clone::Clone::clone(__self_0))
                }
                Operation::Udiv(__self_0) => {
                    Operation::Udiv(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uhadd16(__self_0) => {
                    Operation::Uhadd16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uhadd8(__self_0) => {
                    Operation::Uhadd8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uhasx(__self_0) => {
                    Operation::Uhasx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uhsax(__self_0) => {
                    Operation::Uhsax(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uhsub16(__self_0) => {
                    Operation::Uhsub16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uhsub8(__self_0) => {
                    Operation::Uhsub8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Umaal(__self_0) => {
                    Operation::Umaal(::core::clone::Clone::clone(__self_0))
                }
                Operation::Umlal(__self_0) => {
                    Operation::Umlal(::core::clone::Clone::clone(__self_0))
                }
                Operation::Umull(__self_0) => {
                    Operation::Umull(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uqadd16(__self_0) => {
                    Operation::Uqadd16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uqadd8(__self_0) => {
                    Operation::Uqadd8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uqasx(__self_0) => {
                    Operation::Uqasx(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uqsax(__self_0) => {
                    Operation::Uqsax(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uqsub16(__self_0) => {
                    Operation::Uqsub16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uqsub8(__self_0) => {
                    Operation::Uqsub8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uqsad8(__self_0) => {
                    Operation::Uqsad8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Usada8(__self_0) => {
                    Operation::Usada8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Usad8(__self_0) => {
                    Operation::Usad8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Usat(__self_0) => {
                    Operation::Usat(::core::clone::Clone::clone(__self_0))
                }
                Operation::Usat16(__self_0) => {
                    Operation::Usat16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Usax(__self_0) => {
                    Operation::Usax(::core::clone::Clone::clone(__self_0))
                }
                Operation::Usub16(__self_0) => {
                    Operation::Usub16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Usub8(__self_0) => {
                    Operation::Usub8(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uxtab(__self_0) => {
                    Operation::Uxtab(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uxtab16(__self_0) => {
                    Operation::Uxtab16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uxtah(__self_0) => {
                    Operation::Uxtah(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uxtb(__self_0) => {
                    Operation::Uxtb(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uxtb16(__self_0) => {
                    Operation::Uxtb16(::core::clone::Clone::clone(__self_0))
                }
                Operation::Uxth(__self_0) => {
                    Operation::Uxth(::core::clone::Clone::clone(__self_0))
                }
                Operation::VselF32(__self_0) => {
                    Operation::VselF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VselF64(__self_0) => {
                    Operation::VselF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmlF32(__self_0) => {
                    Operation::VmlF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmlF64(__self_0) => {
                    Operation::VmlF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VnmlF32(__self_0) => {
                    Operation::VnmlF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VnmlF64(__self_0) => {
                    Operation::VnmlF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VnmulF32(__self_0) => {
                    Operation::VnmulF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VnmulF64(__self_0) => {
                    Operation::VnmulF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmulF32(__self_0) => {
                    Operation::VmulF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmulF64(__self_0) => {
                    Operation::VmulF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VaddF32(__self_0) => {
                    Operation::VaddF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VaddF64(__self_0) => {
                    Operation::VaddF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VsubF32(__self_0) => {
                    Operation::VsubF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VsubF64(__self_0) => {
                    Operation::VsubF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VdivF32(__self_0) => {
                    Operation::VdivF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VdivF64(__self_0) => {
                    Operation::VdivF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmaxF32(__self_0) => {
                    Operation::VmaxF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmaxF64(__self_0) => {
                    Operation::VmaxF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VminF32(__self_0) => {
                    Operation::VminF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VminF64(__self_0) => {
                    Operation::VminF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmovImmediateF32(__self_0) => {
                    Operation::VmovImmediateF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmovImmediateF64(__self_0) => {
                    Operation::VmovImmediateF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmovRegisterF32(__self_0) => {
                    Operation::VmovRegisterF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VmovRegisterF64(__self_0) => {
                    Operation::VmovRegisterF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VabsF32(__self_0) => {
                    Operation::VabsF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VabsF64(__self_0) => {
                    Operation::VabsF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VnegF32(__self_0) => {
                    Operation::VnegF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VnegF64(__self_0) => {
                    Operation::VnegF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VsqrtF32(__self_0) => {
                    Operation::VsqrtF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VsqrtF64(__self_0) => {
                    Operation::VsqrtF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VcvtF32(__self_0) => {
                    Operation::VcvtF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VcvtF64(__self_0) => {
                    Operation::VcvtF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VcmpF32(__self_0) => {
                    Operation::VcmpF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VcmpZeroF32(__self_0) => {
                    Operation::VcmpZeroF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VcmpZeroF64(__self_0) => {
                    Operation::VcmpZeroF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VrintF32(__self_0) => {
                    Operation::VrintF32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VrintF64(__self_0) => {
                    Operation::VrintF64(::core::clone::Clone::clone(__self_0))
                }
                Operation::VcvtF64F32(__self_0) => {
                    Operation::VcvtF64F32(::core::clone::Clone::clone(__self_0))
                }
                Operation::VcvtF32F64(__self_0) => {
                    Operation::VcvtF32F64(::core::clone::Clone::clone(__self_0))
                }
                Operation::Vcvt(__self_0) => {
                    Operation::Vcvt(::core::clone::Clone::clone(__self_0))
                }
                Operation::VrintCustomRoundingF32(__self_0) => {
                    Operation::VrintCustomRoundingF32(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                Operation::VrintCustomRoundingF64(__self_0) => {
                    Operation::VrintCustomRoundingF64(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                Operation::VcvtCustomRoundingF64F32(__self_0) => {
                    Operation::VcvtCustomRoundingF64F32(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                Operation::VcvtCustomRoundingF32F64(__self_0) => {
                    Operation::VcvtCustomRoundingF32F64(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                Operation::Wfe(__self_0) => {
                    Operation::Wfe(::core::clone::Clone::clone(__self_0))
                }
                Operation::Wfi(__self_0) => {
                    Operation::Wfi(::core::clone::Clone::clone(__self_0))
                }
                Operation::Yield(__self_0) => {
                    Operation::Yield(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Operation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Operation {
        #[inline]
        fn eq(&self, other: &Operation) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        Operation::AdcImmediate(__self_0),
                        Operation::AdcImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::AdcRegister(__self_0),
                        Operation::AdcRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::AddImmediate(__self_0),
                        Operation::AddImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::AddRegister(__self_0),
                        Operation::AddRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::AddSPImmediate(__self_0),
                        Operation::AddSPImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::AddSPRegister(__self_0),
                        Operation::AddSPRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Adr(__self_0), Operation::Adr(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::AndImmediate(__self_0),
                        Operation::AndImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::AndRegister(__self_0),
                        Operation::AndRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::AsrImmediate(__self_0),
                        Operation::AsrImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::AsrRegister(__self_0),
                        Operation::AsrRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::B(__self_0), Operation::B(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Bfc(__self_0), Operation::Bfc(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Bfi(__self_0), Operation::Bfi(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::BicImmediate(__self_0),
                        Operation::BicImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::BicRegister(__self_0),
                        Operation::BicRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Bkpt(__self_0), Operation::Bkpt(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Bl(__self_0), Operation::Bl(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Blx(__self_0), Operation::Blx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Bx(__self_0), Operation::Bx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Cbz(__self_0), Operation::Cbz(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Cdp(__self_0), Operation::Cdp(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Clrex(__self_0), Operation::Clrex(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Clz(__self_0), Operation::Clz(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::CmnImmediate(__self_0),
                        Operation::CmnImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::CmnRegister(__self_0),
                        Operation::CmnRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::CmpImmediate(__self_0),
                        Operation::CmpImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::CmpRegister(__self_0),
                        Operation::CmpRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Cps(__self_0), Operation::Cps(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Dbg(__self_0), Operation::Dbg(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Dmb(__self_0), Operation::Dmb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Dsb(__self_0), Operation::Dsb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::EorImmediate(__self_0),
                        Operation::EorImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::EorRegister(__self_0),
                        Operation::EorRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Isb(__self_0), Operation::Isb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::It(__self_0), Operation::It(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ldm(__self_0), Operation::Ldm(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ldmdb(__self_0), Operation::Ldmdb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::LdrImmediate(__self_0),
                        Operation::LdrImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrLiteral(__self_0),
                        Operation::LdrLiteral(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrRegister(__self_0),
                        Operation::LdrRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrbImmediate(__self_0),
                        Operation::LdrbImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrbLiteral(__self_0),
                        Operation::LdrbLiteral(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrbRegister(__self_0),
                        Operation::LdrbRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Ldrbt(__self_0), Operation::Ldrbt(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::LdrdImmediate(__self_0),
                        Operation::LdrdImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrdLiteral(__self_0),
                        Operation::LdrdLiteral(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Ldrex(__self_0), Operation::Ldrex(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ldrexb(__self_0), Operation::Ldrexb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ldrexh(__self_0), Operation::Ldrexh(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::LdrhImmediate(__self_0),
                        Operation::LdrhImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrhLiteral(__self_0),
                        Operation::LdrhLiteral(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrhRegister(__self_0),
                        Operation::LdrhRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Ldrht(__self_0), Operation::Ldrht(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::LdrsbImmediate(__self_0),
                        Operation::LdrsbImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrsbLiteral(__self_0),
                        Operation::LdrsbLiteral(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrsbRegister(__self_0),
                        Operation::LdrsbRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Ldrsbt(__self_0), Operation::Ldrsbt(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::LdrshImmediate(__self_0),
                        Operation::LdrshImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrshLiteral(__self_0),
                        Operation::LdrshLiteral(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdrshRegister(__self_0),
                        Operation::LdrshRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Ldrsht(__self_0), Operation::Ldrsht(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ldrt(__self_0), Operation::Ldrt(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::LdcImmediate(__self_0),
                        Operation::LdcImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LdcLiteral(__self_0),
                        Operation::LdcLiteral(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LslImmediate(__self_0),
                        Operation::LslImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LslRegister(__self_0),
                        Operation::LslRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LsrImmediate(__self_0),
                        Operation::LsrImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::LsrRegister(__self_0),
                        Operation::LsrRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Mcrr(__self_0), Operation::Mcrr(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Mcr(__self_0), Operation::Mcr(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Mla(__self_0), Operation::Mla(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Mls(__self_0), Operation::Mls(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::MovImmediate(__self_0),
                        Operation::MovImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::MovRegister(__self_0),
                        Operation::MovRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Movt(__self_0), Operation::Movt(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Mrrc(__self_0), Operation::Mrrc(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Mrc(__self_0), Operation::Mrc(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Mrs(__self_0), Operation::Mrs(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Msr(__self_0), Operation::Msr(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Mul(__self_0), Operation::Mul(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::MvnImmediate(__self_0),
                        Operation::MvnImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::MvnRegister(__self_0),
                        Operation::MvnRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Nop(__self_0), Operation::Nop(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::OrnImmediate(__self_0),
                        Operation::OrnImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::OrnRegister(__self_0),
                        Operation::OrnRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::OrrImmediate(__self_0),
                        Operation::OrrImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::OrrRegister(__self_0),
                        Operation::OrrRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Pkh(__self_0), Operation::Pkh(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::PldImmediate(__self_0),
                        Operation::PldImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::PldLiteral(__self_0),
                        Operation::PldLiteral(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::PldRegister(__self_0),
                        Operation::PldRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::PliImmediate(__self_0),
                        Operation::PliImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::PliRegister(__self_0),
                        Operation::PliRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Pop(__self_0), Operation::Pop(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Push(__self_0), Operation::Push(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qadd(__self_0), Operation::Qadd(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qadd16(__self_0), Operation::Qadd16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qadd8(__self_0), Operation::Qadd8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qasx(__self_0), Operation::Qasx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qdadd(__self_0), Operation::Qdadd(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qdsub(__self_0), Operation::Qdsub(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qsax(__self_0), Operation::Qsax(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qsub(__self_0), Operation::Qsub(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qsub16(__self_0), Operation::Qsub16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Qsub8(__self_0), Operation::Qsub8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Rbit(__self_0), Operation::Rbit(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Rev(__self_0), Operation::Rev(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Rev16(__self_0), Operation::Rev16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Revsh(__self_0), Operation::Revsh(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::RorImmediate(__self_0),
                        Operation::RorImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::RorRegister(__self_0),
                        Operation::RorRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Rrx(__self_0), Operation::Rrx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::RsbImmediate(__self_0),
                        Operation::RsbImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::RsbRegister(__self_0),
                        Operation::RsbRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Sadd16(__self_0), Operation::Sadd16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sadd8(__self_0), Operation::Sadd8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sasx(__self_0), Operation::Sasx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::SbcImmediate(__self_0),
                        Operation::SbcImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::SbcRegister(__self_0),
                        Operation::SbcRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Sbfx(__self_0), Operation::Sbfx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sdiv(__self_0), Operation::Sdiv(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sel(__self_0), Operation::Sel(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sev(__self_0), Operation::Sev(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Svc(__self_0), Operation::Svc(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Shadd16(__self_0), Operation::Shadd16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Shadd8(__self_0), Operation::Shadd8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Shasx(__self_0), Operation::Shasx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Shsax(__self_0), Operation::Shsax(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Shsub16(__self_0), Operation::Shsub16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Shsub8(__self_0), Operation::Shsub8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smla(__self_0), Operation::Smla(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smlad(__self_0), Operation::Smlad(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smlal(__self_0), Operation::Smlal(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::SmlalSelective(__self_0),
                        Operation::SmlalSelective(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Smlald(__self_0), Operation::Smlald(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smlaw(__self_0), Operation::Smlaw(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smlsd(__self_0), Operation::Smlsd(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smlsld(__self_0), Operation::Smlsld(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smmla(__self_0), Operation::Smmla(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smmls(__self_0), Operation::Smmls(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smmul(__self_0), Operation::Smmul(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smuad(__self_0), Operation::Smuad(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smul(__self_0), Operation::Smul(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smull(__self_0), Operation::Smull(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smulw(__self_0), Operation::Smulw(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Smusd(__self_0), Operation::Smusd(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ssat(__self_0), Operation::Ssat(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ssat16(__self_0), Operation::Ssat16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ssax(__self_0), Operation::Ssax(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ssub16(__self_0), Operation::Ssub16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ssub8(__self_0), Operation::Ssub8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Stm(__self_0), Operation::Stm(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Stmdb(__self_0), Operation::Stmdb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::StrImmediate(__self_0),
                        Operation::StrImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::StrRegister(__self_0),
                        Operation::StrRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::StrbImmediate(__self_0),
                        Operation::StrbImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::StrbRegister(__self_0),
                        Operation::StrbRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Strbt(__self_0), Operation::Strbt(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::StrdImmediate(__self_0),
                        Operation::StrdImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Strex(__self_0), Operation::Strex(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Strexb(__self_0), Operation::Strexb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Strexh(__self_0), Operation::Strexh(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::StrhImmediate(__self_0),
                        Operation::StrhImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::StrhRegister(__self_0),
                        Operation::StrhRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Strht(__self_0), Operation::Strht(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Strt(__self_0), Operation::Strt(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::SubImmediate(__self_0),
                        Operation::SubImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::SubRegister(__self_0),
                        Operation::SubRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Stc(__self_0), Operation::Stc(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::SubSpMinusImmediate(__self_0),
                        Operation::SubSpMinusImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::SubSpMinusRegister(__self_0),
                        Operation::SubSpMinusRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Sxtab(__self_0), Operation::Sxtab(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sxtab16(__self_0), Operation::Sxtab16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sxtah(__self_0), Operation::Sxtah(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sxtb(__self_0), Operation::Sxtb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sxtb16(__self_0), Operation::Sxtb16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Sxth(__self_0), Operation::Sxth(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Tb(__self_0), Operation::Tb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::TeqImmediate(__self_0),
                        Operation::TeqImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::TeqRegister(__self_0),
                        Operation::TeqRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::TstImmediate(__self_0),
                        Operation::TstImmediate(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::TstRegister(__self_0),
                        Operation::TstRegister(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Uadd16(__self_0), Operation::Uadd16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uadd8(__self_0), Operation::Uadd8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uasx(__self_0), Operation::Uasx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Ubfx(__self_0), Operation::Ubfx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Udf(__self_0), Operation::Udf(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Udiv(__self_0), Operation::Udiv(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uhadd16(__self_0), Operation::Uhadd16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uhadd8(__self_0), Operation::Uhadd8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uhasx(__self_0), Operation::Uhasx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uhsax(__self_0), Operation::Uhsax(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uhsub16(__self_0), Operation::Uhsub16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uhsub8(__self_0), Operation::Uhsub8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Umaal(__self_0), Operation::Umaal(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Umlal(__self_0), Operation::Umlal(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Umull(__self_0), Operation::Umull(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uqadd16(__self_0), Operation::Uqadd16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uqadd8(__self_0), Operation::Uqadd8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uqasx(__self_0), Operation::Uqasx(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uqsax(__self_0), Operation::Uqsax(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uqsub16(__self_0), Operation::Uqsub16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uqsub8(__self_0), Operation::Uqsub8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uqsad8(__self_0), Operation::Uqsad8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Usada8(__self_0), Operation::Usada8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Usad8(__self_0), Operation::Usad8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Usat(__self_0), Operation::Usat(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Usat16(__self_0), Operation::Usat16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Usax(__self_0), Operation::Usax(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Usub16(__self_0), Operation::Usub16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Usub8(__self_0), Operation::Usub8(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uxtab(__self_0), Operation::Uxtab(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uxtab16(__self_0), Operation::Uxtab16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uxtah(__self_0), Operation::Uxtah(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uxtb(__self_0), Operation::Uxtb(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uxtb16(__self_0), Operation::Uxtb16(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Uxth(__self_0), Operation::Uxth(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VselF32(__self_0), Operation::VselF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VselF64(__self_0), Operation::VselF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VmlF32(__self_0), Operation::VmlF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VmlF64(__self_0), Operation::VmlF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VnmlF32(__self_0), Operation::VnmlF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VnmlF64(__self_0), Operation::VnmlF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VnmulF32(__self_0), Operation::VnmulF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VnmulF64(__self_0), Operation::VnmulF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VmulF32(__self_0), Operation::VmulF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VmulF64(__self_0), Operation::VmulF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VaddF32(__self_0), Operation::VaddF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VaddF64(__self_0), Operation::VaddF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VsubF32(__self_0), Operation::VsubF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VsubF64(__self_0), Operation::VsubF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VdivF32(__self_0), Operation::VdivF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VdivF64(__self_0), Operation::VdivF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VmaxF32(__self_0), Operation::VmaxF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VmaxF64(__self_0), Operation::VmaxF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VminF32(__self_0), Operation::VminF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VminF64(__self_0), Operation::VminF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::VmovImmediateF32(__self_0),
                        Operation::VmovImmediateF32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::VmovImmediateF64(__self_0),
                        Operation::VmovImmediateF64(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::VmovRegisterF32(__self_0),
                        Operation::VmovRegisterF32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::VmovRegisterF64(__self_0),
                        Operation::VmovRegisterF64(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::VabsF32(__self_0), Operation::VabsF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VabsF64(__self_0), Operation::VabsF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VnegF32(__self_0), Operation::VnegF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VnegF64(__self_0), Operation::VnegF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VsqrtF32(__self_0), Operation::VsqrtF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VsqrtF64(__self_0), Operation::VsqrtF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VcvtF32(__self_0), Operation::VcvtF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VcvtF64(__self_0), Operation::VcvtF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VcmpF32(__self_0), Operation::VcmpF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::VcmpZeroF32(__self_0),
                        Operation::VcmpZeroF32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::VcmpZeroF64(__self_0),
                        Operation::VcmpZeroF64(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::VrintF32(__self_0), Operation::VrintF32(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::VrintF64(__self_0), Operation::VrintF64(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::VcvtF64F32(__self_0),
                        Operation::VcvtF64F32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::VcvtF32F64(__self_0),
                        Operation::VcvtF32F64(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Vcvt(__self_0), Operation::Vcvt(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        Operation::VrintCustomRoundingF32(__self_0),
                        Operation::VrintCustomRoundingF32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::VrintCustomRoundingF64(__self_0),
                        Operation::VrintCustomRoundingF64(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::VcvtCustomRoundingF64F32(__self_0),
                        Operation::VcvtCustomRoundingF64F32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        Operation::VcvtCustomRoundingF32F64(__self_0),
                        Operation::VcvtCustomRoundingF32F64(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Operation::Wfe(__self_0), Operation::Wfe(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Wfi(__self_0), Operation::Wfi(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Operation::Yield(__self_0), Operation::Yield(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    pub enum ConversionArgument {
        F32(F32Register),
        F64(F64Register),
        U32(Register),
        I32(Register),
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ConversionArgument {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ConversionArgument {
        #[inline]
        fn eq(&self, other: &ConversionArgument) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        ConversionArgument::F32(__self_0),
                        ConversionArgument::F32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        ConversionArgument::F64(__self_0),
                        ConversionArgument::F64(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        ConversionArgument::U32(__self_0),
                        ConversionArgument::U32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        ConversionArgument::I32(__self_0),
                        ConversionArgument::I32(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ConversionArgument {
        #[inline]
        fn clone(&self) -> ConversionArgument {
            match self {
                ConversionArgument::F32(__self_0) => {
                    ConversionArgument::F32(::core::clone::Clone::clone(__self_0))
                }
                ConversionArgument::F64(__self_0) => {
                    ConversionArgument::F64(::core::clone::Clone::clone(__self_0))
                }
                ConversionArgument::U32(__self_0) => {
                    ConversionArgument::U32(::core::clone::Clone::clone(__self_0))
                }
                ConversionArgument::I32(__self_0) => {
                    ConversionArgument::I32(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ConversionArgument {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ConversionArgument::F32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "F32",
                        &__self_0,
                    )
                }
                ConversionArgument::F64(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "F64",
                        &__self_0,
                    )
                }
                ConversionArgument::U32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "U32",
                        &__self_0,
                    )
                }
                ConversionArgument::I32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "I32",
                        &__self_0,
                    )
                }
            }
        }
    }
}
use std::fmt::Debug;
use arch::ArchError;
use asm::b16::B16;
use operation::Operation;
use crate::asm::b32::B32;
/// Representation of a armv7 program.
///
/// This struct is constructed via
/// [`ASM`](ASM::parse).
#[allow(dead_code)]
pub struct ASM {
    statements: Vec<(usize, operation::Operation)>,
}
#[automatically_derived]
#[allow(dead_code)]
impl ::core::fmt::Debug for ASM {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "ASM",
            "statements",
            &&self.statements,
        )
    }
}
/// Denotes that the element can be peeked `N` elements into the future.
pub trait Peek<T: Sized>: Sized {
    /// Peeks `N` steps forward.
    ///
    /// If the value `N` exceeds the remaining buffer then the function returns
    /// None.
    fn peek<const N: usize>(&mut self) -> Option<T>;
}
/// Denotes that a caller can consume `N` elements from the type.
pub trait Consume<T: Sized>: Sized + Peek<T> {
    /// Consumes `N` items of type `T` forward.
    ///
    /// If the value of `N` exceeds the remaining buffer then the function
    /// returns None and no items are consumed.
    fn consume<const N: usize>(&mut self) -> Option<[T; N]>;
}
/// Denotes that the type can be treated as a stream to be [`parsed`](Parse)
/// from.
pub trait Stream: Consume<u32> + Consume<u16> + Consume<u8> + Debug {
    /// consumes a single byte from the stream.
    fn step(&mut self) -> Option<u8> {
        Some(self.consume::<1>()?[0])
    }
    /// Gets the next element of type `T` in the buffer.
    fn next<T>(&mut self) -> Result<T, ParseError>
    where
        Self: Peek<T>,
    {
        match self.peek::<1>() {
            Some(word) => Ok(word),
            None => Err(ParseError::IncompleteProgram),
        }
    }
}
/// Denotes that the type can be constructed from a [`Stream`].
pub trait Parse {
    /// What the parser parses in to.
    type Target;
    /// Converts the stream in to an instance of [`Target`](Parse::Target).
    ///
    /// If the parsing is successful it [`consumes`](Consume) a number
    /// of elements from the [`Stream`]. If it does not successfully
    /// parse an element no elements are consumed from the stream.
    fn parse<T: Stream>(iter: &mut T) -> Result<Self::Target, ParseError>
    where
        Self: Sized;
}
pub(crate) trait ToOperation {
    /// Translates the encoded value in to a [`Operation`] instruction
    fn encoding_specific_operations(self) -> crate::operation::Operation;
}
/// Enumerates the errors that might occur during parsing [`ASM`].
pub enum ParseError {
    /// Thrown when the buffer is not long enough.
    /// The current instruction was not valid
    IncompleteProgram,
    /// Thrown when there is no matching 16 bit instruction
    ///
    /// Occurred while parsing the block in question
    Invalid16Bit(&'static str),
    /// Thrown when there is no matching 32 bit instruction
    ///
    /// Occurred while parsing the block in question
    Invalid32Bit(&'static str),
    /// Thrown when there is no matching
    Incomplete32Bit,
    /// Thrown when a field in an identifier is incorrect
    InvalidField(String),
    /// Thrown when a target register does not exist.
    InvalidRegister(u8),
    /// Thrown when a target register does not exist.
    InvalidFloatingPointRegister(u8),
    /// Thrown when a target
    /// ([IEEE754RoundingMode](crate::arch::register::IEEE754RoundingMode)])
    /// rounding mode does not exist.
    InvalidRoundingMode(u8),
    /// Thrown when an unpredictable instruction is used
    Unpredictable,
    /// Thrown when an undefined instruction is used
    Undefined,
    /// Thrown when a non covered case is reached
    IncompleteParser,
    /// Thrown when an invalid condition is requested
    InvalidCondition,
    /// Thrown when the parsing fails part way through parsing
    PartiallyParsed(Box<Self>, Vec<Operation>),
    /// Sub-crate [`arch`] threw an error
    ArchError(ArchError),
    /// Thrown when internal logic is faulty, this should never occur
    InternalError(&'static str),
}
#[automatically_derived]
impl ::core::fmt::Debug for ParseError {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ParseError::IncompleteProgram => {
                ::core::fmt::Formatter::write_str(f, "IncompleteProgram")
            }
            ParseError::Invalid16Bit(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Invalid16Bit",
                    &__self_0,
                )
            }
            ParseError::Invalid32Bit(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Invalid32Bit",
                    &__self_0,
                )
            }
            ParseError::Incomplete32Bit => {
                ::core::fmt::Formatter::write_str(f, "Incomplete32Bit")
            }
            ParseError::InvalidField(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InvalidField",
                    &__self_0,
                )
            }
            ParseError::InvalidRegister(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InvalidRegister",
                    &__self_0,
                )
            }
            ParseError::InvalidFloatingPointRegister(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InvalidFloatingPointRegister",
                    &__self_0,
                )
            }
            ParseError::InvalidRoundingMode(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InvalidRoundingMode",
                    &__self_0,
                )
            }
            ParseError::Unpredictable => {
                ::core::fmt::Formatter::write_str(f, "Unpredictable")
            }
            ParseError::Undefined => ::core::fmt::Formatter::write_str(f, "Undefined"),
            ParseError::IncompleteParser => {
                ::core::fmt::Formatter::write_str(f, "IncompleteParser")
            }
            ParseError::InvalidCondition => {
                ::core::fmt::Formatter::write_str(f, "InvalidCondition")
            }
            ParseError::PartiallyParsed(__self_0, __self_1) => {
                ::core::fmt::Formatter::debug_tuple_field2_finish(
                    f,
                    "PartiallyParsed",
                    __self_0,
                    &__self_1,
                )
            }
            ParseError::ArchError(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ArchError",
                    &__self_0,
                )
            }
            ParseError::InternalError(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InternalError",
                    &__self_0,
                )
            }
        }
    }
}
impl Parse for ASM {
    type Target = Self;
    fn parse<T: Stream>(iter: &mut T) -> Result<ASM, ParseError>
    where
        Self: Sized,
    {
        let mut stmts = Vec::new();
        while let Some(_halfword) = iter.peek::<1>() as Option<u16> {
            match Operation::parse(iter) {
                Ok(el) => stmts.push(el),
                Err(e) => {
                    return Err(
                        ParseError::PartiallyParsed(
                            Box::new(e),
                            stmts.into_iter().map(|el| el.1).collect(),
                        ),
                    );
                }
            };
        }
        Ok(stmts.into())
    }
}
impl Parse for operation::Operation {
    type Target = (usize, operation::Operation);
    fn parse<T: Stream>(
        iter: &mut T,
    ) -> Result<(usize, operation::Operation), ParseError>
    where
        Self: Sized,
    {
        let halfword: Option<u16> = iter.peek::<1>();
        if halfword.is_none() {
            return Err(ParseError::IncompleteProgram);
        }
        let halfword = halfword.unwrap();
        Ok(
            match halfword >> 11 {
                0b11101..=0b11111 => B32::parse(iter)?,
                _ => B16::parse(iter)?,
            },
        )
    }
}
impl From<Vec<(usize, Operation)>> for ASM {
    fn from(value: Vec<(usize, operation::Operation)>) -> Self {
        Self { statements: value }
    }
}
impl From<ASM> for Vec<(usize, Operation)> {
    fn from(value: ASM) -> Vec<(usize, Operation)> {
        value.statements
    }
}
/// Re-exports the needed types to use this crate.
pub mod prelude {
    pub use super::{Parse, Peek, Stream, ASM};
    pub use crate::{
        arch::{
            self, set_flags::SetFlags, wrapper_types::*, Condition, ImmShift, Register,
            RegisterList, Shift,
        },
        buffer::PeekableBuffer, operation::{self, Operation},
    };
}
